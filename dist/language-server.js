"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// ../../shims/importMeta.js
var importMeta;
var init_importMeta = __esm({
  "../../shims/importMeta.js"() {
    "use strict";
    importMeta = {
      url: `file://${process.cwd()}/node_modules`
    };
  }
});

// ../../node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/utils/is.js
var require_is = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/utils/is.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.thenable = exports2.typedArray = exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
    function boolean(value) {
      return value === true || value === false;
    }
    exports2.boolean = boolean;
    function string(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports2.string = string;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports2.number = number;
    function error(value) {
      return value instanceof Error;
    }
    exports2.error = error;
    function func(value) {
      return typeof value === "function";
    }
    exports2.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports2.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    exports2.stringArray = stringArray;
    function typedArray(value, check) {
      return Array.isArray(value) && value.every(check);
    }
    exports2.typedArray = typedArray;
    function thenable(value) {
      return value && func(value.then);
    }
    exports2.thenable = thenable;
  }
});

// ../../node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/is.js
var require_is2 = __commonJS({
  "../../node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/is.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
    function boolean(value) {
      return value === true || value === false;
    }
    exports2.boolean = boolean;
    function string(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports2.string = string;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports2.number = number;
    function error(value) {
      return value instanceof Error;
    }
    exports2.error = error;
    function func(value) {
      return typeof value === "function";
    }
    exports2.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports2.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    exports2.stringArray = stringArray;
  }
});

// ../../node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/messages.js
var require_messages = __commonJS({
  "../../node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/messages.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Message = exports2.NotificationType9 = exports2.NotificationType8 = exports2.NotificationType7 = exports2.NotificationType6 = exports2.NotificationType5 = exports2.NotificationType4 = exports2.NotificationType3 = exports2.NotificationType2 = exports2.NotificationType1 = exports2.NotificationType0 = exports2.NotificationType = exports2.RequestType9 = exports2.RequestType8 = exports2.RequestType7 = exports2.RequestType6 = exports2.RequestType5 = exports2.RequestType4 = exports2.RequestType3 = exports2.RequestType2 = exports2.RequestType1 = exports2.RequestType = exports2.RequestType0 = exports2.AbstractMessageSignature = exports2.ParameterStructures = exports2.ResponseError = exports2.ErrorCodes = void 0;
    var is = require_is2();
    var ErrorCodes;
    (function(ErrorCodes2) {
      ErrorCodes2.ParseError = -32700;
      ErrorCodes2.InvalidRequest = -32600;
      ErrorCodes2.MethodNotFound = -32601;
      ErrorCodes2.InvalidParams = -32602;
      ErrorCodes2.InternalError = -32603;
      ErrorCodes2.jsonrpcReservedErrorRangeStart = -32099;
      ErrorCodes2.serverErrorStart = -32099;
      ErrorCodes2.MessageWriteError = -32099;
      ErrorCodes2.MessageReadError = -32098;
      ErrorCodes2.PendingResponseRejected = -32097;
      ErrorCodes2.ConnectionInactive = -32096;
      ErrorCodes2.ServerNotInitialized = -32002;
      ErrorCodes2.UnknownErrorCode = -32001;
      ErrorCodes2.jsonrpcReservedErrorRangeEnd = -32e3;
      ErrorCodes2.serverErrorEnd = -32e3;
    })(ErrorCodes || (exports2.ErrorCodes = ErrorCodes = {}));
    var ResponseError = class _ResponseError extends Error {
      constructor(code, message, data) {
        super(message);
        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
        this.data = data;
        Object.setPrototypeOf(this, _ResponseError.prototype);
      }
      toJson() {
        const result = {
          code: this.code,
          message: this.message
        };
        if (this.data !== void 0) {
          result.data = this.data;
        }
        return result;
      }
    };
    exports2.ResponseError = ResponseError;
    var ParameterStructures = class _ParameterStructures {
      constructor(kind) {
        this.kind = kind;
      }
      static is(value) {
        return value === _ParameterStructures.auto || value === _ParameterStructures.byName || value === _ParameterStructures.byPosition;
      }
      toString() {
        return this.kind;
      }
    };
    exports2.ParameterStructures = ParameterStructures;
    ParameterStructures.auto = new ParameterStructures("auto");
    ParameterStructures.byPosition = new ParameterStructures("byPosition");
    ParameterStructures.byName = new ParameterStructures("byName");
    var AbstractMessageSignature = class {
      constructor(method, numberOfParams) {
        this.method = method;
        this.numberOfParams = numberOfParams;
      }
      get parameterStructures() {
        return ParameterStructures.auto;
      }
    };
    exports2.AbstractMessageSignature = AbstractMessageSignature;
    var RequestType0 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 0);
      }
    };
    exports2.RequestType0 = RequestType0;
    var RequestType = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.RequestType = RequestType;
    var RequestType1 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.RequestType1 = RequestType1;
    var RequestType2 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 2);
      }
    };
    exports2.RequestType2 = RequestType2;
    var RequestType3 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 3);
      }
    };
    exports2.RequestType3 = RequestType3;
    var RequestType4 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 4);
      }
    };
    exports2.RequestType4 = RequestType4;
    var RequestType5 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 5);
      }
    };
    exports2.RequestType5 = RequestType5;
    var RequestType6 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 6);
      }
    };
    exports2.RequestType6 = RequestType6;
    var RequestType7 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 7);
      }
    };
    exports2.RequestType7 = RequestType7;
    var RequestType8 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 8);
      }
    };
    exports2.RequestType8 = RequestType8;
    var RequestType9 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 9);
      }
    };
    exports2.RequestType9 = RequestType9;
    var NotificationType = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.NotificationType = NotificationType;
    var NotificationType0 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 0);
      }
    };
    exports2.NotificationType0 = NotificationType0;
    var NotificationType1 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.NotificationType1 = NotificationType1;
    var NotificationType2 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 2);
      }
    };
    exports2.NotificationType2 = NotificationType2;
    var NotificationType3 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 3);
      }
    };
    exports2.NotificationType3 = NotificationType3;
    var NotificationType4 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 4);
      }
    };
    exports2.NotificationType4 = NotificationType4;
    var NotificationType5 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 5);
      }
    };
    exports2.NotificationType5 = NotificationType5;
    var NotificationType6 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 6);
      }
    };
    exports2.NotificationType6 = NotificationType6;
    var NotificationType7 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 7);
      }
    };
    exports2.NotificationType7 = NotificationType7;
    var NotificationType8 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 8);
      }
    };
    exports2.NotificationType8 = NotificationType8;
    var NotificationType9 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 9);
      }
    };
    exports2.NotificationType9 = NotificationType9;
    var Message;
    (function(Message2) {
      function isRequest(message) {
        const candidate = message;
        return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
      }
      Message2.isRequest = isRequest;
      function isNotification(message) {
        const candidate = message;
        return candidate && is.string(candidate.method) && message.id === void 0;
      }
      Message2.isNotification = isNotification;
      function isResponse(message) {
        const candidate = message;
        return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
      }
      Message2.isResponse = isResponse;
    })(Message || (exports2.Message = Message = {}));
  }
});

// ../../node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/linkedMap.js
var require_linkedMap = __commonJS({
  "../../node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/linkedMap.js"(exports2) {
    "use strict";
    init_importMeta();
    var _a;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LRUCache = exports2.LinkedMap = exports2.Touch = void 0;
    var Touch;
    (function(Touch2) {
      Touch2.None = 0;
      Touch2.First = 1;
      Touch2.AsOld = Touch2.First;
      Touch2.Last = 2;
      Touch2.AsNew = Touch2.Last;
    })(Touch || (exports2.Touch = Touch = {}));
    var LinkedMap = class {
      constructor() {
        this[_a] = "LinkedMap";
        this._map = /* @__PURE__ */ new Map();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state = 0;
      }
      clear() {
        this._map.clear();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state++;
      }
      isEmpty() {
        return !this._head && !this._tail;
      }
      get size() {
        return this._size;
      }
      get first() {
        return this._head?.value;
      }
      get last() {
        return this._tail?.value;
      }
      has(key) {
        return this._map.has(key);
      }
      get(key, touch = Touch.None) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        if (touch !== Touch.None) {
          this.touch(item, touch);
        }
        return item.value;
      }
      set(key, value, touch = Touch.None) {
        let item = this._map.get(key);
        if (item) {
          item.value = value;
          if (touch !== Touch.None) {
            this.touch(item, touch);
          }
        } else {
          item = { key, value, next: void 0, previous: void 0 };
          switch (touch) {
            case Touch.None:
              this.addItemLast(item);
              break;
            case Touch.First:
              this.addItemFirst(item);
              break;
            case Touch.Last:
              this.addItemLast(item);
              break;
            default:
              this.addItemLast(item);
              break;
          }
          this._map.set(key, item);
          this._size++;
        }
        return this;
      }
      delete(key) {
        return !!this.remove(key);
      }
      remove(key) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        this._map.delete(key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      shift() {
        if (!this._head && !this._tail) {
          return void 0;
        }
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        const item = this._head;
        this._map.delete(item.key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      forEach(callbackfn, thisArg) {
        const state = this._state;
        let current = this._head;
        while (current) {
          if (thisArg) {
            callbackfn.bind(thisArg)(current.value, current.key, this);
          } else {
            callbackfn(current.value, current.key, this);
          }
          if (this._state !== state) {
            throw new Error(`LinkedMap got modified during iteration.`);
          }
          current = current.next;
        }
      }
      keys() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.key, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      values() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.value, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      entries() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: [current.key, current.value], done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      [(_a = Symbol.toStringTag, Symbol.iterator)]() {
        return this.entries();
      }
      trimOld(newSize) {
        if (newSize >= this.size) {
          return;
        }
        if (newSize === 0) {
          this.clear();
          return;
        }
        let current = this._head;
        let currentSize = this.size;
        while (current && currentSize > newSize) {
          this._map.delete(current.key);
          current = current.next;
          currentSize--;
        }
        this._head = current;
        this._size = currentSize;
        if (current) {
          current.previous = void 0;
        }
        this._state++;
      }
      addItemFirst(item) {
        if (!this._head && !this._tail) {
          this._tail = item;
        } else if (!this._head) {
          throw new Error("Invalid list");
        } else {
          item.next = this._head;
          this._head.previous = item;
        }
        this._head = item;
        this._state++;
      }
      addItemLast(item) {
        if (!this._head && !this._tail) {
          this._head = item;
        } else if (!this._tail) {
          throw new Error("Invalid list");
        } else {
          item.previous = this._tail;
          this._tail.next = item;
        }
        this._tail = item;
        this._state++;
      }
      removeItem(item) {
        if (item === this._head && item === this._tail) {
          this._head = void 0;
          this._tail = void 0;
        } else if (item === this._head) {
          if (!item.next) {
            throw new Error("Invalid list");
          }
          item.next.previous = void 0;
          this._head = item.next;
        } else if (item === this._tail) {
          if (!item.previous) {
            throw new Error("Invalid list");
          }
          item.previous.next = void 0;
          this._tail = item.previous;
        } else {
          const next = item.next;
          const previous = item.previous;
          if (!next || !previous) {
            throw new Error("Invalid list");
          }
          next.previous = previous;
          previous.next = next;
        }
        item.next = void 0;
        item.previous = void 0;
        this._state++;
      }
      touch(item, touch) {
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        if (touch !== Touch.First && touch !== Touch.Last) {
          return;
        }
        if (touch === Touch.First) {
          if (item === this._head) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._tail) {
            previous.next = void 0;
            this._tail = previous;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.previous = void 0;
          item.next = this._head;
          this._head.previous = item;
          this._head = item;
          this._state++;
        } else if (touch === Touch.Last) {
          if (item === this._tail) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._head) {
            next.previous = void 0;
            this._head = next;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.next = void 0;
          item.previous = this._tail;
          this._tail.next = item;
          this._tail = item;
          this._state++;
        }
      }
      toJSON() {
        const data = [];
        this.forEach((value, key) => {
          data.push([key, value]);
        });
        return data;
      }
      fromJSON(data) {
        this.clear();
        for (const [key, value] of data) {
          this.set(key, value);
        }
      }
    };
    exports2.LinkedMap = LinkedMap;
    var LRUCache2 = class extends LinkedMap {
      constructor(limit, ratio = 1) {
        super();
        this._limit = limit;
        this._ratio = Math.min(Math.max(0, ratio), 1);
      }
      get limit() {
        return this._limit;
      }
      set limit(limit) {
        this._limit = limit;
        this.checkTrim();
      }
      get ratio() {
        return this._ratio;
      }
      set ratio(ratio) {
        this._ratio = Math.min(Math.max(0, ratio), 1);
        this.checkTrim();
      }
      get(key, touch = Touch.AsNew) {
        return super.get(key, touch);
      }
      peek(key) {
        return super.get(key, Touch.None);
      }
      set(key, value) {
        super.set(key, value, Touch.Last);
        this.checkTrim();
        return this;
      }
      checkTrim() {
        if (this.size > this._limit) {
          this.trimOld(Math.round(this._limit * this._ratio));
        }
      }
    };
    exports2.LRUCache = LRUCache2;
  }
});

// ../../node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/disposable.js
var require_disposable = __commonJS({
  "../../node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/disposable.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Disposable = void 0;
    var Disposable;
    (function(Disposable2) {
      function create(func) {
        return {
          dispose: func
        };
      }
      Disposable2.create = create;
    })(Disposable || (exports2.Disposable = Disposable = {}));
  }
});

// ../../node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/ral.js
var require_ral = __commonJS({
  "../../node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/ral.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var _ral;
    function RAL() {
      if (_ral === void 0) {
        throw new Error(`No runtime abstraction layer installed`);
      }
      return _ral;
    }
    (function(RAL2) {
      function install(ral) {
        if (ral === void 0) {
          throw new Error(`No runtime abstraction layer provided`);
        }
        _ral = ral;
      }
      RAL2.install = install;
    })(RAL || (RAL = {}));
    exports2.default = RAL;
  }
});

// ../../node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/events.js
var require_events = __commonJS({
  "../../node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/events.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Emitter = exports2.Event = void 0;
    var ral_1 = require_ral();
    var Event;
    (function(Event2) {
      const _disposable = { dispose() {
      } };
      Event2.None = function() {
        return _disposable;
      };
    })(Event || (exports2.Event = Event = {}));
    var CallbackList = class {
      add(callback, context = null, bucket) {
        if (!this._callbacks) {
          this._callbacks = [];
          this._contexts = [];
        }
        this._callbacks.push(callback);
        this._contexts.push(context);
        if (Array.isArray(bucket)) {
          bucket.push({ dispose: () => this.remove(callback, context) });
        }
      }
      remove(callback, context = null) {
        if (!this._callbacks) {
          return;
        }
        let foundCallbackWithDifferentContext = false;
        for (let i = 0, len = this._callbacks.length; i < len; i++) {
          if (this._callbacks[i] === callback) {
            if (this._contexts[i] === context) {
              this._callbacks.splice(i, 1);
              this._contexts.splice(i, 1);
              return;
            } else {
              foundCallbackWithDifferentContext = true;
            }
          }
        }
        if (foundCallbackWithDifferentContext) {
          throw new Error("When adding a listener with a context, you should remove it with the same context");
        }
      }
      invoke(...args) {
        if (!this._callbacks) {
          return [];
        }
        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
        for (let i = 0, len = callbacks.length; i < len; i++) {
          try {
            ret.push(callbacks[i].apply(contexts[i], args));
          } catch (e) {
            (0, ral_1.default)().console.error(e);
          }
        }
        return ret;
      }
      isEmpty() {
        return !this._callbacks || this._callbacks.length === 0;
      }
      dispose() {
        this._callbacks = void 0;
        this._contexts = void 0;
      }
    };
    var Emitter = class _Emitter {
      constructor(_options) {
        this._options = _options;
      }
      /**
       * For the public to allow to subscribe
       * to events from this Emitter
       */
      get event() {
        if (!this._event) {
          this._event = (listener, thisArgs, disposables) => {
            if (!this._callbacks) {
              this._callbacks = new CallbackList();
            }
            if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
              this._options.onFirstListenerAdd(this);
            }
            this._callbacks.add(listener, thisArgs);
            const result = {
              dispose: () => {
                if (!this._callbacks) {
                  return;
                }
                this._callbacks.remove(listener, thisArgs);
                result.dispose = _Emitter._noop;
                if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                  this._options.onLastListenerRemove(this);
                }
              }
            };
            if (Array.isArray(disposables)) {
              disposables.push(result);
            }
            return result;
          };
        }
        return this._event;
      }
      /**
       * To be kept private to fire an event to
       * subscribers
       */
      fire(event) {
        if (this._callbacks) {
          this._callbacks.invoke.call(this._callbacks, event);
        }
      }
      dispose() {
        if (this._callbacks) {
          this._callbacks.dispose();
          this._callbacks = void 0;
        }
      }
    };
    exports2.Emitter = Emitter;
    Emitter._noop = function() {
    };
  }
});

// ../../node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/cancellation.js
var require_cancellation = __commonJS({
  "../../node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/cancellation.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CancellationTokenSource = exports2.CancellationToken = void 0;
    var ral_1 = require_ral();
    var Is = require_is2();
    var events_1 = require_events();
    var CancellationToken;
    (function(CancellationToken2) {
      CancellationToken2.None = Object.freeze({
        isCancellationRequested: false,
        onCancellationRequested: events_1.Event.None
      });
      CancellationToken2.Cancelled = Object.freeze({
        isCancellationRequested: true,
        onCancellationRequested: events_1.Event.None
      });
      function is(value) {
        const candidate = value;
        return candidate && (candidate === CancellationToken2.None || candidate === CancellationToken2.Cancelled || Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
      }
      CancellationToken2.is = is;
    })(CancellationToken || (exports2.CancellationToken = CancellationToken = {}));
    var shortcutEvent = Object.freeze(function(callback, context) {
      const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);
      return { dispose() {
        handle.dispose();
      } };
    });
    var MutableToken = class {
      constructor() {
        this._isCancelled = false;
      }
      cancel() {
        if (!this._isCancelled) {
          this._isCancelled = true;
          if (this._emitter) {
            this._emitter.fire(void 0);
            this.dispose();
          }
        }
      }
      get isCancellationRequested() {
        return this._isCancelled;
      }
      get onCancellationRequested() {
        if (this._isCancelled) {
          return shortcutEvent;
        }
        if (!this._emitter) {
          this._emitter = new events_1.Emitter();
        }
        return this._emitter.event;
      }
      dispose() {
        if (this._emitter) {
          this._emitter.dispose();
          this._emitter = void 0;
        }
      }
    };
    var CancellationTokenSource = class {
      get token() {
        if (!this._token) {
          this._token = new MutableToken();
        }
        return this._token;
      }
      cancel() {
        if (!this._token) {
          this._token = CancellationToken.Cancelled;
        } else {
          this._token.cancel();
        }
      }
      dispose() {
        if (!this._token) {
          this._token = CancellationToken.None;
        } else if (this._token instanceof MutableToken) {
          this._token.dispose();
        }
      }
    };
    exports2.CancellationTokenSource = CancellationTokenSource;
  }
});

// ../../node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/sharedArrayCancellation.js
var require_sharedArrayCancellation = __commonJS({
  "../../node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/sharedArrayCancellation.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SharedArrayReceiverStrategy = exports2.SharedArraySenderStrategy = void 0;
    var cancellation_1 = require_cancellation();
    var CancellationState;
    (function(CancellationState2) {
      CancellationState2.Continue = 0;
      CancellationState2.Cancelled = 1;
    })(CancellationState || (CancellationState = {}));
    var SharedArraySenderStrategy = class {
      constructor() {
        this.buffers = /* @__PURE__ */ new Map();
      }
      enableCancellation(request) {
        if (request.id === null) {
          return;
        }
        const buffer = new SharedArrayBuffer(4);
        const data = new Int32Array(buffer, 0, 1);
        data[0] = CancellationState.Continue;
        this.buffers.set(request.id, buffer);
        request.$cancellationData = buffer;
      }
      async sendCancellation(_conn, id) {
        const buffer = this.buffers.get(id);
        if (buffer === void 0) {
          return;
        }
        const data = new Int32Array(buffer, 0, 1);
        Atomics.store(data, 0, CancellationState.Cancelled);
      }
      cleanup(id) {
        this.buffers.delete(id);
      }
      dispose() {
        this.buffers.clear();
      }
    };
    exports2.SharedArraySenderStrategy = SharedArraySenderStrategy;
    var SharedArrayBufferCancellationToken = class {
      constructor(buffer) {
        this.data = new Int32Array(buffer, 0, 1);
      }
      get isCancellationRequested() {
        return Atomics.load(this.data, 0) === CancellationState.Cancelled;
      }
      get onCancellationRequested() {
        throw new Error(`Cancellation over SharedArrayBuffer doesn't support cancellation events`);
      }
    };
    var SharedArrayBufferCancellationTokenSource = class {
      constructor(buffer) {
        this.token = new SharedArrayBufferCancellationToken(buffer);
      }
      cancel() {
      }
      dispose() {
      }
    };
    var SharedArrayReceiverStrategy = class {
      constructor() {
        this.kind = "request";
      }
      createCancellationTokenSource(request) {
        const buffer = request.$cancellationData;
        if (buffer === void 0) {
          return new cancellation_1.CancellationTokenSource();
        }
        return new SharedArrayBufferCancellationTokenSource(buffer);
      }
    };
    exports2.SharedArrayReceiverStrategy = SharedArrayReceiverStrategy;
  }
});

// ../../node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/semaphore.js
var require_semaphore = __commonJS({
  "../../node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/semaphore.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Semaphore = void 0;
    var ral_1 = require_ral();
    var Semaphore = class {
      constructor(capacity = 1) {
        if (capacity <= 0) {
          throw new Error("Capacity must be greater than 0");
        }
        this._capacity = capacity;
        this._active = 0;
        this._waiting = [];
      }
      lock(thunk) {
        return new Promise((resolve, reject) => {
          this._waiting.push({ thunk, resolve, reject });
          this.runNext();
        });
      }
      get active() {
        return this._active;
      }
      runNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
          return;
        }
        (0, ral_1.default)().timer.setImmediate(() => this.doRunNext());
      }
      doRunNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
          return;
        }
        const next = this._waiting.shift();
        this._active++;
        if (this._active > this._capacity) {
          throw new Error(`To many thunks active`);
        }
        try {
          const result = next.thunk();
          if (result instanceof Promise) {
            result.then((value) => {
              this._active--;
              next.resolve(value);
              this.runNext();
            }, (err) => {
              this._active--;
              next.reject(err);
              this.runNext();
            });
          } else {
            this._active--;
            next.resolve(result);
            this.runNext();
          }
        } catch (err) {
          this._active--;
          next.reject(err);
          this.runNext();
        }
      }
    };
    exports2.Semaphore = Semaphore;
  }
});

// ../../node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/messageReader.js
var require_messageReader = __commonJS({
  "../../node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/messageReader.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ReadableStreamMessageReader = exports2.AbstractMessageReader = exports2.MessageReader = void 0;
    var ral_1 = require_ral();
    var Is = require_is2();
    var events_1 = require_events();
    var semaphore_1 = require_semaphore();
    var MessageReader;
    (function(MessageReader2) {
      function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) && Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
      }
      MessageReader2.is = is;
    })(MessageReader || (exports2.MessageReader = MessageReader = {}));
    var AbstractMessageReader = class {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
        this.partialMessageEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error) {
        this.errorEmitter.fire(this.asError(error));
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      get onPartialMessage() {
        return this.partialMessageEmitter.event;
      }
      firePartialMessage(info) {
        this.partialMessageEmitter.fire(info);
      }
      asError(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : "unknown"}`);
        }
      }
    };
    exports2.AbstractMessageReader = AbstractMessageReader;
    var ResolvedMessageReaderOptions;
    (function(ResolvedMessageReaderOptions2) {
      function fromOptions(options) {
        let charset;
        let result;
        let contentDecoder;
        const contentDecoders = /* @__PURE__ */ new Map();
        let contentTypeDecoder;
        const contentTypeDecoders = /* @__PURE__ */ new Map();
        if (options === void 0 || typeof options === "string") {
          charset = options ?? "utf-8";
        } else {
          charset = options.charset ?? "utf-8";
          if (options.contentDecoder !== void 0) {
            contentDecoder = options.contentDecoder;
            contentDecoders.set(contentDecoder.name, contentDecoder);
          }
          if (options.contentDecoders !== void 0) {
            for (const decoder of options.contentDecoders) {
              contentDecoders.set(decoder.name, decoder);
            }
          }
          if (options.contentTypeDecoder !== void 0) {
            contentTypeDecoder = options.contentTypeDecoder;
            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
          }
          if (options.contentTypeDecoders !== void 0) {
            for (const decoder of options.contentTypeDecoders) {
              contentTypeDecoders.set(decoder.name, decoder);
            }
          }
        }
        if (contentTypeDecoder === void 0) {
          contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;
          contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
        }
        return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };
      }
      ResolvedMessageReaderOptions2.fromOptions = fromOptions;
    })(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
    var ReadableStreamMessageReader = class extends AbstractMessageReader {
      constructor(readable, options) {
        super();
        this.readable = readable;
        this.options = ResolvedMessageReaderOptions.fromOptions(options);
        this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);
        this._partialMessageTimeout = 1e4;
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.readSemaphore = new semaphore_1.Semaphore(1);
      }
      set partialMessageTimeout(timeout) {
        this._partialMessageTimeout = timeout;
      }
      get partialMessageTimeout() {
        return this._partialMessageTimeout;
      }
      listen(callback) {
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.partialMessageTimer = void 0;
        this.callback = callback;
        const result = this.readable.onData((data) => {
          this.onData(data);
        });
        this.readable.onError((error) => this.fireError(error));
        this.readable.onClose(() => this.fireClose());
        return result;
      }
      onData(data) {
        try {
          this.buffer.append(data);
          while (true) {
            if (this.nextMessageLength === -1) {
              const headers = this.buffer.tryReadHeaders(true);
              if (!headers) {
                return;
              }
              const contentLength = headers.get("content-length");
              if (!contentLength) {
                this.fireError(new Error(`Header must provide a Content-Length property.
${JSON.stringify(Object.fromEntries(headers))}`));
                return;
              }
              const length = parseInt(contentLength);
              if (isNaN(length)) {
                this.fireError(new Error(`Content-Length value must be a number. Got ${contentLength}`));
                return;
              }
              this.nextMessageLength = length;
            }
            const body = this.buffer.tryReadBody(this.nextMessageLength);
            if (body === void 0) {
              this.setPartialMessageTimer();
              return;
            }
            this.clearPartialMessageTimer();
            this.nextMessageLength = -1;
            this.readSemaphore.lock(async () => {
              const bytes = this.options.contentDecoder !== void 0 ? await this.options.contentDecoder.decode(body) : body;
              const message = await this.options.contentTypeDecoder.decode(bytes, this.options);
              this.callback(message);
            }).catch((error) => {
              this.fireError(error);
            });
          }
        } catch (error) {
          this.fireError(error);
        }
      }
      clearPartialMessageTimer() {
        if (this.partialMessageTimer) {
          this.partialMessageTimer.dispose();
          this.partialMessageTimer = void 0;
        }
      }
      setPartialMessageTimer() {
        this.clearPartialMessageTimer();
        if (this._partialMessageTimeout <= 0) {
          return;
        }
        this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout) => {
          this.partialMessageTimer = void 0;
          if (token === this.messageToken) {
            this.firePartialMessage({ messageToken: token, waitingTime: timeout });
            this.setPartialMessageTimer();
          }
        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
      }
    };
    exports2.ReadableStreamMessageReader = ReadableStreamMessageReader;
  }
});

// ../../node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/messageWriter.js
var require_messageWriter = __commonJS({
  "../../node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/messageWriter.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WriteableStreamMessageWriter = exports2.AbstractMessageWriter = exports2.MessageWriter = void 0;
    var ral_1 = require_ral();
    var Is = require_is2();
    var semaphore_1 = require_semaphore();
    var events_1 = require_events();
    var ContentLength = "Content-Length: ";
    var CRLF = "\r\n";
    var MessageWriter;
    (function(MessageWriter2) {
      function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) && Is.func(candidate.onError) && Is.func(candidate.write);
      }
      MessageWriter2.is = is;
    })(MessageWriter || (exports2.MessageWriter = MessageWriter = {}));
    var AbstractMessageWriter = class {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error, message, count) {
        this.errorEmitter.fire([this.asError(error), message, count]);
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      asError(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : "unknown"}`);
        }
      }
    };
    exports2.AbstractMessageWriter = AbstractMessageWriter;
    var ResolvedMessageWriterOptions;
    (function(ResolvedMessageWriterOptions2) {
      function fromOptions(options) {
        if (options === void 0 || typeof options === "string") {
          return { charset: options ?? "utf-8", contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder };
        } else {
          return { charset: options.charset ?? "utf-8", contentEncoder: options.contentEncoder, contentTypeEncoder: options.contentTypeEncoder ?? (0, ral_1.default)().applicationJson.encoder };
        }
      }
      ResolvedMessageWriterOptions2.fromOptions = fromOptions;
    })(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
    var WriteableStreamMessageWriter = class extends AbstractMessageWriter {
      constructor(writable, options) {
        super();
        this.writable = writable;
        this.options = ResolvedMessageWriterOptions.fromOptions(options);
        this.errorCount = 0;
        this.writeSemaphore = new semaphore_1.Semaphore(1);
        this.writable.onError((error) => this.fireError(error));
        this.writable.onClose(() => this.fireClose());
      }
      async write(msg) {
        return this.writeSemaphore.lock(async () => {
          const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {
            if (this.options.contentEncoder !== void 0) {
              return this.options.contentEncoder.encode(buffer);
            } else {
              return buffer;
            }
          });
          return payload.then((buffer) => {
            const headers = [];
            headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
            headers.push(CRLF);
            return this.doWrite(msg, headers, buffer);
          }, (error) => {
            this.fireError(error);
            throw error;
          });
        });
      }
      async doWrite(msg, headers, data) {
        try {
          await this.writable.write(headers.join(""), "ascii");
          return this.writable.write(data);
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
        this.writable.end();
      }
    };
    exports2.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
  }
});

// ../../node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/messageBuffer.js
var require_messageBuffer = __commonJS({
  "../../node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/messageBuffer.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AbstractMessageBuffer = void 0;
    var CR = 13;
    var LF = 10;
    var CRLF = "\r\n";
    var AbstractMessageBuffer = class {
      constructor(encoding = "utf-8") {
        this._encoding = encoding;
        this._chunks = [];
        this._totalLength = 0;
      }
      get encoding() {
        return this._encoding;
      }
      append(chunk) {
        const toAppend = typeof chunk === "string" ? this.fromString(chunk, this._encoding) : chunk;
        this._chunks.push(toAppend);
        this._totalLength += toAppend.byteLength;
      }
      tryReadHeaders(lowerCaseKeys = false) {
        if (this._chunks.length === 0) {
          return void 0;
        }
        let state = 0;
        let chunkIndex = 0;
        let offset = 0;
        let chunkBytesRead = 0;
        row: while (chunkIndex < this._chunks.length) {
          const chunk = this._chunks[chunkIndex];
          offset = 0;
          column: while (offset < chunk.length) {
            const value = chunk[offset];
            switch (value) {
              case CR:
                switch (state) {
                  case 0:
                    state = 1;
                    break;
                  case 2:
                    state = 3;
                    break;
                  default:
                    state = 0;
                }
                break;
              case LF:
                switch (state) {
                  case 1:
                    state = 2;
                    break;
                  case 3:
                    state = 4;
                    offset++;
                    break row;
                  default:
                    state = 0;
                }
                break;
              default:
                state = 0;
            }
            offset++;
          }
          chunkBytesRead += chunk.byteLength;
          chunkIndex++;
        }
        if (state !== 4) {
          return void 0;
        }
        const buffer = this._read(chunkBytesRead + offset);
        const result = /* @__PURE__ */ new Map();
        const headers = this.toString(buffer, "ascii").split(CRLF);
        if (headers.length < 2) {
          return result;
        }
        for (let i = 0; i < headers.length - 2; i++) {
          const header = headers[i];
          const index = header.indexOf(":");
          if (index === -1) {
            throw new Error(`Message header must separate key and value using ':'
${header}`);
          }
          const key = header.substr(0, index);
          const value = header.substr(index + 1).trim();
          result.set(lowerCaseKeys ? key.toLowerCase() : key, value);
        }
        return result;
      }
      tryReadBody(length) {
        if (this._totalLength < length) {
          return void 0;
        }
        return this._read(length);
      }
      get numberOfBytes() {
        return this._totalLength;
      }
      _read(byteCount) {
        if (byteCount === 0) {
          return this.emptyBuffer();
        }
        if (byteCount > this._totalLength) {
          throw new Error(`Cannot read so many bytes!`);
        }
        if (this._chunks[0].byteLength === byteCount) {
          const chunk = this._chunks[0];
          this._chunks.shift();
          this._totalLength -= byteCount;
          return this.asNative(chunk);
        }
        if (this._chunks[0].byteLength > byteCount) {
          const chunk = this._chunks[0];
          const result2 = this.asNative(chunk, byteCount);
          this._chunks[0] = chunk.slice(byteCount);
          this._totalLength -= byteCount;
          return result2;
        }
        const result = this.allocNative(byteCount);
        let resultOffset = 0;
        let chunkIndex = 0;
        while (byteCount > 0) {
          const chunk = this._chunks[chunkIndex];
          if (chunk.byteLength > byteCount) {
            const chunkPart = chunk.slice(0, byteCount);
            result.set(chunkPart, resultOffset);
            resultOffset += byteCount;
            this._chunks[chunkIndex] = chunk.slice(byteCount);
            this._totalLength -= byteCount;
            byteCount -= byteCount;
          } else {
            result.set(chunk, resultOffset);
            resultOffset += chunk.byteLength;
            this._chunks.shift();
            this._totalLength -= chunk.byteLength;
            byteCount -= chunk.byteLength;
          }
        }
        return result;
      }
    };
    exports2.AbstractMessageBuffer = AbstractMessageBuffer;
  }
});

// ../../node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/connection.js
var require_connection = __commonJS({
  "../../node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/connection.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createMessageConnection = exports2.ConnectionOptions = exports2.MessageStrategy = exports2.CancellationStrategy = exports2.CancellationSenderStrategy = exports2.CancellationReceiverStrategy = exports2.RequestCancellationReceiverStrategy = exports2.IdCancellationReceiverStrategy = exports2.ConnectionStrategy = exports2.ConnectionError = exports2.ConnectionErrors = exports2.LogTraceNotification = exports2.SetTraceNotification = exports2.TraceFormat = exports2.TraceValues = exports2.Trace = exports2.NullLogger = exports2.ProgressType = exports2.ProgressToken = void 0;
    var ral_1 = require_ral();
    var Is = require_is2();
    var messages_1 = require_messages();
    var linkedMap_1 = require_linkedMap();
    var events_1 = require_events();
    var cancellation_1 = require_cancellation();
    var CancelNotification;
    (function(CancelNotification2) {
      CancelNotification2.type = new messages_1.NotificationType("$/cancelRequest");
    })(CancelNotification || (CancelNotification = {}));
    var ProgressToken;
    (function(ProgressToken2) {
      function is(value) {
        return typeof value === "string" || typeof value === "number";
      }
      ProgressToken2.is = is;
    })(ProgressToken || (exports2.ProgressToken = ProgressToken = {}));
    var ProgressNotification;
    (function(ProgressNotification2) {
      ProgressNotification2.type = new messages_1.NotificationType("$/progress");
    })(ProgressNotification || (ProgressNotification = {}));
    var ProgressType = class {
      constructor() {
      }
    };
    exports2.ProgressType = ProgressType;
    var StarRequestHandler;
    (function(StarRequestHandler2) {
      function is(value) {
        return Is.func(value);
      }
      StarRequestHandler2.is = is;
    })(StarRequestHandler || (StarRequestHandler = {}));
    exports2.NullLogger = Object.freeze({
      error: () => {
      },
      warn: () => {
      },
      info: () => {
      },
      log: () => {
      }
    });
    var Trace;
    (function(Trace2) {
      Trace2[Trace2["Off"] = 0] = "Off";
      Trace2[Trace2["Messages"] = 1] = "Messages";
      Trace2[Trace2["Compact"] = 2] = "Compact";
      Trace2[Trace2["Verbose"] = 3] = "Verbose";
    })(Trace || (exports2.Trace = Trace = {}));
    var TraceValues;
    (function(TraceValues2) {
      TraceValues2.Off = "off";
      TraceValues2.Messages = "messages";
      TraceValues2.Compact = "compact";
      TraceValues2.Verbose = "verbose";
    })(TraceValues || (exports2.TraceValues = TraceValues = {}));
    (function(Trace2) {
      function fromString(value) {
        if (!Is.string(value)) {
          return Trace2.Off;
        }
        value = value.toLowerCase();
        switch (value) {
          case "off":
            return Trace2.Off;
          case "messages":
            return Trace2.Messages;
          case "compact":
            return Trace2.Compact;
          case "verbose":
            return Trace2.Verbose;
          default:
            return Trace2.Off;
        }
      }
      Trace2.fromString = fromString;
      function toString(value) {
        switch (value) {
          case Trace2.Off:
            return "off";
          case Trace2.Messages:
            return "messages";
          case Trace2.Compact:
            return "compact";
          case Trace2.Verbose:
            return "verbose";
          default:
            return "off";
        }
      }
      Trace2.toString = toString;
    })(Trace || (exports2.Trace = Trace = {}));
    var TraceFormat;
    (function(TraceFormat2) {
      TraceFormat2["Text"] = "text";
      TraceFormat2["JSON"] = "json";
    })(TraceFormat || (exports2.TraceFormat = TraceFormat = {}));
    (function(TraceFormat2) {
      function fromString(value) {
        if (!Is.string(value)) {
          return TraceFormat2.Text;
        }
        value = value.toLowerCase();
        if (value === "json") {
          return TraceFormat2.JSON;
        } else {
          return TraceFormat2.Text;
        }
      }
      TraceFormat2.fromString = fromString;
    })(TraceFormat || (exports2.TraceFormat = TraceFormat = {}));
    var SetTraceNotification;
    (function(SetTraceNotification2) {
      SetTraceNotification2.type = new messages_1.NotificationType("$/setTrace");
    })(SetTraceNotification || (exports2.SetTraceNotification = SetTraceNotification = {}));
    var LogTraceNotification;
    (function(LogTraceNotification2) {
      LogTraceNotification2.type = new messages_1.NotificationType("$/logTrace");
    })(LogTraceNotification || (exports2.LogTraceNotification = LogTraceNotification = {}));
    var ConnectionErrors;
    (function(ConnectionErrors2) {
      ConnectionErrors2[ConnectionErrors2["Closed"] = 1] = "Closed";
      ConnectionErrors2[ConnectionErrors2["Disposed"] = 2] = "Disposed";
      ConnectionErrors2[ConnectionErrors2["AlreadyListening"] = 3] = "AlreadyListening";
    })(ConnectionErrors || (exports2.ConnectionErrors = ConnectionErrors = {}));
    var ConnectionError = class _ConnectionError extends Error {
      constructor(code, message) {
        super(message);
        this.code = code;
        Object.setPrototypeOf(this, _ConnectionError.prototype);
      }
    };
    exports2.ConnectionError = ConnectionError;
    var ConnectionStrategy;
    (function(ConnectionStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.cancelUndispatched);
      }
      ConnectionStrategy2.is = is;
    })(ConnectionStrategy || (exports2.ConnectionStrategy = ConnectionStrategy = {}));
    var IdCancellationReceiverStrategy;
    (function(IdCancellationReceiverStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && (candidate.kind === void 0 || candidate.kind === "id") && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === void 0 || Is.func(candidate.dispose));
      }
      IdCancellationReceiverStrategy2.is = is;
    })(IdCancellationReceiverStrategy || (exports2.IdCancellationReceiverStrategy = IdCancellationReceiverStrategy = {}));
    var RequestCancellationReceiverStrategy;
    (function(RequestCancellationReceiverStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && candidate.kind === "request" && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === void 0 || Is.func(candidate.dispose));
      }
      RequestCancellationReceiverStrategy2.is = is;
    })(RequestCancellationReceiverStrategy || (exports2.RequestCancellationReceiverStrategy = RequestCancellationReceiverStrategy = {}));
    var CancellationReceiverStrategy;
    (function(CancellationReceiverStrategy2) {
      CancellationReceiverStrategy2.Message = Object.freeze({
        createCancellationTokenSource(_) {
          return new cancellation_1.CancellationTokenSource();
        }
      });
      function is(value) {
        return IdCancellationReceiverStrategy.is(value) || RequestCancellationReceiverStrategy.is(value);
      }
      CancellationReceiverStrategy2.is = is;
    })(CancellationReceiverStrategy || (exports2.CancellationReceiverStrategy = CancellationReceiverStrategy = {}));
    var CancellationSenderStrategy;
    (function(CancellationSenderStrategy2) {
      CancellationSenderStrategy2.Message = Object.freeze({
        sendCancellation(conn, id) {
          return conn.sendNotification(CancelNotification.type, { id });
        },
        cleanup(_) {
        }
      });
      function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);
      }
      CancellationSenderStrategy2.is = is;
    })(CancellationSenderStrategy || (exports2.CancellationSenderStrategy = CancellationSenderStrategy = {}));
    var CancellationStrategy;
    (function(CancellationStrategy2) {
      CancellationStrategy2.Message = Object.freeze({
        receiver: CancellationReceiverStrategy.Message,
        sender: CancellationSenderStrategy.Message
      });
      function is(value) {
        const candidate = value;
        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
      }
      CancellationStrategy2.is = is;
    })(CancellationStrategy || (exports2.CancellationStrategy = CancellationStrategy = {}));
    var MessageStrategy;
    (function(MessageStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.handleMessage);
      }
      MessageStrategy2.is = is;
    })(MessageStrategy || (exports2.MessageStrategy = MessageStrategy = {}));
    var ConnectionOptions;
    (function(ConnectionOptions2) {
      function is(value) {
        const candidate = value;
        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy) || MessageStrategy.is(candidate.messageStrategy));
      }
      ConnectionOptions2.is = is;
    })(ConnectionOptions || (exports2.ConnectionOptions = ConnectionOptions = {}));
    var ConnectionState;
    (function(ConnectionState2) {
      ConnectionState2[ConnectionState2["New"] = 1] = "New";
      ConnectionState2[ConnectionState2["Listening"] = 2] = "Listening";
      ConnectionState2[ConnectionState2["Closed"] = 3] = "Closed";
      ConnectionState2[ConnectionState2["Disposed"] = 4] = "Disposed";
    })(ConnectionState || (ConnectionState = {}));
    function createMessageConnection(messageReader, messageWriter, _logger, options) {
      const logger = _logger !== void 0 ? _logger : exports2.NullLogger;
      let sequenceNumber = 0;
      let notificationSequenceNumber = 0;
      let unknownResponseSequenceNumber = 0;
      const version = "2.0";
      let starRequestHandler = void 0;
      const requestHandlers = /* @__PURE__ */ new Map();
      let starNotificationHandler = void 0;
      const notificationHandlers = /* @__PURE__ */ new Map();
      const progressHandlers = /* @__PURE__ */ new Map();
      let timer;
      let messageQueue = new linkedMap_1.LinkedMap();
      let responsePromises = /* @__PURE__ */ new Map();
      let knownCanceledRequests = /* @__PURE__ */ new Set();
      let requestTokens = /* @__PURE__ */ new Map();
      let trace = Trace.Off;
      let traceFormat = TraceFormat.Text;
      let tracer;
      let state = ConnectionState.New;
      const errorEmitter = new events_1.Emitter();
      const closeEmitter = new events_1.Emitter();
      const unhandledNotificationEmitter = new events_1.Emitter();
      const unhandledProgressEmitter = new events_1.Emitter();
      const disposeEmitter = new events_1.Emitter();
      const cancellationStrategy = options && options.cancellationStrategy ? options.cancellationStrategy : CancellationStrategy.Message;
      function createRequestQueueKey(id) {
        if (id === null) {
          throw new Error(`Can't send requests with id null since the response can't be correlated.`);
        }
        return "req-" + id.toString();
      }
      function createResponseQueueKey(id) {
        if (id === null) {
          return "res-unknown-" + (++unknownResponseSequenceNumber).toString();
        } else {
          return "res-" + id.toString();
        }
      }
      function createNotificationQueueKey() {
        return "not-" + (++notificationSequenceNumber).toString();
      }
      function addMessageToQueue(queue, message) {
        if (messages_1.Message.isRequest(message)) {
          queue.set(createRequestQueueKey(message.id), message);
        } else if (messages_1.Message.isResponse(message)) {
          queue.set(createResponseQueueKey(message.id), message);
        } else {
          queue.set(createNotificationQueueKey(), message);
        }
      }
      function cancelUndispatched(_message) {
        return void 0;
      }
      function isListening() {
        return state === ConnectionState.Listening;
      }
      function isClosed() {
        return state === ConnectionState.Closed;
      }
      function isDisposed() {
        return state === ConnectionState.Disposed;
      }
      function closeHandler() {
        if (state === ConnectionState.New || state === ConnectionState.Listening) {
          state = ConnectionState.Closed;
          closeEmitter.fire(void 0);
        }
      }
      function readErrorHandler(error) {
        errorEmitter.fire([error, void 0, void 0]);
      }
      function writeErrorHandler(data) {
        errorEmitter.fire(data);
      }
      messageReader.onClose(closeHandler);
      messageReader.onError(readErrorHandler);
      messageWriter.onClose(closeHandler);
      messageWriter.onError(writeErrorHandler);
      function triggerMessageQueue() {
        if (timer || messageQueue.size === 0) {
          return;
        }
        timer = (0, ral_1.default)().timer.setImmediate(() => {
          timer = void 0;
          processMessageQueue();
        });
      }
      function handleMessage(message) {
        if (messages_1.Message.isRequest(message)) {
          handleRequest(message);
        } else if (messages_1.Message.isNotification(message)) {
          handleNotification(message);
        } else if (messages_1.Message.isResponse(message)) {
          handleResponse(message);
        } else {
          handleInvalidMessage(message);
        }
      }
      function processMessageQueue() {
        if (messageQueue.size === 0) {
          return;
        }
        const message = messageQueue.shift();
        try {
          const messageStrategy = options?.messageStrategy;
          if (MessageStrategy.is(messageStrategy)) {
            messageStrategy.handleMessage(message, handleMessage);
          } else {
            handleMessage(message);
          }
        } finally {
          triggerMessageQueue();
        }
      }
      const callback = (message) => {
        try {
          if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {
            const cancelId = message.params.id;
            const key = createRequestQueueKey(cancelId);
            const toCancel = messageQueue.get(key);
            if (messages_1.Message.isRequest(toCancel)) {
              const strategy = options?.connectionStrategy;
              const response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
              if (response && (response.error !== void 0 || response.result !== void 0)) {
                messageQueue.delete(key);
                requestTokens.delete(cancelId);
                response.id = toCancel.id;
                traceSendingResponse(response, message.method, Date.now());
                messageWriter.write(response).catch(() => logger.error(`Sending response for canceled message failed.`));
                return;
              }
            }
            const cancellationToken = requestTokens.get(cancelId);
            if (cancellationToken !== void 0) {
              cancellationToken.cancel();
              traceReceivedNotification(message);
              return;
            } else {
              knownCanceledRequests.add(cancelId);
            }
          }
          addMessageToQueue(messageQueue, message);
        } finally {
          triggerMessageQueue();
        }
      };
      function handleRequest(requestMessage) {
        if (isDisposed()) {
          return;
        }
        function reply(resultOrError, method, startTime2) {
          const message = {
            jsonrpc: version,
            id: requestMessage.id
          };
          if (resultOrError instanceof messages_1.ResponseError) {
            message.error = resultOrError.toJson();
          } else {
            message.result = resultOrError === void 0 ? null : resultOrError;
          }
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        function replyError(error, method, startTime2) {
          const message = {
            jsonrpc: version,
            id: requestMessage.id,
            error: error.toJson()
          };
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        function replySuccess(result, method, startTime2) {
          if (result === void 0) {
            result = null;
          }
          const message = {
            jsonrpc: version,
            id: requestMessage.id,
            result
          };
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        traceReceivedRequest(requestMessage);
        const element = requestHandlers.get(requestMessage.method);
        let type;
        let requestHandler;
        if (element) {
          type = element.type;
          requestHandler = element.handler;
        }
        const startTime = Date.now();
        if (requestHandler || starRequestHandler) {
          const tokenKey = requestMessage.id ?? String(Date.now());
          const cancellationSource = IdCancellationReceiverStrategy.is(cancellationStrategy.receiver) ? cancellationStrategy.receiver.createCancellationTokenSource(tokenKey) : cancellationStrategy.receiver.createCancellationTokenSource(requestMessage);
          if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
            cancellationSource.cancel();
          }
          if (requestMessage.id !== null) {
            requestTokens.set(tokenKey, cancellationSource);
          }
          try {
            let handlerResult;
            if (requestHandler) {
              if (requestMessage.params === void 0) {
                if (type !== void 0 && type.numberOfParams !== 0) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(cancellationSource.token);
              } else if (Array.isArray(requestMessage.params)) {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byName) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
              } else {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
              }
            } else if (starRequestHandler) {
              handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
            }
            const promise = handlerResult;
            if (!handlerResult) {
              requestTokens.delete(tokenKey);
              replySuccess(handlerResult, requestMessage.method, startTime);
            } else if (promise.then) {
              promise.then((resultOrError) => {
                requestTokens.delete(tokenKey);
                reply(resultOrError, requestMessage.method, startTime);
              }, (error) => {
                requestTokens.delete(tokenKey);
                if (error instanceof messages_1.ResponseError) {
                  replyError(error, requestMessage.method, startTime);
                } else if (error && Is.string(error.message)) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                } else {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                }
              });
            } else {
              requestTokens.delete(tokenKey);
              reply(handlerResult, requestMessage.method, startTime);
            }
          } catch (error) {
            requestTokens.delete(tokenKey);
            if (error instanceof messages_1.ResponseError) {
              reply(error, requestMessage.method, startTime);
            } else if (error && Is.string(error.message)) {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
            } else {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
            }
          }
        } else {
          replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
        }
      }
      function handleResponse(responseMessage) {
        if (isDisposed()) {
          return;
        }
        if (responseMessage.id === null) {
          if (responseMessage.error) {
            logger.error(`Received response message without id: Error is: 
${JSON.stringify(responseMessage.error, void 0, 4)}`);
          } else {
            logger.error(`Received response message without id. No further error information provided.`);
          }
        } else {
          const key = responseMessage.id;
          const responsePromise = responsePromises.get(key);
          traceReceivedResponse(responseMessage, responsePromise);
          if (responsePromise !== void 0) {
            responsePromises.delete(key);
            try {
              if (responseMessage.error) {
                const error = responseMessage.error;
                responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
              } else if (responseMessage.result !== void 0) {
                responsePromise.resolve(responseMessage.result);
              } else {
                throw new Error("Should never happen.");
              }
            } catch (error) {
              if (error.message) {
                logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
              } else {
                logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
              }
            }
          }
        }
      }
      function handleNotification(message) {
        if (isDisposed()) {
          return;
        }
        let type = void 0;
        let notificationHandler;
        if (message.method === CancelNotification.type.method) {
          const cancelId = message.params.id;
          knownCanceledRequests.delete(cancelId);
          traceReceivedNotification(message);
          return;
        } else {
          const element = notificationHandlers.get(message.method);
          if (element) {
            notificationHandler = element.handler;
            type = element.type;
          }
        }
        if (notificationHandler || starNotificationHandler) {
          try {
            traceReceivedNotification(message);
            if (notificationHandler) {
              if (message.params === void 0) {
                if (type !== void 0) {
                  if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                    logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);
                  }
                }
                notificationHandler();
              } else if (Array.isArray(message.params)) {
                const params = message.params;
                if (message.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0])) {
                  notificationHandler({ token: params[0], value: params[1] });
                } else {
                  if (type !== void 0) {
                    if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                      logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                    }
                    if (type.numberOfParams !== message.params.length) {
                      logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);
                    }
                  }
                  notificationHandler(...params);
                }
              } else {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                  logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                }
                notificationHandler(message.params);
              }
            } else if (starNotificationHandler) {
              starNotificationHandler(message.method, message.params);
            }
          } catch (error) {
            if (error.message) {
              logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
            } else {
              logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
            }
          }
        } else {
          unhandledNotificationEmitter.fire(message);
        }
      }
      function handleInvalidMessage(message) {
        if (!message) {
          logger.error("Received empty message.");
          return;
        }
        logger.error(`Received message which is neither a response nor a notification message:
${JSON.stringify(message, null, 4)}`);
        const responseMessage = message;
        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
          const key = responseMessage.id;
          const responseHandler = responsePromises.get(key);
          if (responseHandler) {
            responseHandler.reject(new Error("The received response has neither a result nor an error property."));
          }
        }
      }
      function stringifyTrace(params) {
        if (params === void 0 || params === null) {
          return void 0;
        }
        switch (trace) {
          case Trace.Verbose:
            return JSON.stringify(params, null, 4);
          case Trace.Compact:
            return JSON.stringify(params);
          default:
            return void 0;
        }
      }
      function traceSendingRequest(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
            data = `Params: ${stringifyTrace(message.params)}

`;
          }
          tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
        } else {
          logLSPMessage("send-request", message);
        }
      }
      function traceSendingNotification(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Sending notification '${message.method}'.`, data);
        } else {
          logLSPMessage("send-notification", message);
        }
      }
      function traceSendingResponse(message, method, startTime) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.error && message.error.data) {
              data = `Error data: ${stringifyTrace(message.error.data)}

`;
            } else {
              if (message.result) {
                data = `Result: ${stringifyTrace(message.result)}

`;
              } else if (message.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
        } else {
          logLSPMessage("send-response", message);
        }
      }
      function traceReceivedRequest(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
            data = `Params: ${stringifyTrace(message.params)}

`;
          }
          tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
        } else {
          logLSPMessage("receive-request", message);
        }
      }
      function traceReceivedNotification(message) {
        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Received notification '${message.method}'.`, data);
        } else {
          logLSPMessage("receive-notification", message);
        }
      }
      function traceReceivedResponse(message, responsePromise) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.error && message.error.data) {
              data = `Error data: ${stringifyTrace(message.error.data)}

`;
            } else {
              if (message.result) {
                data = `Result: ${stringifyTrace(message.result)}

`;
              } else if (message.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          if (responsePromise) {
            const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : "";
            tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
          } else {
            tracer.log(`Received response ${message.id} without active response promise.`, data);
          }
        } else {
          logLSPMessage("receive-response", message);
        }
      }
      function logLSPMessage(type, message) {
        if (!tracer || trace === Trace.Off) {
          return;
        }
        const lspMessage = {
          isLSPMessage: true,
          type,
          message,
          timestamp: Date.now()
        };
        tracer.log(lspMessage);
      }
      function throwIfClosedOrDisposed() {
        if (isClosed()) {
          throw new ConnectionError(ConnectionErrors.Closed, "Connection is closed.");
        }
        if (isDisposed()) {
          throw new ConnectionError(ConnectionErrors.Disposed, "Connection is disposed.");
        }
      }
      function throwIfListening() {
        if (isListening()) {
          throw new ConnectionError(ConnectionErrors.AlreadyListening, "Connection is already listening");
        }
      }
      function throwIfNotListening() {
        if (!isListening()) {
          throw new Error("Call listen() first.");
        }
      }
      function undefinedToNull(param) {
        if (param === void 0) {
          return null;
        } else {
          return param;
        }
      }
      function nullToUndefined(param) {
        if (param === null) {
          return void 0;
        } else {
          return param;
        }
      }
      function isNamedParam(param) {
        return param !== void 0 && param !== null && !Array.isArray(param) && typeof param === "object";
      }
      function computeSingleParam(parameterStructures, param) {
        switch (parameterStructures) {
          case messages_1.ParameterStructures.auto:
            if (isNamedParam(param)) {
              return nullToUndefined(param);
            } else {
              return [undefinedToNull(param)];
            }
          case messages_1.ParameterStructures.byName:
            if (!isNamedParam(param)) {
              throw new Error(`Received parameters by name but param is not an object literal.`);
            }
            return nullToUndefined(param);
          case messages_1.ParameterStructures.byPosition:
            return [undefinedToNull(param)];
          default:
            throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
        }
      }
      function computeMessageParams(type, params) {
        let result;
        const numberOfParams = type.numberOfParams;
        switch (numberOfParams) {
          case 0:
            result = void 0;
            break;
          case 1:
            result = computeSingleParam(type.parameterStructures, params[0]);
            break;
          default:
            result = [];
            for (let i = 0; i < params.length && i < numberOfParams; i++) {
              result.push(undefinedToNull(params[i]));
            }
            if (params.length < numberOfParams) {
              for (let i = params.length; i < numberOfParams; i++) {
                result.push(null);
              }
            }
            break;
        }
        return result;
      }
      const connection2 = {
        sendNotification: (type, ...args) => {
          throwIfClosedOrDisposed();
          let method;
          let messageParams;
          if (Is.string(type)) {
            method = type;
            const first = args[0];
            let paramStart = 0;
            let parameterStructures = messages_1.ParameterStructures.auto;
            if (messages_1.ParameterStructures.is(first)) {
              paramStart = 1;
              parameterStructures = first;
            }
            let paramEnd = args.length;
            const numberOfParams = paramEnd - paramStart;
            switch (numberOfParams) {
              case 0:
                messageParams = void 0;
                break;
              case 1:
                messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                break;
              default:
                if (parameterStructures === messages_1.ParameterStructures.byName) {
                  throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                }
                messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                break;
            }
          } else {
            const params = args;
            method = type.method;
            messageParams = computeMessageParams(type, params);
          }
          const notificationMessage = {
            jsonrpc: version,
            method,
            params: messageParams
          };
          traceSendingNotification(notificationMessage);
          return messageWriter.write(notificationMessage).catch((error) => {
            logger.error(`Sending notification failed.`);
            throw error;
          });
        },
        onNotification: (type, handler) => {
          throwIfClosedOrDisposed();
          let method;
          if (Is.func(type)) {
            starNotificationHandler = type;
          } else if (handler) {
            if (Is.string(type)) {
              method = type;
              notificationHandlers.set(type, { type: void 0, handler });
            } else {
              method = type.method;
              notificationHandlers.set(type.method, { type, handler });
            }
          }
          return {
            dispose: () => {
              if (method !== void 0) {
                notificationHandlers.delete(method);
              } else {
                starNotificationHandler = void 0;
              }
            }
          };
        },
        onProgress: (_type, token, handler) => {
          if (progressHandlers.has(token)) {
            throw new Error(`Progress handler for token ${token} already registered`);
          }
          progressHandlers.set(token, handler);
          return {
            dispose: () => {
              progressHandlers.delete(token);
            }
          };
        },
        sendProgress: (_type, token, value) => {
          return connection2.sendNotification(ProgressNotification.type, { token, value });
        },
        onUnhandledProgress: unhandledProgressEmitter.event,
        sendRequest: (type, ...args) => {
          throwIfClosedOrDisposed();
          throwIfNotListening();
          let method;
          let messageParams;
          let token = void 0;
          if (Is.string(type)) {
            method = type;
            const first = args[0];
            const last = args[args.length - 1];
            let paramStart = 0;
            let parameterStructures = messages_1.ParameterStructures.auto;
            if (messages_1.ParameterStructures.is(first)) {
              paramStart = 1;
              parameterStructures = first;
            }
            let paramEnd = args.length;
            if (cancellation_1.CancellationToken.is(last)) {
              paramEnd = paramEnd - 1;
              token = last;
            }
            const numberOfParams = paramEnd - paramStart;
            switch (numberOfParams) {
              case 0:
                messageParams = void 0;
                break;
              case 1:
                messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                break;
              default:
                if (parameterStructures === messages_1.ParameterStructures.byName) {
                  throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                }
                messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                break;
            }
          } else {
            const params = args;
            method = type.method;
            messageParams = computeMessageParams(type, params);
            const numberOfParams = type.numberOfParams;
            token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : void 0;
          }
          const id = sequenceNumber++;
          let disposable;
          if (token) {
            disposable = token.onCancellationRequested(() => {
              const p = cancellationStrategy.sender.sendCancellation(connection2, id);
              if (p === void 0) {
                logger.log(`Received no promise from cancellation strategy when cancelling id ${id}`);
                return Promise.resolve();
              } else {
                return p.catch(() => {
                  logger.log(`Sending cancellation messages for id ${id} failed`);
                });
              }
            });
          }
          const requestMessage = {
            jsonrpc: version,
            id,
            method,
            params: messageParams
          };
          traceSendingRequest(requestMessage);
          if (typeof cancellationStrategy.sender.enableCancellation === "function") {
            cancellationStrategy.sender.enableCancellation(requestMessage);
          }
          return new Promise(async (resolve, reject) => {
            const resolveWithCleanup = (r) => {
              resolve(r);
              cancellationStrategy.sender.cleanup(id);
              disposable?.dispose();
            };
            const rejectWithCleanup = (r) => {
              reject(r);
              cancellationStrategy.sender.cleanup(id);
              disposable?.dispose();
            };
            const responsePromise = { method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };
            try {
              await messageWriter.write(requestMessage);
              responsePromises.set(id, responsePromise);
            } catch (error) {
              logger.error(`Sending request failed.`);
              responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, error.message ? error.message : "Unknown reason"));
              throw error;
            }
          });
        },
        onRequest: (type, handler) => {
          throwIfClosedOrDisposed();
          let method = null;
          if (StarRequestHandler.is(type)) {
            method = void 0;
            starRequestHandler = type;
          } else if (Is.string(type)) {
            method = null;
            if (handler !== void 0) {
              method = type;
              requestHandlers.set(type, { handler, type: void 0 });
            }
          } else {
            if (handler !== void 0) {
              method = type.method;
              requestHandlers.set(type.method, { type, handler });
            }
          }
          return {
            dispose: () => {
              if (method === null) {
                return;
              }
              if (method !== void 0) {
                requestHandlers.delete(method);
              } else {
                starRequestHandler = void 0;
              }
            }
          };
        },
        hasPendingResponse: () => {
          return responsePromises.size > 0;
        },
        trace: async (_value, _tracer, sendNotificationOrTraceOptions) => {
          let _sendNotification = false;
          let _traceFormat = TraceFormat.Text;
          if (sendNotificationOrTraceOptions !== void 0) {
            if (Is.boolean(sendNotificationOrTraceOptions)) {
              _sendNotification = sendNotificationOrTraceOptions;
            } else {
              _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
              _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
            }
          }
          trace = _value;
          traceFormat = _traceFormat;
          if (trace === Trace.Off) {
            tracer = void 0;
          } else {
            tracer = _tracer;
          }
          if (_sendNotification && !isClosed() && !isDisposed()) {
            await connection2.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });
          }
        },
        onError: errorEmitter.event,
        onClose: closeEmitter.event,
        onUnhandledNotification: unhandledNotificationEmitter.event,
        onDispose: disposeEmitter.event,
        end: () => {
          messageWriter.end();
        },
        dispose: () => {
          if (isDisposed()) {
            return;
          }
          state = ConnectionState.Disposed;
          disposeEmitter.fire(void 0);
          const error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, "Pending response rejected since connection got disposed");
          for (const promise of responsePromises.values()) {
            promise.reject(error);
          }
          responsePromises = /* @__PURE__ */ new Map();
          requestTokens = /* @__PURE__ */ new Map();
          knownCanceledRequests = /* @__PURE__ */ new Set();
          messageQueue = new linkedMap_1.LinkedMap();
          if (Is.func(messageWriter.dispose)) {
            messageWriter.dispose();
          }
          if (Is.func(messageReader.dispose)) {
            messageReader.dispose();
          }
        },
        listen: () => {
          throwIfClosedOrDisposed();
          throwIfListening();
          state = ConnectionState.Listening;
          messageReader.listen(callback);
        },
        inspect: () => {
          (0, ral_1.default)().console.log("inspect");
        }
      };
      connection2.onNotification(LogTraceNotification.type, (params) => {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        const verbose = trace === Trace.Verbose || trace === Trace.Compact;
        tracer.log(params.message, verbose ? params.verbose : void 0);
      });
      connection2.onNotification(ProgressNotification.type, (params) => {
        const handler = progressHandlers.get(params.token);
        if (handler) {
          handler(params.value);
        } else {
          unhandledProgressEmitter.fire(params);
        }
      });
      return connection2;
    }
    exports2.createMessageConnection = createMessageConnection;
  }
});

// ../../node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/api.js
var require_api = __commonJS({
  "../../node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/api.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProgressType = exports2.ProgressToken = exports2.createMessageConnection = exports2.NullLogger = exports2.ConnectionOptions = exports2.ConnectionStrategy = exports2.AbstractMessageBuffer = exports2.WriteableStreamMessageWriter = exports2.AbstractMessageWriter = exports2.MessageWriter = exports2.ReadableStreamMessageReader = exports2.AbstractMessageReader = exports2.MessageReader = exports2.SharedArrayReceiverStrategy = exports2.SharedArraySenderStrategy = exports2.CancellationToken = exports2.CancellationTokenSource = exports2.Emitter = exports2.Event = exports2.Disposable = exports2.LRUCache = exports2.Touch = exports2.LinkedMap = exports2.ParameterStructures = exports2.NotificationType9 = exports2.NotificationType8 = exports2.NotificationType7 = exports2.NotificationType6 = exports2.NotificationType5 = exports2.NotificationType4 = exports2.NotificationType3 = exports2.NotificationType2 = exports2.NotificationType1 = exports2.NotificationType0 = exports2.NotificationType = exports2.ErrorCodes = exports2.ResponseError = exports2.RequestType9 = exports2.RequestType8 = exports2.RequestType7 = exports2.RequestType6 = exports2.RequestType5 = exports2.RequestType4 = exports2.RequestType3 = exports2.RequestType2 = exports2.RequestType1 = exports2.RequestType0 = exports2.RequestType = exports2.Message = exports2.RAL = void 0;
    exports2.MessageStrategy = exports2.CancellationStrategy = exports2.CancellationSenderStrategy = exports2.CancellationReceiverStrategy = exports2.ConnectionError = exports2.ConnectionErrors = exports2.LogTraceNotification = exports2.SetTraceNotification = exports2.TraceFormat = exports2.TraceValues = exports2.Trace = void 0;
    var messages_1 = require_messages();
    Object.defineProperty(exports2, "Message", { enumerable: true, get: function() {
      return messages_1.Message;
    } });
    Object.defineProperty(exports2, "RequestType", { enumerable: true, get: function() {
      return messages_1.RequestType;
    } });
    Object.defineProperty(exports2, "RequestType0", { enumerable: true, get: function() {
      return messages_1.RequestType0;
    } });
    Object.defineProperty(exports2, "RequestType1", { enumerable: true, get: function() {
      return messages_1.RequestType1;
    } });
    Object.defineProperty(exports2, "RequestType2", { enumerable: true, get: function() {
      return messages_1.RequestType2;
    } });
    Object.defineProperty(exports2, "RequestType3", { enumerable: true, get: function() {
      return messages_1.RequestType3;
    } });
    Object.defineProperty(exports2, "RequestType4", { enumerable: true, get: function() {
      return messages_1.RequestType4;
    } });
    Object.defineProperty(exports2, "RequestType5", { enumerable: true, get: function() {
      return messages_1.RequestType5;
    } });
    Object.defineProperty(exports2, "RequestType6", { enumerable: true, get: function() {
      return messages_1.RequestType6;
    } });
    Object.defineProperty(exports2, "RequestType7", { enumerable: true, get: function() {
      return messages_1.RequestType7;
    } });
    Object.defineProperty(exports2, "RequestType8", { enumerable: true, get: function() {
      return messages_1.RequestType8;
    } });
    Object.defineProperty(exports2, "RequestType9", { enumerable: true, get: function() {
      return messages_1.RequestType9;
    } });
    Object.defineProperty(exports2, "ResponseError", { enumerable: true, get: function() {
      return messages_1.ResponseError;
    } });
    Object.defineProperty(exports2, "ErrorCodes", { enumerable: true, get: function() {
      return messages_1.ErrorCodes;
    } });
    Object.defineProperty(exports2, "NotificationType", { enumerable: true, get: function() {
      return messages_1.NotificationType;
    } });
    Object.defineProperty(exports2, "NotificationType0", { enumerable: true, get: function() {
      return messages_1.NotificationType0;
    } });
    Object.defineProperty(exports2, "NotificationType1", { enumerable: true, get: function() {
      return messages_1.NotificationType1;
    } });
    Object.defineProperty(exports2, "NotificationType2", { enumerable: true, get: function() {
      return messages_1.NotificationType2;
    } });
    Object.defineProperty(exports2, "NotificationType3", { enumerable: true, get: function() {
      return messages_1.NotificationType3;
    } });
    Object.defineProperty(exports2, "NotificationType4", { enumerable: true, get: function() {
      return messages_1.NotificationType4;
    } });
    Object.defineProperty(exports2, "NotificationType5", { enumerable: true, get: function() {
      return messages_1.NotificationType5;
    } });
    Object.defineProperty(exports2, "NotificationType6", { enumerable: true, get: function() {
      return messages_1.NotificationType6;
    } });
    Object.defineProperty(exports2, "NotificationType7", { enumerable: true, get: function() {
      return messages_1.NotificationType7;
    } });
    Object.defineProperty(exports2, "NotificationType8", { enumerable: true, get: function() {
      return messages_1.NotificationType8;
    } });
    Object.defineProperty(exports2, "NotificationType9", { enumerable: true, get: function() {
      return messages_1.NotificationType9;
    } });
    Object.defineProperty(exports2, "ParameterStructures", { enumerable: true, get: function() {
      return messages_1.ParameterStructures;
    } });
    var linkedMap_1 = require_linkedMap();
    Object.defineProperty(exports2, "LinkedMap", { enumerable: true, get: function() {
      return linkedMap_1.LinkedMap;
    } });
    Object.defineProperty(exports2, "LRUCache", { enumerable: true, get: function() {
      return linkedMap_1.LRUCache;
    } });
    Object.defineProperty(exports2, "Touch", { enumerable: true, get: function() {
      return linkedMap_1.Touch;
    } });
    var disposable_1 = require_disposable();
    Object.defineProperty(exports2, "Disposable", { enumerable: true, get: function() {
      return disposable_1.Disposable;
    } });
    var events_1 = require_events();
    Object.defineProperty(exports2, "Event", { enumerable: true, get: function() {
      return events_1.Event;
    } });
    Object.defineProperty(exports2, "Emitter", { enumerable: true, get: function() {
      return events_1.Emitter;
    } });
    var cancellation_1 = require_cancellation();
    Object.defineProperty(exports2, "CancellationTokenSource", { enumerable: true, get: function() {
      return cancellation_1.CancellationTokenSource;
    } });
    Object.defineProperty(exports2, "CancellationToken", { enumerable: true, get: function() {
      return cancellation_1.CancellationToken;
    } });
    var sharedArrayCancellation_1 = require_sharedArrayCancellation();
    Object.defineProperty(exports2, "SharedArraySenderStrategy", { enumerable: true, get: function() {
      return sharedArrayCancellation_1.SharedArraySenderStrategy;
    } });
    Object.defineProperty(exports2, "SharedArrayReceiverStrategy", { enumerable: true, get: function() {
      return sharedArrayCancellation_1.SharedArrayReceiverStrategy;
    } });
    var messageReader_1 = require_messageReader();
    Object.defineProperty(exports2, "MessageReader", { enumerable: true, get: function() {
      return messageReader_1.MessageReader;
    } });
    Object.defineProperty(exports2, "AbstractMessageReader", { enumerable: true, get: function() {
      return messageReader_1.AbstractMessageReader;
    } });
    Object.defineProperty(exports2, "ReadableStreamMessageReader", { enumerable: true, get: function() {
      return messageReader_1.ReadableStreamMessageReader;
    } });
    var messageWriter_1 = require_messageWriter();
    Object.defineProperty(exports2, "MessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.MessageWriter;
    } });
    Object.defineProperty(exports2, "AbstractMessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.AbstractMessageWriter;
    } });
    Object.defineProperty(exports2, "WriteableStreamMessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.WriteableStreamMessageWriter;
    } });
    var messageBuffer_1 = require_messageBuffer();
    Object.defineProperty(exports2, "AbstractMessageBuffer", { enumerable: true, get: function() {
      return messageBuffer_1.AbstractMessageBuffer;
    } });
    var connection_1 = require_connection();
    Object.defineProperty(exports2, "ConnectionStrategy", { enumerable: true, get: function() {
      return connection_1.ConnectionStrategy;
    } });
    Object.defineProperty(exports2, "ConnectionOptions", { enumerable: true, get: function() {
      return connection_1.ConnectionOptions;
    } });
    Object.defineProperty(exports2, "NullLogger", { enumerable: true, get: function() {
      return connection_1.NullLogger;
    } });
    Object.defineProperty(exports2, "createMessageConnection", { enumerable: true, get: function() {
      return connection_1.createMessageConnection;
    } });
    Object.defineProperty(exports2, "ProgressToken", { enumerable: true, get: function() {
      return connection_1.ProgressToken;
    } });
    Object.defineProperty(exports2, "ProgressType", { enumerable: true, get: function() {
      return connection_1.ProgressType;
    } });
    Object.defineProperty(exports2, "Trace", { enumerable: true, get: function() {
      return connection_1.Trace;
    } });
    Object.defineProperty(exports2, "TraceValues", { enumerable: true, get: function() {
      return connection_1.TraceValues;
    } });
    Object.defineProperty(exports2, "TraceFormat", { enumerable: true, get: function() {
      return connection_1.TraceFormat;
    } });
    Object.defineProperty(exports2, "SetTraceNotification", { enumerable: true, get: function() {
      return connection_1.SetTraceNotification;
    } });
    Object.defineProperty(exports2, "LogTraceNotification", { enumerable: true, get: function() {
      return connection_1.LogTraceNotification;
    } });
    Object.defineProperty(exports2, "ConnectionErrors", { enumerable: true, get: function() {
      return connection_1.ConnectionErrors;
    } });
    Object.defineProperty(exports2, "ConnectionError", { enumerable: true, get: function() {
      return connection_1.ConnectionError;
    } });
    Object.defineProperty(exports2, "CancellationReceiverStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationReceiverStrategy;
    } });
    Object.defineProperty(exports2, "CancellationSenderStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationSenderStrategy;
    } });
    Object.defineProperty(exports2, "CancellationStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationStrategy;
    } });
    Object.defineProperty(exports2, "MessageStrategy", { enumerable: true, get: function() {
      return connection_1.MessageStrategy;
    } });
    var ral_1 = require_ral();
    exports2.RAL = ral_1.default;
  }
});

// ../../node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/node/ril.js
var require_ril = __commonJS({
  "../../node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/node/ril.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require("util");
    var api_1 = require_api();
    var MessageBuffer = class _MessageBuffer extends api_1.AbstractMessageBuffer {
      constructor(encoding = "utf-8") {
        super(encoding);
      }
      emptyBuffer() {
        return _MessageBuffer.emptyBuffer;
      }
      fromString(value, encoding) {
        return Buffer.from(value, encoding);
      }
      toString(value, encoding) {
        if (value instanceof Buffer) {
          return value.toString(encoding);
        } else {
          return new util_1.TextDecoder(encoding).decode(value);
        }
      }
      asNative(buffer, length) {
        if (length === void 0) {
          return buffer instanceof Buffer ? buffer : Buffer.from(buffer);
        } else {
          return buffer instanceof Buffer ? buffer.slice(0, length) : Buffer.from(buffer, 0, length);
        }
      }
      allocNative(length) {
        return Buffer.allocUnsafe(length);
      }
    };
    MessageBuffer.emptyBuffer = Buffer.allocUnsafe(0);
    var ReadableStreamWrapper = class {
      constructor(stream2) {
        this.stream = stream2;
      }
      onClose(listener) {
        this.stream.on("close", listener);
        return api_1.Disposable.create(() => this.stream.off("close", listener));
      }
      onError(listener) {
        this.stream.on("error", listener);
        return api_1.Disposable.create(() => this.stream.off("error", listener));
      }
      onEnd(listener) {
        this.stream.on("end", listener);
        return api_1.Disposable.create(() => this.stream.off("end", listener));
      }
      onData(listener) {
        this.stream.on("data", listener);
        return api_1.Disposable.create(() => this.stream.off("data", listener));
      }
    };
    var WritableStreamWrapper = class {
      constructor(stream2) {
        this.stream = stream2;
      }
      onClose(listener) {
        this.stream.on("close", listener);
        return api_1.Disposable.create(() => this.stream.off("close", listener));
      }
      onError(listener) {
        this.stream.on("error", listener);
        return api_1.Disposable.create(() => this.stream.off("error", listener));
      }
      onEnd(listener) {
        this.stream.on("end", listener);
        return api_1.Disposable.create(() => this.stream.off("end", listener));
      }
      write(data, encoding) {
        return new Promise((resolve, reject) => {
          const callback = (error) => {
            if (error === void 0 || error === null) {
              resolve();
            } else {
              reject(error);
            }
          };
          if (typeof data === "string") {
            this.stream.write(data, encoding, callback);
          } else {
            this.stream.write(data, callback);
          }
        });
      }
      end() {
        this.stream.end();
      }
    };
    var _ril = Object.freeze({
      messageBuffer: Object.freeze({
        create: (encoding) => new MessageBuffer(encoding)
      }),
      applicationJson: Object.freeze({
        encoder: Object.freeze({
          name: "application/json",
          encode: (msg, options) => {
            try {
              return Promise.resolve(Buffer.from(JSON.stringify(msg, void 0, 0), options.charset));
            } catch (err) {
              return Promise.reject(err);
            }
          }
        }),
        decoder: Object.freeze({
          name: "application/json",
          decode: (buffer, options) => {
            try {
              if (buffer instanceof Buffer) {
                return Promise.resolve(JSON.parse(buffer.toString(options.charset)));
              } else {
                return Promise.resolve(JSON.parse(new util_1.TextDecoder(options.charset).decode(buffer)));
              }
            } catch (err) {
              return Promise.reject(err);
            }
          }
        })
      }),
      stream: Object.freeze({
        asReadableStream: (stream2) => new ReadableStreamWrapper(stream2),
        asWritableStream: (stream2) => new WritableStreamWrapper(stream2)
      }),
      console,
      timer: Object.freeze({
        setTimeout(callback, ms, ...args) {
          const handle = setTimeout(callback, ms, ...args);
          return { dispose: () => clearTimeout(handle) };
        },
        setImmediate(callback, ...args) {
          const handle = setImmediate(callback, ...args);
          return { dispose: () => clearImmediate(handle) };
        },
        setInterval(callback, ms, ...args) {
          const handle = setInterval(callback, ms, ...args);
          return { dispose: () => clearInterval(handle) };
        }
      })
    });
    function RIL() {
      return _ril;
    }
    (function(RIL2) {
      function install() {
        api_1.RAL.install(_ril);
      }
      RIL2.install = install;
    })(RIL || (RIL = {}));
    exports2.default = RIL;
  }
});

// ../../node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/node/main.js
var require_main = __commonJS({
  "../../node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/node/main.js"(exports2) {
    "use strict";
    init_importMeta();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createMessageConnection = exports2.createServerSocketTransport = exports2.createClientSocketTransport = exports2.createServerPipeTransport = exports2.createClientPipeTransport = exports2.generateRandomPipeName = exports2.StreamMessageWriter = exports2.StreamMessageReader = exports2.SocketMessageWriter = exports2.SocketMessageReader = exports2.PortMessageWriter = exports2.PortMessageReader = exports2.IPCMessageWriter = exports2.IPCMessageReader = void 0;
    var ril_1 = require_ril();
    ril_1.default.install();
    var path2 = require("path");
    var os = require("os");
    var crypto_1 = require("crypto");
    var net_1 = require("net");
    var api_1 = require_api();
    __exportStar(require_api(), exports2);
    var IPCMessageReader = class extends api_1.AbstractMessageReader {
      constructor(process2) {
        super();
        this.process = process2;
        let eventEmitter = this.process;
        eventEmitter.on("error", (error) => this.fireError(error));
        eventEmitter.on("close", () => this.fireClose());
      }
      listen(callback) {
        this.process.on("message", callback);
        return api_1.Disposable.create(() => this.process.off("message", callback));
      }
    };
    exports2.IPCMessageReader = IPCMessageReader;
    var IPCMessageWriter = class extends api_1.AbstractMessageWriter {
      constructor(process2) {
        super();
        this.process = process2;
        this.errorCount = 0;
        const eventEmitter = this.process;
        eventEmitter.on("error", (error) => this.fireError(error));
        eventEmitter.on("close", () => this.fireClose);
      }
      write(msg) {
        try {
          if (typeof this.process.send === "function") {
            this.process.send(msg, void 0, void 0, (error) => {
              if (error) {
                this.errorCount++;
                this.handleError(error, msg);
              } else {
                this.errorCount = 0;
              }
            });
          }
          return Promise.resolve();
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
      }
    };
    exports2.IPCMessageWriter = IPCMessageWriter;
    var PortMessageReader = class extends api_1.AbstractMessageReader {
      constructor(port) {
        super();
        this.onData = new api_1.Emitter();
        port.on("close", () => this.fireClose);
        port.on("error", (error) => this.fireError(error));
        port.on("message", (message) => {
          this.onData.fire(message);
        });
      }
      listen(callback) {
        return this.onData.event(callback);
      }
    };
    exports2.PortMessageReader = PortMessageReader;
    var PortMessageWriter = class extends api_1.AbstractMessageWriter {
      constructor(port) {
        super();
        this.port = port;
        this.errorCount = 0;
        port.on("close", () => this.fireClose());
        port.on("error", (error) => this.fireError(error));
      }
      write(msg) {
        try {
          this.port.postMessage(msg);
          return Promise.resolve();
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
      }
    };
    exports2.PortMessageWriter = PortMessageWriter;
    var SocketMessageReader = class extends api_1.ReadableStreamMessageReader {
      constructor(socket, encoding = "utf-8") {
        super((0, ril_1.default)().stream.asReadableStream(socket), encoding);
      }
    };
    exports2.SocketMessageReader = SocketMessageReader;
    var SocketMessageWriter = class extends api_1.WriteableStreamMessageWriter {
      constructor(socket, options) {
        super((0, ril_1.default)().stream.asWritableStream(socket), options);
        this.socket = socket;
      }
      dispose() {
        super.dispose();
        this.socket.destroy();
      }
    };
    exports2.SocketMessageWriter = SocketMessageWriter;
    var StreamMessageReader = class extends api_1.ReadableStreamMessageReader {
      constructor(readable, encoding) {
        super((0, ril_1.default)().stream.asReadableStream(readable), encoding);
      }
    };
    exports2.StreamMessageReader = StreamMessageReader;
    var StreamMessageWriter = class extends api_1.WriteableStreamMessageWriter {
      constructor(writable, options) {
        super((0, ril_1.default)().stream.asWritableStream(writable), options);
      }
    };
    exports2.StreamMessageWriter = StreamMessageWriter;
    var XDG_RUNTIME_DIR = process.env["XDG_RUNTIME_DIR"];
    var safeIpcPathLengths = /* @__PURE__ */ new Map([
      ["linux", 107],
      ["darwin", 103]
    ]);
    function generateRandomPipeName() {
      const randomSuffix = (0, crypto_1.randomBytes)(21).toString("hex");
      if (process.platform === "win32") {
        return `\\\\.\\pipe\\vscode-jsonrpc-${randomSuffix}-sock`;
      }
      let result;
      if (XDG_RUNTIME_DIR) {
        result = path2.join(XDG_RUNTIME_DIR, `vscode-ipc-${randomSuffix}.sock`);
      } else {
        result = path2.join(os.tmpdir(), `vscode-${randomSuffix}.sock`);
      }
      const limit = safeIpcPathLengths.get(process.platform);
      if (limit !== void 0 && result.length > limit) {
        (0, ril_1.default)().console.warn(`WARNING: IPC handle "${result}" is longer than ${limit} characters.`);
      }
      return result;
    }
    exports2.generateRandomPipeName = generateRandomPipeName;
    function createClientPipeTransport(pipeName, encoding = "utf-8") {
      let connectResolve;
      const connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
      });
      return new Promise((resolve, reject) => {
        let server = (0, net_1.createServer)((socket) => {
          server.close();
          connectResolve([
            new SocketMessageReader(socket, encoding),
            new SocketMessageWriter(socket, encoding)
          ]);
        });
        server.on("error", reject);
        server.listen(pipeName, () => {
          server.removeListener("error", reject);
          resolve({
            onConnected: () => {
              return connected;
            }
          });
        });
      });
    }
    exports2.createClientPipeTransport = createClientPipeTransport;
    function createServerPipeTransport(pipeName, encoding = "utf-8") {
      const socket = (0, net_1.createConnection)(pipeName);
      return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
      ];
    }
    exports2.createServerPipeTransport = createServerPipeTransport;
    function createClientSocketTransport(port, encoding = "utf-8") {
      let connectResolve;
      const connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
      });
      return new Promise((resolve, reject) => {
        const server = (0, net_1.createServer)((socket) => {
          server.close();
          connectResolve([
            new SocketMessageReader(socket, encoding),
            new SocketMessageWriter(socket, encoding)
          ]);
        });
        server.on("error", reject);
        server.listen(port, "127.0.0.1", () => {
          server.removeListener("error", reject);
          resolve({
            onConnected: () => {
              return connected;
            }
          });
        });
      });
    }
    exports2.createClientSocketTransport = createClientSocketTransport;
    function createServerSocketTransport(port, encoding = "utf-8") {
      const socket = (0, net_1.createConnection)(port, "127.0.0.1");
      return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
      ];
    }
    exports2.createServerSocketTransport = createServerSocketTransport;
    function isReadableStream(value) {
      const candidate = value;
      return candidate.read !== void 0 && candidate.addListener !== void 0;
    }
    function isWritableStream(value) {
      const candidate = value;
      return candidate.write !== void 0 && candidate.addListener !== void 0;
    }
    function createMessageConnection(input, output, logger, options) {
      if (!logger) {
        logger = api_1.NullLogger;
      }
      const reader = isReadableStream(input) ? new StreamMessageReader(input) : input;
      const writer = isWritableStream(output) ? new StreamMessageWriter(output) : output;
      if (api_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
      }
      return (0, api_1.createMessageConnection)(reader, writer, logger, options);
    }
    exports2.createMessageConnection = createMessageConnection;
  }
});

// ../../node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/node.js
var require_node = __commonJS({
  "../../node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/node.js"(exports2, module2) {
    "use strict";
    init_importMeta();
    module2.exports = require_main();
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-types@3.17.5/node_modules/vscode-languageserver-types/lib/umd/main.js
var require_main2 = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-types@3.17.5/node_modules/vscode-languageserver-types/lib/umd/main.js"(exports2, module2) {
    init_importMeta();
    (function(factory) {
      if (typeof module2 === "object" && typeof module2.exports === "object") {
        var v = factory(require, exports2);
        if (v !== void 0) module2.exports = v;
      } else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
      }
    })(function(require2, exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.TextDocument = exports3.EOL = exports3.WorkspaceFolder = exports3.InlineCompletionContext = exports3.SelectedCompletionInfo = exports3.InlineCompletionTriggerKind = exports3.InlineCompletionList = exports3.InlineCompletionItem = exports3.StringValue = exports3.InlayHint = exports3.InlayHintLabelPart = exports3.InlayHintKind = exports3.InlineValueContext = exports3.InlineValueEvaluatableExpression = exports3.InlineValueVariableLookup = exports3.InlineValueText = exports3.SemanticTokens = exports3.SemanticTokenModifiers = exports3.SemanticTokenTypes = exports3.SelectionRange = exports3.DocumentLink = exports3.FormattingOptions = exports3.CodeLens = exports3.CodeAction = exports3.CodeActionContext = exports3.CodeActionTriggerKind = exports3.CodeActionKind = exports3.DocumentSymbol = exports3.WorkspaceSymbol = exports3.SymbolInformation = exports3.SymbolTag = exports3.SymbolKind = exports3.DocumentHighlight = exports3.DocumentHighlightKind = exports3.SignatureInformation = exports3.ParameterInformation = exports3.Hover = exports3.MarkedString = exports3.CompletionList = exports3.CompletionItem = exports3.CompletionItemLabelDetails = exports3.InsertTextMode = exports3.InsertReplaceEdit = exports3.CompletionItemTag = exports3.InsertTextFormat = exports3.CompletionItemKind = exports3.MarkupContent = exports3.MarkupKind = exports3.TextDocumentItem = exports3.OptionalVersionedTextDocumentIdentifier = exports3.VersionedTextDocumentIdentifier = exports3.TextDocumentIdentifier = exports3.WorkspaceChange = exports3.WorkspaceEdit = exports3.DeleteFile = exports3.RenameFile = exports3.CreateFile = exports3.TextDocumentEdit = exports3.AnnotatedTextEdit = exports3.ChangeAnnotationIdentifier = exports3.ChangeAnnotation = exports3.TextEdit = exports3.Command = exports3.Diagnostic = exports3.CodeDescription = exports3.DiagnosticTag = exports3.DiagnosticSeverity = exports3.DiagnosticRelatedInformation = exports3.FoldingRange = exports3.FoldingRangeKind = exports3.ColorPresentation = exports3.ColorInformation = exports3.Color = exports3.LocationLink = exports3.Location = exports3.Range = exports3.Position = exports3.uinteger = exports3.integer = exports3.URI = exports3.DocumentUri = void 0;
      var DocumentUri;
      (function(DocumentUri2) {
        function is(value) {
          return typeof value === "string";
        }
        DocumentUri2.is = is;
      })(DocumentUri || (exports3.DocumentUri = DocumentUri = {}));
      var URI;
      (function(URI2) {
        function is(value) {
          return typeof value === "string";
        }
        URI2.is = is;
      })(URI || (exports3.URI = URI = {}));
      var integer;
      (function(integer2) {
        integer2.MIN_VALUE = -2147483648;
        integer2.MAX_VALUE = 2147483647;
        function is(value) {
          return typeof value === "number" && integer2.MIN_VALUE <= value && value <= integer2.MAX_VALUE;
        }
        integer2.is = is;
      })(integer || (exports3.integer = integer = {}));
      var uinteger;
      (function(uinteger2) {
        uinteger2.MIN_VALUE = 0;
        uinteger2.MAX_VALUE = 2147483647;
        function is(value) {
          return typeof value === "number" && uinteger2.MIN_VALUE <= value && value <= uinteger2.MAX_VALUE;
        }
        uinteger2.is = is;
      })(uinteger || (exports3.uinteger = uinteger = {}));
      var Position;
      (function(Position2) {
        function create(line, character) {
          if (line === Number.MAX_VALUE) {
            line = uinteger.MAX_VALUE;
          }
          if (character === Number.MAX_VALUE) {
            character = uinteger.MAX_VALUE;
          }
          return { line, character };
        }
        Position2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
        }
        Position2.is = is;
      })(Position || (exports3.Position = Position = {}));
      var Range;
      (function(Range2) {
        function create(one, two, three, four) {
          if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
            return { start: Position.create(one, two), end: Position.create(three, four) };
          } else if (Position.is(one) && Position.is(two)) {
            return { start: one, end: two };
          } else {
            throw new Error("Range#create called with invalid arguments[".concat(one, ", ").concat(two, ", ").concat(three, ", ").concat(four, "]"));
          }
        }
        Range2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
        }
        Range2.is = is;
      })(Range || (exports3.Range = Range = {}));
      var Location;
      (function(Location2) {
        function create(uri, range) {
          return { uri, range };
        }
        Location2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
        }
        Location2.is = is;
      })(Location || (exports3.Location = Location = {}));
      var LocationLink;
      (function(LocationLink2) {
        function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
          return { targetUri, targetRange, targetSelectionRange, originSelectionRange };
        }
        LocationLink2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri) && Range.is(candidate.targetSelectionRange) && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
        }
        LocationLink2.is = is;
      })(LocationLink || (exports3.LocationLink = LocationLink = {}));
      var Color;
      (function(Color2) {
        function create(red, green, blue, alpha) {
          return {
            red,
            green,
            blue,
            alpha
          };
        }
        Color2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1) && Is.numberRange(candidate.green, 0, 1) && Is.numberRange(candidate.blue, 0, 1) && Is.numberRange(candidate.alpha, 0, 1);
        }
        Color2.is = is;
      })(Color || (exports3.Color = Color = {}));
      var ColorInformation;
      (function(ColorInformation2) {
        function create(range, color) {
          return {
            range,
            color
          };
        }
        ColorInformation2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);
        }
        ColorInformation2.is = is;
      })(ColorInformation || (exports3.ColorInformation = ColorInformation = {}));
      var ColorPresentation;
      (function(ColorPresentation2) {
        function create(label, textEdit, additionalTextEdits) {
          return {
            label,
            textEdit,
            additionalTextEdits
          };
        }
        ColorPresentation2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
        }
        ColorPresentation2.is = is;
      })(ColorPresentation || (exports3.ColorPresentation = ColorPresentation = {}));
      var FoldingRangeKind;
      (function(FoldingRangeKind2) {
        FoldingRangeKind2.Comment = "comment";
        FoldingRangeKind2.Imports = "imports";
        FoldingRangeKind2.Region = "region";
      })(FoldingRangeKind || (exports3.FoldingRangeKind = FoldingRangeKind = {}));
      var FoldingRange;
      (function(FoldingRange2) {
        function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
          var result = {
            startLine,
            endLine
          };
          if (Is.defined(startCharacter)) {
            result.startCharacter = startCharacter;
          }
          if (Is.defined(endCharacter)) {
            result.endCharacter = endCharacter;
          }
          if (Is.defined(kind)) {
            result.kind = kind;
          }
          if (Is.defined(collapsedText)) {
            result.collapsedText = collapsedText;
          }
          return result;
        }
        FoldingRange2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
        }
        FoldingRange2.is = is;
      })(FoldingRange || (exports3.FoldingRange = FoldingRange = {}));
      var DiagnosticRelatedInformation;
      (function(DiagnosticRelatedInformation2) {
        function create(location, message) {
          return {
            location,
            message
          };
        }
        DiagnosticRelatedInformation2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
        }
        DiagnosticRelatedInformation2.is = is;
      })(DiagnosticRelatedInformation || (exports3.DiagnosticRelatedInformation = DiagnosticRelatedInformation = {}));
      var DiagnosticSeverity;
      (function(DiagnosticSeverity2) {
        DiagnosticSeverity2.Error = 1;
        DiagnosticSeverity2.Warning = 2;
        DiagnosticSeverity2.Information = 3;
        DiagnosticSeverity2.Hint = 4;
      })(DiagnosticSeverity || (exports3.DiagnosticSeverity = DiagnosticSeverity = {}));
      var DiagnosticTag;
      (function(DiagnosticTag2) {
        DiagnosticTag2.Unnecessary = 1;
        DiagnosticTag2.Deprecated = 2;
      })(DiagnosticTag || (exports3.DiagnosticTag = DiagnosticTag = {}));
      var CodeDescription;
      (function(CodeDescription2) {
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.string(candidate.href);
        }
        CodeDescription2.is = is;
      })(CodeDescription || (exports3.CodeDescription = CodeDescription = {}));
      var Diagnostic;
      (function(Diagnostic2) {
        function create(range, message, severity, code, source, relatedInformation) {
          var result = { range, message };
          if (Is.defined(severity)) {
            result.severity = severity;
          }
          if (Is.defined(code)) {
            result.code = code;
          }
          if (Is.defined(source)) {
            result.source = source;
          }
          if (Is.defined(relatedInformation)) {
            result.relatedInformation = relatedInformation;
          }
          return result;
        }
        Diagnostic2.create = create;
        function is(value) {
          var _a;
          var candidate = value;
          return Is.defined(candidate) && Range.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.undefined(candidate.codeDescription) || Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
        }
        Diagnostic2.is = is;
      })(Diagnostic || (exports3.Diagnostic = Diagnostic = {}));
      var Command;
      (function(Command2) {
        function create(title, command) {
          var args = [];
          for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
          }
          var result = { title, command };
          if (Is.defined(args) && args.length > 0) {
            result.arguments = args;
          }
          return result;
        }
        Command2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
        }
        Command2.is = is;
      })(Command || (exports3.Command = Command = {}));
      var TextEdit;
      (function(TextEdit2) {
        function replace(range, newText) {
          return { range, newText };
        }
        TextEdit2.replace = replace;
        function insert(position, newText) {
          return { range: { start: position, end: position }, newText };
        }
        TextEdit2.insert = insert;
        function del(range) {
          return { range, newText: "" };
        }
        TextEdit2.del = del;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range.is(candidate.range);
        }
        TextEdit2.is = is;
      })(TextEdit || (exports3.TextEdit = TextEdit = {}));
      var ChangeAnnotation;
      (function(ChangeAnnotation2) {
        function create(label, needsConfirmation, description) {
          var result = { label };
          if (needsConfirmation !== void 0) {
            result.needsConfirmation = needsConfirmation;
          }
          if (description !== void 0) {
            result.description = description;
          }
          return result;
        }
        ChangeAnnotation2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
        }
        ChangeAnnotation2.is = is;
      })(ChangeAnnotation || (exports3.ChangeAnnotation = ChangeAnnotation = {}));
      var ChangeAnnotationIdentifier;
      (function(ChangeAnnotationIdentifier2) {
        function is(value) {
          var candidate = value;
          return Is.string(candidate);
        }
        ChangeAnnotationIdentifier2.is = is;
      })(ChangeAnnotationIdentifier || (exports3.ChangeAnnotationIdentifier = ChangeAnnotationIdentifier = {}));
      var AnnotatedTextEdit;
      (function(AnnotatedTextEdit2) {
        function replace(range, newText, annotation) {
          return { range, newText, annotationId: annotation };
        }
        AnnotatedTextEdit2.replace = replace;
        function insert(position, newText, annotation) {
          return { range: { start: position, end: position }, newText, annotationId: annotation };
        }
        AnnotatedTextEdit2.insert = insert;
        function del(range, annotation) {
          return { range, newText: "", annotationId: annotation };
        }
        AnnotatedTextEdit2.del = del;
        function is(value) {
          var candidate = value;
          return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        AnnotatedTextEdit2.is = is;
      })(AnnotatedTextEdit || (exports3.AnnotatedTextEdit = AnnotatedTextEdit = {}));
      var TextDocumentEdit;
      (function(TextDocumentEdit2) {
        function create(textDocument, edits) {
          return { textDocument, edits };
        }
        TextDocumentEdit2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
        }
        TextDocumentEdit2.is = is;
      })(TextDocumentEdit || (exports3.TextDocumentEdit = TextDocumentEdit = {}));
      var CreateFile;
      (function(CreateFile2) {
        function create(uri, options, annotation) {
          var result = {
            kind: "create",
            uri
          };
          if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
            result.options = options;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        CreateFile2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && candidate.kind === "create" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        CreateFile2.is = is;
      })(CreateFile || (exports3.CreateFile = CreateFile = {}));
      var RenameFile;
      (function(RenameFile2) {
        function create(oldUri, newUri, options, annotation) {
          var result = {
            kind: "rename",
            oldUri,
            newUri
          };
          if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
            result.options = options;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        RenameFile2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && candidate.kind === "rename" && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        RenameFile2.is = is;
      })(RenameFile || (exports3.RenameFile = RenameFile = {}));
      var DeleteFile;
      (function(DeleteFile2) {
        function create(uri, options, annotation) {
          var result = {
            kind: "delete",
            uri
          };
          if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {
            result.options = options;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        DeleteFile2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && candidate.kind === "delete" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.recursive === void 0 || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        DeleteFile2.is = is;
      })(DeleteFile || (exports3.DeleteFile = DeleteFile = {}));
      var WorkspaceEdit;
      (function(WorkspaceEdit2) {
        function is(value) {
          var candidate = value;
          return candidate && (candidate.changes !== void 0 || candidate.documentChanges !== void 0) && (candidate.documentChanges === void 0 || candidate.documentChanges.every(function(change) {
            if (Is.string(change.kind)) {
              return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
            } else {
              return TextDocumentEdit.is(change);
            }
          }));
        }
        WorkspaceEdit2.is = is;
      })(WorkspaceEdit || (exports3.WorkspaceEdit = WorkspaceEdit = {}));
      var TextEditChangeImpl = (
        /** @class */
        function() {
          function TextEditChangeImpl2(edits, changeAnnotations) {
            this.edits = edits;
            this.changeAnnotations = changeAnnotations;
          }
          TextEditChangeImpl2.prototype.insert = function(position, newText, annotation) {
            var edit;
            var id;
            if (annotation === void 0) {
              edit = TextEdit.insert(position, newText);
            } else if (ChangeAnnotationIdentifier.is(annotation)) {
              id = annotation;
              edit = AnnotatedTextEdit.insert(position, newText, annotation);
            } else {
              this.assertChangeAnnotations(this.changeAnnotations);
              id = this.changeAnnotations.manage(annotation);
              edit = AnnotatedTextEdit.insert(position, newText, id);
            }
            this.edits.push(edit);
            if (id !== void 0) {
              return id;
            }
          };
          TextEditChangeImpl2.prototype.replace = function(range, newText, annotation) {
            var edit;
            var id;
            if (annotation === void 0) {
              edit = TextEdit.replace(range, newText);
            } else if (ChangeAnnotationIdentifier.is(annotation)) {
              id = annotation;
              edit = AnnotatedTextEdit.replace(range, newText, annotation);
            } else {
              this.assertChangeAnnotations(this.changeAnnotations);
              id = this.changeAnnotations.manage(annotation);
              edit = AnnotatedTextEdit.replace(range, newText, id);
            }
            this.edits.push(edit);
            if (id !== void 0) {
              return id;
            }
          };
          TextEditChangeImpl2.prototype.delete = function(range, annotation) {
            var edit;
            var id;
            if (annotation === void 0) {
              edit = TextEdit.del(range);
            } else if (ChangeAnnotationIdentifier.is(annotation)) {
              id = annotation;
              edit = AnnotatedTextEdit.del(range, annotation);
            } else {
              this.assertChangeAnnotations(this.changeAnnotations);
              id = this.changeAnnotations.manage(annotation);
              edit = AnnotatedTextEdit.del(range, id);
            }
            this.edits.push(edit);
            if (id !== void 0) {
              return id;
            }
          };
          TextEditChangeImpl2.prototype.add = function(edit) {
            this.edits.push(edit);
          };
          TextEditChangeImpl2.prototype.all = function() {
            return this.edits;
          };
          TextEditChangeImpl2.prototype.clear = function() {
            this.edits.splice(0, this.edits.length);
          };
          TextEditChangeImpl2.prototype.assertChangeAnnotations = function(value) {
            if (value === void 0) {
              throw new Error("Text edit change is not configured to manage change annotations.");
            }
          };
          return TextEditChangeImpl2;
        }()
      );
      var ChangeAnnotations = (
        /** @class */
        function() {
          function ChangeAnnotations2(annotations) {
            this._annotations = annotations === void 0 ? /* @__PURE__ */ Object.create(null) : annotations;
            this._counter = 0;
            this._size = 0;
          }
          ChangeAnnotations2.prototype.all = function() {
            return this._annotations;
          };
          Object.defineProperty(ChangeAnnotations2.prototype, "size", {
            get: function() {
              return this._size;
            },
            enumerable: false,
            configurable: true
          });
          ChangeAnnotations2.prototype.manage = function(idOrAnnotation, annotation) {
            var id;
            if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
              id = idOrAnnotation;
            } else {
              id = this.nextId();
              annotation = idOrAnnotation;
            }
            if (this._annotations[id] !== void 0) {
              throw new Error("Id ".concat(id, " is already in use."));
            }
            if (annotation === void 0) {
              throw new Error("No annotation provided for id ".concat(id));
            }
            this._annotations[id] = annotation;
            this._size++;
            return id;
          };
          ChangeAnnotations2.prototype.nextId = function() {
            this._counter++;
            return this._counter.toString();
          };
          return ChangeAnnotations2;
        }()
      );
      var WorkspaceChange = (
        /** @class */
        function() {
          function WorkspaceChange2(workspaceEdit) {
            var _this = this;
            this._textEditChanges = /* @__PURE__ */ Object.create(null);
            if (workspaceEdit !== void 0) {
              this._workspaceEdit = workspaceEdit;
              if (workspaceEdit.documentChanges) {
                this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
                workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                workspaceEdit.documentChanges.forEach(function(change) {
                  if (TextDocumentEdit.is(change)) {
                    var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);
                    _this._textEditChanges[change.textDocument.uri] = textEditChange;
                  }
                });
              } else if (workspaceEdit.changes) {
                Object.keys(workspaceEdit.changes).forEach(function(key) {
                  var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
                  _this._textEditChanges[key] = textEditChange;
                });
              }
            } else {
              this._workspaceEdit = {};
            }
          }
          Object.defineProperty(WorkspaceChange2.prototype, "edit", {
            /**
             * Returns the underlying {@link WorkspaceEdit} literal
             * use to be returned from a workspace edit operation like rename.
             */
            get: function() {
              this.initDocumentChanges();
              if (this._changeAnnotations !== void 0) {
                if (this._changeAnnotations.size === 0) {
                  this._workspaceEdit.changeAnnotations = void 0;
                } else {
                  this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                }
              }
              return this._workspaceEdit;
            },
            enumerable: false,
            configurable: true
          });
          WorkspaceChange2.prototype.getTextEditChange = function(key) {
            if (OptionalVersionedTextDocumentIdentifier.is(key)) {
              this.initDocumentChanges();
              if (this._workspaceEdit.documentChanges === void 0) {
                throw new Error("Workspace edit is not configured for document changes.");
              }
              var textDocument = { uri: key.uri, version: key.version };
              var result = this._textEditChanges[textDocument.uri];
              if (!result) {
                var edits = [];
                var textDocumentEdit = {
                  textDocument,
                  edits
                };
                this._workspaceEdit.documentChanges.push(textDocumentEdit);
                result = new TextEditChangeImpl(edits, this._changeAnnotations);
                this._textEditChanges[textDocument.uri] = result;
              }
              return result;
            } else {
              this.initChanges();
              if (this._workspaceEdit.changes === void 0) {
                throw new Error("Workspace edit is not configured for normal text edit changes.");
              }
              var result = this._textEditChanges[key];
              if (!result) {
                var edits = [];
                this._workspaceEdit.changes[key] = edits;
                result = new TextEditChangeImpl(edits);
                this._textEditChanges[key] = result;
              }
              return result;
            }
          };
          WorkspaceChange2.prototype.initDocumentChanges = function() {
            if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
              this._changeAnnotations = new ChangeAnnotations();
              this._workspaceEdit.documentChanges = [];
              this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
            }
          };
          WorkspaceChange2.prototype.initChanges = function() {
            if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
              this._workspaceEdit.changes = /* @__PURE__ */ Object.create(null);
            }
          };
          WorkspaceChange2.prototype.createFile = function(uri, optionsOrAnnotation, options) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === void 0) {
              throw new Error("Workspace edit is not configured for document changes.");
            }
            var annotation;
            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
              annotation = optionsOrAnnotation;
            } else {
              options = optionsOrAnnotation;
            }
            var operation;
            var id;
            if (annotation === void 0) {
              operation = CreateFile.create(uri, options);
            } else {
              id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
              operation = CreateFile.create(uri, options, id);
            }
            this._workspaceEdit.documentChanges.push(operation);
            if (id !== void 0) {
              return id;
            }
          };
          WorkspaceChange2.prototype.renameFile = function(oldUri, newUri, optionsOrAnnotation, options) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === void 0) {
              throw new Error("Workspace edit is not configured for document changes.");
            }
            var annotation;
            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
              annotation = optionsOrAnnotation;
            } else {
              options = optionsOrAnnotation;
            }
            var operation;
            var id;
            if (annotation === void 0) {
              operation = RenameFile.create(oldUri, newUri, options);
            } else {
              id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
              operation = RenameFile.create(oldUri, newUri, options, id);
            }
            this._workspaceEdit.documentChanges.push(operation);
            if (id !== void 0) {
              return id;
            }
          };
          WorkspaceChange2.prototype.deleteFile = function(uri, optionsOrAnnotation, options) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === void 0) {
              throw new Error("Workspace edit is not configured for document changes.");
            }
            var annotation;
            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
              annotation = optionsOrAnnotation;
            } else {
              options = optionsOrAnnotation;
            }
            var operation;
            var id;
            if (annotation === void 0) {
              operation = DeleteFile.create(uri, options);
            } else {
              id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
              operation = DeleteFile.create(uri, options, id);
            }
            this._workspaceEdit.documentChanges.push(operation);
            if (id !== void 0) {
              return id;
            }
          };
          return WorkspaceChange2;
        }()
      );
      exports3.WorkspaceChange = WorkspaceChange;
      var TextDocumentIdentifier;
      (function(TextDocumentIdentifier2) {
        function create(uri) {
          return { uri };
        }
        TextDocumentIdentifier2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri);
        }
        TextDocumentIdentifier2.is = is;
      })(TextDocumentIdentifier || (exports3.TextDocumentIdentifier = TextDocumentIdentifier = {}));
      var VersionedTextDocumentIdentifier;
      (function(VersionedTextDocumentIdentifier2) {
        function create(uri, version) {
          return { uri, version };
        }
        VersionedTextDocumentIdentifier2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
        }
        VersionedTextDocumentIdentifier2.is = is;
      })(VersionedTextDocumentIdentifier || (exports3.VersionedTextDocumentIdentifier = VersionedTextDocumentIdentifier = {}));
      var OptionalVersionedTextDocumentIdentifier;
      (function(OptionalVersionedTextDocumentIdentifier2) {
        function create(uri, version) {
          return { uri, version };
        }
        OptionalVersionedTextDocumentIdentifier2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
        }
        OptionalVersionedTextDocumentIdentifier2.is = is;
      })(OptionalVersionedTextDocumentIdentifier || (exports3.OptionalVersionedTextDocumentIdentifier = OptionalVersionedTextDocumentIdentifier = {}));
      var TextDocumentItem;
      (function(TextDocumentItem2) {
        function create(uri, languageId, version, text) {
          return { uri, languageId, version, text };
        }
        TextDocumentItem2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
        }
        TextDocumentItem2.is = is;
      })(TextDocumentItem || (exports3.TextDocumentItem = TextDocumentItem = {}));
      var MarkupKind;
      (function(MarkupKind2) {
        MarkupKind2.PlainText = "plaintext";
        MarkupKind2.Markdown = "markdown";
        function is(value) {
          var candidate = value;
          return candidate === MarkupKind2.PlainText || candidate === MarkupKind2.Markdown;
        }
        MarkupKind2.is = is;
      })(MarkupKind || (exports3.MarkupKind = MarkupKind = {}));
      var MarkupContent;
      (function(MarkupContent2) {
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
        }
        MarkupContent2.is = is;
      })(MarkupContent || (exports3.MarkupContent = MarkupContent = {}));
      var CompletionItemKind;
      (function(CompletionItemKind2) {
        CompletionItemKind2.Text = 1;
        CompletionItemKind2.Method = 2;
        CompletionItemKind2.Function = 3;
        CompletionItemKind2.Constructor = 4;
        CompletionItemKind2.Field = 5;
        CompletionItemKind2.Variable = 6;
        CompletionItemKind2.Class = 7;
        CompletionItemKind2.Interface = 8;
        CompletionItemKind2.Module = 9;
        CompletionItemKind2.Property = 10;
        CompletionItemKind2.Unit = 11;
        CompletionItemKind2.Value = 12;
        CompletionItemKind2.Enum = 13;
        CompletionItemKind2.Keyword = 14;
        CompletionItemKind2.Snippet = 15;
        CompletionItemKind2.Color = 16;
        CompletionItemKind2.File = 17;
        CompletionItemKind2.Reference = 18;
        CompletionItemKind2.Folder = 19;
        CompletionItemKind2.EnumMember = 20;
        CompletionItemKind2.Constant = 21;
        CompletionItemKind2.Struct = 22;
        CompletionItemKind2.Event = 23;
        CompletionItemKind2.Operator = 24;
        CompletionItemKind2.TypeParameter = 25;
      })(CompletionItemKind || (exports3.CompletionItemKind = CompletionItemKind = {}));
      var InsertTextFormat;
      (function(InsertTextFormat2) {
        InsertTextFormat2.PlainText = 1;
        InsertTextFormat2.Snippet = 2;
      })(InsertTextFormat || (exports3.InsertTextFormat = InsertTextFormat = {}));
      var CompletionItemTag;
      (function(CompletionItemTag2) {
        CompletionItemTag2.Deprecated = 1;
      })(CompletionItemTag || (exports3.CompletionItemTag = CompletionItemTag = {}));
      var InsertReplaceEdit;
      (function(InsertReplaceEdit2) {
        function create(newText, insert, replace) {
          return { newText, insert, replace };
        }
        InsertReplaceEdit2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);
        }
        InsertReplaceEdit2.is = is;
      })(InsertReplaceEdit || (exports3.InsertReplaceEdit = InsertReplaceEdit = {}));
      var InsertTextMode;
      (function(InsertTextMode2) {
        InsertTextMode2.asIs = 1;
        InsertTextMode2.adjustIndentation = 2;
      })(InsertTextMode || (exports3.InsertTextMode = InsertTextMode = {}));
      var CompletionItemLabelDetails;
      (function(CompletionItemLabelDetails2) {
        function is(value) {
          var candidate = value;
          return candidate && (Is.string(candidate.detail) || candidate.detail === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
        }
        CompletionItemLabelDetails2.is = is;
      })(CompletionItemLabelDetails || (exports3.CompletionItemLabelDetails = CompletionItemLabelDetails = {}));
      var CompletionItem;
      (function(CompletionItem2) {
        function create(label) {
          return { label };
        }
        CompletionItem2.create = create;
      })(CompletionItem || (exports3.CompletionItem = CompletionItem = {}));
      var CompletionList;
      (function(CompletionList2) {
        function create(items, isIncomplete) {
          return { items: items ? items : [], isIncomplete: !!isIncomplete };
        }
        CompletionList2.create = create;
      })(CompletionList || (exports3.CompletionList = CompletionList = {}));
      var MarkedString;
      (function(MarkedString2) {
        function fromPlainText(plainText) {
          return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
        }
        MarkedString2.fromPlainText = fromPlainText;
        function is(value) {
          var candidate = value;
          return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);
        }
        MarkedString2.is = is;
      })(MarkedString || (exports3.MarkedString = MarkedString = {}));
      var Hover;
      (function(Hover2) {
        function is(value) {
          var candidate = value;
          return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) || MarkedString.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === void 0 || Range.is(value.range));
        }
        Hover2.is = is;
      })(Hover || (exports3.Hover = Hover = {}));
      var ParameterInformation;
      (function(ParameterInformation2) {
        function create(label, documentation) {
          return documentation ? { label, documentation } : { label };
        }
        ParameterInformation2.create = create;
      })(ParameterInformation || (exports3.ParameterInformation = ParameterInformation = {}));
      var SignatureInformation;
      (function(SignatureInformation2) {
        function create(label, documentation) {
          var parameters = [];
          for (var _i = 2; _i < arguments.length; _i++) {
            parameters[_i - 2] = arguments[_i];
          }
          var result = { label };
          if (Is.defined(documentation)) {
            result.documentation = documentation;
          }
          if (Is.defined(parameters)) {
            result.parameters = parameters;
          } else {
            result.parameters = [];
          }
          return result;
        }
        SignatureInformation2.create = create;
      })(SignatureInformation || (exports3.SignatureInformation = SignatureInformation = {}));
      var DocumentHighlightKind;
      (function(DocumentHighlightKind2) {
        DocumentHighlightKind2.Text = 1;
        DocumentHighlightKind2.Read = 2;
        DocumentHighlightKind2.Write = 3;
      })(DocumentHighlightKind || (exports3.DocumentHighlightKind = DocumentHighlightKind = {}));
      var DocumentHighlight;
      (function(DocumentHighlight2) {
        function create(range, kind) {
          var result = { range };
          if (Is.number(kind)) {
            result.kind = kind;
          }
          return result;
        }
        DocumentHighlight2.create = create;
      })(DocumentHighlight || (exports3.DocumentHighlight = DocumentHighlight = {}));
      var SymbolKind;
      (function(SymbolKind2) {
        SymbolKind2.File = 1;
        SymbolKind2.Module = 2;
        SymbolKind2.Namespace = 3;
        SymbolKind2.Package = 4;
        SymbolKind2.Class = 5;
        SymbolKind2.Method = 6;
        SymbolKind2.Property = 7;
        SymbolKind2.Field = 8;
        SymbolKind2.Constructor = 9;
        SymbolKind2.Enum = 10;
        SymbolKind2.Interface = 11;
        SymbolKind2.Function = 12;
        SymbolKind2.Variable = 13;
        SymbolKind2.Constant = 14;
        SymbolKind2.String = 15;
        SymbolKind2.Number = 16;
        SymbolKind2.Boolean = 17;
        SymbolKind2.Array = 18;
        SymbolKind2.Object = 19;
        SymbolKind2.Key = 20;
        SymbolKind2.Null = 21;
        SymbolKind2.EnumMember = 22;
        SymbolKind2.Struct = 23;
        SymbolKind2.Event = 24;
        SymbolKind2.Operator = 25;
        SymbolKind2.TypeParameter = 26;
      })(SymbolKind || (exports3.SymbolKind = SymbolKind = {}));
      var SymbolTag;
      (function(SymbolTag2) {
        SymbolTag2.Deprecated = 1;
      })(SymbolTag || (exports3.SymbolTag = SymbolTag = {}));
      var SymbolInformation;
      (function(SymbolInformation2) {
        function create(name, kind, range, uri, containerName) {
          var result = {
            name,
            kind,
            location: { uri, range }
          };
          if (containerName) {
            result.containerName = containerName;
          }
          return result;
        }
        SymbolInformation2.create = create;
      })(SymbolInformation || (exports3.SymbolInformation = SymbolInformation = {}));
      var WorkspaceSymbol;
      (function(WorkspaceSymbol2) {
        function create(name, kind, uri, range) {
          return range !== void 0 ? { name, kind, location: { uri, range } } : { name, kind, location: { uri } };
        }
        WorkspaceSymbol2.create = create;
      })(WorkspaceSymbol || (exports3.WorkspaceSymbol = WorkspaceSymbol = {}));
      var DocumentSymbol;
      (function(DocumentSymbol2) {
        function create(name, detail, kind, range, selectionRange, children) {
          var result = {
            name,
            detail,
            kind,
            range,
            selectionRange
          };
          if (children !== void 0) {
            result.children = children;
          }
          return result;
        }
        DocumentSymbol2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range.is(candidate.range) && Range.is(candidate.selectionRange) && (candidate.detail === void 0 || Is.string(candidate.detail)) && (candidate.deprecated === void 0 || Is.boolean(candidate.deprecated)) && (candidate.children === void 0 || Array.isArray(candidate.children)) && (candidate.tags === void 0 || Array.isArray(candidate.tags));
        }
        DocumentSymbol2.is = is;
      })(DocumentSymbol || (exports3.DocumentSymbol = DocumentSymbol = {}));
      var CodeActionKind;
      (function(CodeActionKind2) {
        CodeActionKind2.Empty = "";
        CodeActionKind2.QuickFix = "quickfix";
        CodeActionKind2.Refactor = "refactor";
        CodeActionKind2.RefactorExtract = "refactor.extract";
        CodeActionKind2.RefactorInline = "refactor.inline";
        CodeActionKind2.RefactorRewrite = "refactor.rewrite";
        CodeActionKind2.Source = "source";
        CodeActionKind2.SourceOrganizeImports = "source.organizeImports";
        CodeActionKind2.SourceFixAll = "source.fixAll";
      })(CodeActionKind || (exports3.CodeActionKind = CodeActionKind = {}));
      var CodeActionTriggerKind;
      (function(CodeActionTriggerKind2) {
        CodeActionTriggerKind2.Invoked = 1;
        CodeActionTriggerKind2.Automatic = 2;
      })(CodeActionTriggerKind || (exports3.CodeActionTriggerKind = CodeActionTriggerKind = {}));
      var CodeActionContext;
      (function(CodeActionContext2) {
        function create(diagnostics, only, triggerKind) {
          var result = { diagnostics };
          if (only !== void 0 && only !== null) {
            result.only = only;
          }
          if (triggerKind !== void 0 && triggerKind !== null) {
            result.triggerKind = triggerKind;
          }
          return result;
        }
        CodeActionContext2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === void 0 || Is.typedArray(candidate.only, Is.string)) && (candidate.triggerKind === void 0 || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);
        }
        CodeActionContext2.is = is;
      })(CodeActionContext || (exports3.CodeActionContext = CodeActionContext = {}));
      var CodeAction;
      (function(CodeAction2) {
        function create(title, kindOrCommandOrEdit, kind) {
          var result = { title };
          var checkKind = true;
          if (typeof kindOrCommandOrEdit === "string") {
            checkKind = false;
            result.kind = kindOrCommandOrEdit;
          } else if (Command.is(kindOrCommandOrEdit)) {
            result.command = kindOrCommandOrEdit;
          } else {
            result.edit = kindOrCommandOrEdit;
          }
          if (checkKind && kind !== void 0) {
            result.kind = kind;
          }
          return result;
        }
        CodeAction2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && Is.string(candidate.title) && (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === void 0 || Is.string(candidate.kind)) && (candidate.edit !== void 0 || candidate.command !== void 0) && (candidate.command === void 0 || Command.is(candidate.command)) && (candidate.isPreferred === void 0 || Is.boolean(candidate.isPreferred)) && (candidate.edit === void 0 || WorkspaceEdit.is(candidate.edit));
        }
        CodeAction2.is = is;
      })(CodeAction || (exports3.CodeAction = CodeAction = {}));
      var CodeLens;
      (function(CodeLens2) {
        function create(range, data) {
          var result = { range };
          if (Is.defined(data)) {
            result.data = data;
          }
          return result;
        }
        CodeLens2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
        }
        CodeLens2.is = is;
      })(CodeLens || (exports3.CodeLens = CodeLens = {}));
      var FormattingOptions;
      (function(FormattingOptions2) {
        function create(tabSize, insertSpaces) {
          return { tabSize, insertSpaces };
        }
        FormattingOptions2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
        }
        FormattingOptions2.is = is;
      })(FormattingOptions || (exports3.FormattingOptions = FormattingOptions = {}));
      var DocumentLink;
      (function(DocumentLink2) {
        function create(range, target, data) {
          return { range, target, data };
        }
        DocumentLink2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
        }
        DocumentLink2.is = is;
      })(DocumentLink || (exports3.DocumentLink = DocumentLink = {}));
      var SelectionRange;
      (function(SelectionRange2) {
        function create(range, parent) {
          return { range, parent };
        }
        SelectionRange2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === void 0 || SelectionRange2.is(candidate.parent));
        }
        SelectionRange2.is = is;
      })(SelectionRange || (exports3.SelectionRange = SelectionRange = {}));
      var SemanticTokenTypes;
      (function(SemanticTokenTypes2) {
        SemanticTokenTypes2["namespace"] = "namespace";
        SemanticTokenTypes2["type"] = "type";
        SemanticTokenTypes2["class"] = "class";
        SemanticTokenTypes2["enum"] = "enum";
        SemanticTokenTypes2["interface"] = "interface";
        SemanticTokenTypes2["struct"] = "struct";
        SemanticTokenTypes2["typeParameter"] = "typeParameter";
        SemanticTokenTypes2["parameter"] = "parameter";
        SemanticTokenTypes2["variable"] = "variable";
        SemanticTokenTypes2["property"] = "property";
        SemanticTokenTypes2["enumMember"] = "enumMember";
        SemanticTokenTypes2["event"] = "event";
        SemanticTokenTypes2["function"] = "function";
        SemanticTokenTypes2["method"] = "method";
        SemanticTokenTypes2["macro"] = "macro";
        SemanticTokenTypes2["keyword"] = "keyword";
        SemanticTokenTypes2["modifier"] = "modifier";
        SemanticTokenTypes2["comment"] = "comment";
        SemanticTokenTypes2["string"] = "string";
        SemanticTokenTypes2["number"] = "number";
        SemanticTokenTypes2["regexp"] = "regexp";
        SemanticTokenTypes2["operator"] = "operator";
        SemanticTokenTypes2["decorator"] = "decorator";
      })(SemanticTokenTypes || (exports3.SemanticTokenTypes = SemanticTokenTypes = {}));
      var SemanticTokenModifiers;
      (function(SemanticTokenModifiers2) {
        SemanticTokenModifiers2["declaration"] = "declaration";
        SemanticTokenModifiers2["definition"] = "definition";
        SemanticTokenModifiers2["readonly"] = "readonly";
        SemanticTokenModifiers2["static"] = "static";
        SemanticTokenModifiers2["deprecated"] = "deprecated";
        SemanticTokenModifiers2["abstract"] = "abstract";
        SemanticTokenModifiers2["async"] = "async";
        SemanticTokenModifiers2["modification"] = "modification";
        SemanticTokenModifiers2["documentation"] = "documentation";
        SemanticTokenModifiers2["defaultLibrary"] = "defaultLibrary";
      })(SemanticTokenModifiers || (exports3.SemanticTokenModifiers = SemanticTokenModifiers = {}));
      var SemanticTokens;
      (function(SemanticTokens2) {
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && (candidate.resultId === void 0 || typeof candidate.resultId === "string") && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === "number");
        }
        SemanticTokens2.is = is;
      })(SemanticTokens || (exports3.SemanticTokens = SemanticTokens = {}));
      var InlineValueText;
      (function(InlineValueText2) {
        function create(range, text) {
          return { range, text };
        }
        InlineValueText2.create = create;
        function is(value) {
          var candidate = value;
          return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);
        }
        InlineValueText2.is = is;
      })(InlineValueText || (exports3.InlineValueText = InlineValueText = {}));
      var InlineValueVariableLookup;
      (function(InlineValueVariableLookup2) {
        function create(range, variableName, caseSensitiveLookup) {
          return { range, variableName, caseSensitiveLookup };
        }
        InlineValueVariableLookup2.create = create;
        function is(value) {
          var candidate = value;
          return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup) && (Is.string(candidate.variableName) || candidate.variableName === void 0);
        }
        InlineValueVariableLookup2.is = is;
      })(InlineValueVariableLookup || (exports3.InlineValueVariableLookup = InlineValueVariableLookup = {}));
      var InlineValueEvaluatableExpression;
      (function(InlineValueEvaluatableExpression2) {
        function create(range, expression) {
          return { range, expression };
        }
        InlineValueEvaluatableExpression2.create = create;
        function is(value) {
          var candidate = value;
          return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && (Is.string(candidate.expression) || candidate.expression === void 0);
        }
        InlineValueEvaluatableExpression2.is = is;
      })(InlineValueEvaluatableExpression || (exports3.InlineValueEvaluatableExpression = InlineValueEvaluatableExpression = {}));
      var InlineValueContext;
      (function(InlineValueContext2) {
        function create(frameId, stoppedLocation) {
          return { frameId, stoppedLocation };
        }
        InlineValueContext2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Range.is(value.stoppedLocation);
        }
        InlineValueContext2.is = is;
      })(InlineValueContext || (exports3.InlineValueContext = InlineValueContext = {}));
      var InlayHintKind;
      (function(InlayHintKind2) {
        InlayHintKind2.Type = 1;
        InlayHintKind2.Parameter = 2;
        function is(value) {
          return value === 1 || value === 2;
        }
        InlayHintKind2.is = is;
      })(InlayHintKind || (exports3.InlayHintKind = InlayHintKind = {}));
      var InlayHintLabelPart;
      (function(InlayHintLabelPart2) {
        function create(value) {
          return { value };
        }
        InlayHintLabelPart2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.location === void 0 || Location.is(candidate.location)) && (candidate.command === void 0 || Command.is(candidate.command));
        }
        InlayHintLabelPart2.is = is;
      })(InlayHintLabelPart || (exports3.InlayHintLabelPart = InlayHintLabelPart = {}));
      var InlayHint;
      (function(InlayHint2) {
        function create(position, label, kind) {
          var result = { position, label };
          if (kind !== void 0) {
            result.kind = kind;
          }
          return result;
        }
        InlayHint2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Position.is(candidate.position) && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is)) && (candidate.kind === void 0 || InlayHintKind.is(candidate.kind)) && candidate.textEdits === void 0 || Is.typedArray(candidate.textEdits, TextEdit.is) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.paddingLeft === void 0 || Is.boolean(candidate.paddingLeft)) && (candidate.paddingRight === void 0 || Is.boolean(candidate.paddingRight));
        }
        InlayHint2.is = is;
      })(InlayHint || (exports3.InlayHint = InlayHint = {}));
      var StringValue;
      (function(StringValue2) {
        function createSnippet(value) {
          return { kind: "snippet", value };
        }
        StringValue2.createSnippet = createSnippet;
      })(StringValue || (exports3.StringValue = StringValue = {}));
      var InlineCompletionItem;
      (function(InlineCompletionItem2) {
        function create(insertText, filterText, range, command) {
          return { insertText, filterText, range, command };
        }
        InlineCompletionItem2.create = create;
      })(InlineCompletionItem || (exports3.InlineCompletionItem = InlineCompletionItem = {}));
      var InlineCompletionList;
      (function(InlineCompletionList2) {
        function create(items) {
          return { items };
        }
        InlineCompletionList2.create = create;
      })(InlineCompletionList || (exports3.InlineCompletionList = InlineCompletionList = {}));
      var InlineCompletionTriggerKind;
      (function(InlineCompletionTriggerKind2) {
        InlineCompletionTriggerKind2.Invoked = 0;
        InlineCompletionTriggerKind2.Automatic = 1;
      })(InlineCompletionTriggerKind || (exports3.InlineCompletionTriggerKind = InlineCompletionTriggerKind = {}));
      var SelectedCompletionInfo;
      (function(SelectedCompletionInfo2) {
        function create(range, text) {
          return { range, text };
        }
        SelectedCompletionInfo2.create = create;
      })(SelectedCompletionInfo || (exports3.SelectedCompletionInfo = SelectedCompletionInfo = {}));
      var InlineCompletionContext;
      (function(InlineCompletionContext2) {
        function create(triggerKind, selectedCompletionInfo) {
          return { triggerKind, selectedCompletionInfo };
        }
        InlineCompletionContext2.create = create;
      })(InlineCompletionContext || (exports3.InlineCompletionContext = InlineCompletionContext = {}));
      var WorkspaceFolder;
      (function(WorkspaceFolder2) {
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && URI.is(candidate.uri) && Is.string(candidate.name);
        }
        WorkspaceFolder2.is = is;
      })(WorkspaceFolder || (exports3.WorkspaceFolder = WorkspaceFolder = {}));
      exports3.EOL = ["\n", "\r\n", "\r"];
      var TextDocument2;
      (function(TextDocument3) {
        function create(uri, languageId, version, content) {
          return new FullTextDocument2(uri, languageId, version, content);
        }
        TextDocument3.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
        }
        TextDocument3.is = is;
        function applyEdits(document, edits) {
          var text = document.getText();
          var sortedEdits = mergeSort2(edits, function(a, b) {
            var diff = a.range.start.line - b.range.start.line;
            if (diff === 0) {
              return a.range.start.character - b.range.start.character;
            }
            return diff;
          });
          var lastModifiedOffset = text.length;
          for (var i = sortedEdits.length - 1; i >= 0; i--) {
            var e = sortedEdits[i];
            var startOffset = document.offsetAt(e.range.start);
            var endOffset = document.offsetAt(e.range.end);
            if (endOffset <= lastModifiedOffset) {
              text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
            } else {
              throw new Error("Overlapping edit");
            }
            lastModifiedOffset = startOffset;
          }
          return text;
        }
        TextDocument3.applyEdits = applyEdits;
        function mergeSort2(data, compare) {
          if (data.length <= 1) {
            return data;
          }
          var p = data.length / 2 | 0;
          var left = data.slice(0, p);
          var right = data.slice(p);
          mergeSort2(left, compare);
          mergeSort2(right, compare);
          var leftIdx = 0;
          var rightIdx = 0;
          var i = 0;
          while (leftIdx < left.length && rightIdx < right.length) {
            var ret = compare(left[leftIdx], right[rightIdx]);
            if (ret <= 0) {
              data[i++] = left[leftIdx++];
            } else {
              data[i++] = right[rightIdx++];
            }
          }
          while (leftIdx < left.length) {
            data[i++] = left[leftIdx++];
          }
          while (rightIdx < right.length) {
            data[i++] = right[rightIdx++];
          }
          return data;
        }
      })(TextDocument2 || (exports3.TextDocument = TextDocument2 = {}));
      var FullTextDocument2 = (
        /** @class */
        function() {
          function FullTextDocument3(uri, languageId, version, content) {
            this._uri = uri;
            this._languageId = languageId;
            this._version = version;
            this._content = content;
            this._lineOffsets = void 0;
          }
          Object.defineProperty(FullTextDocument3.prototype, "uri", {
            get: function() {
              return this._uri;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(FullTextDocument3.prototype, "languageId", {
            get: function() {
              return this._languageId;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(FullTextDocument3.prototype, "version", {
            get: function() {
              return this._version;
            },
            enumerable: false,
            configurable: true
          });
          FullTextDocument3.prototype.getText = function(range) {
            if (range) {
              var start = this.offsetAt(range.start);
              var end = this.offsetAt(range.end);
              return this._content.substring(start, end);
            }
            return this._content;
          };
          FullTextDocument3.prototype.update = function(event, version) {
            this._content = event.text;
            this._version = version;
            this._lineOffsets = void 0;
          };
          FullTextDocument3.prototype.getLineOffsets = function() {
            if (this._lineOffsets === void 0) {
              var lineOffsets = [];
              var text = this._content;
              var isLineStart = true;
              for (var i = 0; i < text.length; i++) {
                if (isLineStart) {
                  lineOffsets.push(i);
                  isLineStart = false;
                }
                var ch = text.charAt(i);
                isLineStart = ch === "\r" || ch === "\n";
                if (ch === "\r" && i + 1 < text.length && text.charAt(i + 1) === "\n") {
                  i++;
                }
              }
              if (isLineStart && text.length > 0) {
                lineOffsets.push(text.length);
              }
              this._lineOffsets = lineOffsets;
            }
            return this._lineOffsets;
          };
          FullTextDocument3.prototype.positionAt = function(offset) {
            offset = Math.max(Math.min(offset, this._content.length), 0);
            var lineOffsets = this.getLineOffsets();
            var low = 0, high = lineOffsets.length;
            if (high === 0) {
              return Position.create(0, offset);
            }
            while (low < high) {
              var mid = Math.floor((low + high) / 2);
              if (lineOffsets[mid] > offset) {
                high = mid;
              } else {
                low = mid + 1;
              }
            }
            var line = low - 1;
            return Position.create(line, offset - lineOffsets[line]);
          };
          FullTextDocument3.prototype.offsetAt = function(position) {
            var lineOffsets = this.getLineOffsets();
            if (position.line >= lineOffsets.length) {
              return this._content.length;
            } else if (position.line < 0) {
              return 0;
            }
            var lineOffset = lineOffsets[position.line];
            var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
            return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
          };
          Object.defineProperty(FullTextDocument3.prototype, "lineCount", {
            get: function() {
              return this.getLineOffsets().length;
            },
            enumerable: false,
            configurable: true
          });
          return FullTextDocument3;
        }()
      );
      var Is;
      (function(Is2) {
        var toString = Object.prototype.toString;
        function defined(value) {
          return typeof value !== "undefined";
        }
        Is2.defined = defined;
        function undefined2(value) {
          return typeof value === "undefined";
        }
        Is2.undefined = undefined2;
        function boolean(value) {
          return value === true || value === false;
        }
        Is2.boolean = boolean;
        function string(value) {
          return toString.call(value) === "[object String]";
        }
        Is2.string = string;
        function number(value) {
          return toString.call(value) === "[object Number]";
        }
        Is2.number = number;
        function numberRange(value, min, max) {
          return toString.call(value) === "[object Number]" && min <= value && value <= max;
        }
        Is2.numberRange = numberRange;
        function integer2(value) {
          return toString.call(value) === "[object Number]" && -2147483648 <= value && value <= 2147483647;
        }
        Is2.integer = integer2;
        function uinteger2(value) {
          return toString.call(value) === "[object Number]" && 0 <= value && value <= 2147483647;
        }
        Is2.uinteger = uinteger2;
        function func(value) {
          return toString.call(value) === "[object Function]";
        }
        Is2.func = func;
        function objectLiteral(value) {
          return value !== null && typeof value === "object";
        }
        Is2.objectLiteral = objectLiteral;
        function typedArray(value, check) {
          return Array.isArray(value) && value.every(check);
        }
        Is2.typedArray = typedArray;
      })(Is || (Is = {}));
    });
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/messages.js
var require_messages2 = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/messages.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProtocolNotificationType = exports2.ProtocolNotificationType0 = exports2.ProtocolRequestType = exports2.ProtocolRequestType0 = exports2.RegistrationType = exports2.MessageDirection = void 0;
    var vscode_jsonrpc_1 = require_main();
    var MessageDirection;
    (function(MessageDirection2) {
      MessageDirection2["clientToServer"] = "clientToServer";
      MessageDirection2["serverToClient"] = "serverToClient";
      MessageDirection2["both"] = "both";
    })(MessageDirection || (exports2.MessageDirection = MessageDirection = {}));
    var RegistrationType = class {
      constructor(method) {
        this.method = method;
      }
    };
    exports2.RegistrationType = RegistrationType;
    var ProtocolRequestType0 = class extends vscode_jsonrpc_1.RequestType0 {
      constructor(method) {
        super(method);
      }
    };
    exports2.ProtocolRequestType0 = ProtocolRequestType0;
    var ProtocolRequestType = class extends vscode_jsonrpc_1.RequestType {
      constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
      }
    };
    exports2.ProtocolRequestType = ProtocolRequestType;
    var ProtocolNotificationType0 = class extends vscode_jsonrpc_1.NotificationType0 {
      constructor(method) {
        super(method);
      }
    };
    exports2.ProtocolNotificationType0 = ProtocolNotificationType0;
    var ProtocolNotificationType = class extends vscode_jsonrpc_1.NotificationType {
      constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
      }
    };
    exports2.ProtocolNotificationType = ProtocolNotificationType;
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/utils/is.js
var require_is3 = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/utils/is.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.objectLiteral = exports2.typedArray = exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
    function boolean(value) {
      return value === true || value === false;
    }
    exports2.boolean = boolean;
    function string(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports2.string = string;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports2.number = number;
    function error(value) {
      return value instanceof Error;
    }
    exports2.error = error;
    function func(value) {
      return typeof value === "function";
    }
    exports2.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports2.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    exports2.stringArray = stringArray;
    function typedArray(value, check) {
      return Array.isArray(value) && value.every(check);
    }
    exports2.typedArray = typedArray;
    function objectLiteral(value) {
      return value !== null && typeof value === "object";
    }
    exports2.objectLiteral = objectLiteral;
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js
var require_protocol_implementation = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ImplementationRequest = void 0;
    var messages_1 = require_messages2();
    var ImplementationRequest;
    (function(ImplementationRequest2) {
      ImplementationRequest2.method = "textDocument/implementation";
      ImplementationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ImplementationRequest2.type = new messages_1.ProtocolRequestType(ImplementationRequest2.method);
    })(ImplementationRequest || (exports2.ImplementationRequest = ImplementationRequest = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js
var require_protocol_typeDefinition = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeDefinitionRequest = void 0;
    var messages_1 = require_messages2();
    var TypeDefinitionRequest;
    (function(TypeDefinitionRequest2) {
      TypeDefinitionRequest2.method = "textDocument/typeDefinition";
      TypeDefinitionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeDefinitionRequest2.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest2.method);
    })(TypeDefinitionRequest || (exports2.TypeDefinitionRequest = TypeDefinitionRequest = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js
var require_protocol_workspaceFolder = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DidChangeWorkspaceFoldersNotification = exports2.WorkspaceFoldersRequest = void 0;
    var messages_1 = require_messages2();
    var WorkspaceFoldersRequest;
    (function(WorkspaceFoldersRequest2) {
      WorkspaceFoldersRequest2.method = "workspace/workspaceFolders";
      WorkspaceFoldersRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      WorkspaceFoldersRequest2.type = new messages_1.ProtocolRequestType0(WorkspaceFoldersRequest2.method);
    })(WorkspaceFoldersRequest || (exports2.WorkspaceFoldersRequest = WorkspaceFoldersRequest = {}));
    var DidChangeWorkspaceFoldersNotification;
    (function(DidChangeWorkspaceFoldersNotification2) {
      DidChangeWorkspaceFoldersNotification2.method = "workspace/didChangeWorkspaceFolders";
      DidChangeWorkspaceFoldersNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeWorkspaceFoldersNotification2.type = new messages_1.ProtocolNotificationType(DidChangeWorkspaceFoldersNotification2.method);
    })(DidChangeWorkspaceFoldersNotification || (exports2.DidChangeWorkspaceFoldersNotification = DidChangeWorkspaceFoldersNotification = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js
var require_protocol_configuration = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConfigurationRequest = void 0;
    var messages_1 = require_messages2();
    var ConfigurationRequest;
    (function(ConfigurationRequest2) {
      ConfigurationRequest2.method = "workspace/configuration";
      ConfigurationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      ConfigurationRequest2.type = new messages_1.ProtocolRequestType(ConfigurationRequest2.method);
    })(ConfigurationRequest || (exports2.ConfigurationRequest = ConfigurationRequest = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js
var require_protocol_colorProvider = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ColorPresentationRequest = exports2.DocumentColorRequest = void 0;
    var messages_1 = require_messages2();
    var DocumentColorRequest;
    (function(DocumentColorRequest2) {
      DocumentColorRequest2.method = "textDocument/documentColor";
      DocumentColorRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentColorRequest2.type = new messages_1.ProtocolRequestType(DocumentColorRequest2.method);
    })(DocumentColorRequest || (exports2.DocumentColorRequest = DocumentColorRequest = {}));
    var ColorPresentationRequest;
    (function(ColorPresentationRequest2) {
      ColorPresentationRequest2.method = "textDocument/colorPresentation";
      ColorPresentationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ColorPresentationRequest2.type = new messages_1.ProtocolRequestType(ColorPresentationRequest2.method);
    })(ColorPresentationRequest || (exports2.ColorPresentationRequest = ColorPresentationRequest = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js
var require_protocol_foldingRange = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FoldingRangeRefreshRequest = exports2.FoldingRangeRequest = void 0;
    var messages_1 = require_messages2();
    var FoldingRangeRequest;
    (function(FoldingRangeRequest2) {
      FoldingRangeRequest2.method = "textDocument/foldingRange";
      FoldingRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      FoldingRangeRequest2.type = new messages_1.ProtocolRequestType(FoldingRangeRequest2.method);
    })(FoldingRangeRequest || (exports2.FoldingRangeRequest = FoldingRangeRequest = {}));
    var FoldingRangeRefreshRequest;
    (function(FoldingRangeRefreshRequest2) {
      FoldingRangeRefreshRequest2.method = `workspace/foldingRange/refresh`;
      FoldingRangeRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      FoldingRangeRefreshRequest2.type = new messages_1.ProtocolRequestType0(FoldingRangeRefreshRequest2.method);
    })(FoldingRangeRefreshRequest || (exports2.FoldingRangeRefreshRequest = FoldingRangeRefreshRequest = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js
var require_protocol_declaration = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DeclarationRequest = void 0;
    var messages_1 = require_messages2();
    var DeclarationRequest;
    (function(DeclarationRequest2) {
      DeclarationRequest2.method = "textDocument/declaration";
      DeclarationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DeclarationRequest2.type = new messages_1.ProtocolRequestType(DeclarationRequest2.method);
    })(DeclarationRequest || (exports2.DeclarationRequest = DeclarationRequest = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js
var require_protocol_selectionRange = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SelectionRangeRequest = void 0;
    var messages_1 = require_messages2();
    var SelectionRangeRequest;
    (function(SelectionRangeRequest2) {
      SelectionRangeRequest2.method = "textDocument/selectionRange";
      SelectionRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SelectionRangeRequest2.type = new messages_1.ProtocolRequestType(SelectionRangeRequest2.method);
    })(SelectionRangeRequest || (exports2.SelectionRangeRequest = SelectionRangeRequest = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js
var require_protocol_progress = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkDoneProgressCancelNotification = exports2.WorkDoneProgressCreateRequest = exports2.WorkDoneProgress = void 0;
    var vscode_jsonrpc_1 = require_main();
    var messages_1 = require_messages2();
    var WorkDoneProgress;
    (function(WorkDoneProgress2) {
      WorkDoneProgress2.type = new vscode_jsonrpc_1.ProgressType();
      function is(value) {
        return value === WorkDoneProgress2.type;
      }
      WorkDoneProgress2.is = is;
    })(WorkDoneProgress || (exports2.WorkDoneProgress = WorkDoneProgress = {}));
    var WorkDoneProgressCreateRequest;
    (function(WorkDoneProgressCreateRequest2) {
      WorkDoneProgressCreateRequest2.method = "window/workDoneProgress/create";
      WorkDoneProgressCreateRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      WorkDoneProgressCreateRequest2.type = new messages_1.ProtocolRequestType(WorkDoneProgressCreateRequest2.method);
    })(WorkDoneProgressCreateRequest || (exports2.WorkDoneProgressCreateRequest = WorkDoneProgressCreateRequest = {}));
    var WorkDoneProgressCancelNotification;
    (function(WorkDoneProgressCancelNotification2) {
      WorkDoneProgressCancelNotification2.method = "window/workDoneProgress/cancel";
      WorkDoneProgressCancelNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkDoneProgressCancelNotification2.type = new messages_1.ProtocolNotificationType(WorkDoneProgressCancelNotification2.method);
    })(WorkDoneProgressCancelNotification || (exports2.WorkDoneProgressCancelNotification = WorkDoneProgressCancelNotification = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js
var require_protocol_callHierarchy = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CallHierarchyOutgoingCallsRequest = exports2.CallHierarchyIncomingCallsRequest = exports2.CallHierarchyPrepareRequest = void 0;
    var messages_1 = require_messages2();
    var CallHierarchyPrepareRequest;
    (function(CallHierarchyPrepareRequest2) {
      CallHierarchyPrepareRequest2.method = "textDocument/prepareCallHierarchy";
      CallHierarchyPrepareRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CallHierarchyPrepareRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest2.method);
    })(CallHierarchyPrepareRequest || (exports2.CallHierarchyPrepareRequest = CallHierarchyPrepareRequest = {}));
    var CallHierarchyIncomingCallsRequest;
    (function(CallHierarchyIncomingCallsRequest2) {
      CallHierarchyIncomingCallsRequest2.method = "callHierarchy/incomingCalls";
      CallHierarchyIncomingCallsRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CallHierarchyIncomingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest2.method);
    })(CallHierarchyIncomingCallsRequest || (exports2.CallHierarchyIncomingCallsRequest = CallHierarchyIncomingCallsRequest = {}));
    var CallHierarchyOutgoingCallsRequest;
    (function(CallHierarchyOutgoingCallsRequest2) {
      CallHierarchyOutgoingCallsRequest2.method = "callHierarchy/outgoingCalls";
      CallHierarchyOutgoingCallsRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CallHierarchyOutgoingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest2.method);
    })(CallHierarchyOutgoingCallsRequest || (exports2.CallHierarchyOutgoingCallsRequest = CallHierarchyOutgoingCallsRequest = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js
var require_protocol_semanticTokens = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SemanticTokensRefreshRequest = exports2.SemanticTokensRangeRequest = exports2.SemanticTokensDeltaRequest = exports2.SemanticTokensRequest = exports2.SemanticTokensRegistrationType = exports2.TokenFormat = void 0;
    var messages_1 = require_messages2();
    var TokenFormat;
    (function(TokenFormat2) {
      TokenFormat2.Relative = "relative";
    })(TokenFormat || (exports2.TokenFormat = TokenFormat = {}));
    var SemanticTokensRegistrationType;
    (function(SemanticTokensRegistrationType2) {
      SemanticTokensRegistrationType2.method = "textDocument/semanticTokens";
      SemanticTokensRegistrationType2.type = new messages_1.RegistrationType(SemanticTokensRegistrationType2.method);
    })(SemanticTokensRegistrationType || (exports2.SemanticTokensRegistrationType = SemanticTokensRegistrationType = {}));
    var SemanticTokensRequest;
    (function(SemanticTokensRequest2) {
      SemanticTokensRequest2.method = "textDocument/semanticTokens/full";
      SemanticTokensRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRequest2.method);
      SemanticTokensRequest2.registrationMethod = SemanticTokensRegistrationType.method;
    })(SemanticTokensRequest || (exports2.SemanticTokensRequest = SemanticTokensRequest = {}));
    var SemanticTokensDeltaRequest;
    (function(SemanticTokensDeltaRequest2) {
      SemanticTokensDeltaRequest2.method = "textDocument/semanticTokens/full/delta";
      SemanticTokensDeltaRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensDeltaRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest2.method);
      SemanticTokensDeltaRequest2.registrationMethod = SemanticTokensRegistrationType.method;
    })(SemanticTokensDeltaRequest || (exports2.SemanticTokensDeltaRequest = SemanticTokensDeltaRequest = {}));
    var SemanticTokensRangeRequest;
    (function(SemanticTokensRangeRequest2) {
      SemanticTokensRangeRequest2.method = "textDocument/semanticTokens/range";
      SemanticTokensRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensRangeRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest2.method);
      SemanticTokensRangeRequest2.registrationMethod = SemanticTokensRegistrationType.method;
    })(SemanticTokensRangeRequest || (exports2.SemanticTokensRangeRequest = SemanticTokensRangeRequest = {}));
    var SemanticTokensRefreshRequest;
    (function(SemanticTokensRefreshRequest2) {
      SemanticTokensRefreshRequest2.method = `workspace/semanticTokens/refresh`;
      SemanticTokensRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      SemanticTokensRefreshRequest2.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest2.method);
    })(SemanticTokensRefreshRequest || (exports2.SemanticTokensRefreshRequest = SemanticTokensRefreshRequest = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js
var require_protocol_showDocument = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ShowDocumentRequest = void 0;
    var messages_1 = require_messages2();
    var ShowDocumentRequest;
    (function(ShowDocumentRequest2) {
      ShowDocumentRequest2.method = "window/showDocument";
      ShowDocumentRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      ShowDocumentRequest2.type = new messages_1.ProtocolRequestType(ShowDocumentRequest2.method);
    })(ShowDocumentRequest || (exports2.ShowDocumentRequest = ShowDocumentRequest = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js
var require_protocol_linkedEditingRange = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LinkedEditingRangeRequest = void 0;
    var messages_1 = require_messages2();
    var LinkedEditingRangeRequest;
    (function(LinkedEditingRangeRequest2) {
      LinkedEditingRangeRequest2.method = "textDocument/linkedEditingRange";
      LinkedEditingRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      LinkedEditingRangeRequest2.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest2.method);
    })(LinkedEditingRangeRequest || (exports2.LinkedEditingRangeRequest = LinkedEditingRangeRequest = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js
var require_protocol_fileOperations = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WillDeleteFilesRequest = exports2.DidDeleteFilesNotification = exports2.DidRenameFilesNotification = exports2.WillRenameFilesRequest = exports2.DidCreateFilesNotification = exports2.WillCreateFilesRequest = exports2.FileOperationPatternKind = void 0;
    var messages_1 = require_messages2();
    var FileOperationPatternKind;
    (function(FileOperationPatternKind2) {
      FileOperationPatternKind2.file = "file";
      FileOperationPatternKind2.folder = "folder";
    })(FileOperationPatternKind || (exports2.FileOperationPatternKind = FileOperationPatternKind = {}));
    var WillCreateFilesRequest;
    (function(WillCreateFilesRequest2) {
      WillCreateFilesRequest2.method = "workspace/willCreateFiles";
      WillCreateFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillCreateFilesRequest2.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest2.method);
    })(WillCreateFilesRequest || (exports2.WillCreateFilesRequest = WillCreateFilesRequest = {}));
    var DidCreateFilesNotification;
    (function(DidCreateFilesNotification2) {
      DidCreateFilesNotification2.method = "workspace/didCreateFiles";
      DidCreateFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidCreateFilesNotification2.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification2.method);
    })(DidCreateFilesNotification || (exports2.DidCreateFilesNotification = DidCreateFilesNotification = {}));
    var WillRenameFilesRequest;
    (function(WillRenameFilesRequest2) {
      WillRenameFilesRequest2.method = "workspace/willRenameFiles";
      WillRenameFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillRenameFilesRequest2.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest2.method);
    })(WillRenameFilesRequest || (exports2.WillRenameFilesRequest = WillRenameFilesRequest = {}));
    var DidRenameFilesNotification;
    (function(DidRenameFilesNotification2) {
      DidRenameFilesNotification2.method = "workspace/didRenameFiles";
      DidRenameFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidRenameFilesNotification2.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification2.method);
    })(DidRenameFilesNotification || (exports2.DidRenameFilesNotification = DidRenameFilesNotification = {}));
    var DidDeleteFilesNotification;
    (function(DidDeleteFilesNotification2) {
      DidDeleteFilesNotification2.method = "workspace/didDeleteFiles";
      DidDeleteFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidDeleteFilesNotification2.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification2.method);
    })(DidDeleteFilesNotification || (exports2.DidDeleteFilesNotification = DidDeleteFilesNotification = {}));
    var WillDeleteFilesRequest;
    (function(WillDeleteFilesRequest2) {
      WillDeleteFilesRequest2.method = "workspace/willDeleteFiles";
      WillDeleteFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillDeleteFilesRequest2.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest2.method);
    })(WillDeleteFilesRequest || (exports2.WillDeleteFilesRequest = WillDeleteFilesRequest = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js
var require_protocol_moniker = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MonikerRequest = exports2.MonikerKind = exports2.UniquenessLevel = void 0;
    var messages_1 = require_messages2();
    var UniquenessLevel;
    (function(UniquenessLevel2) {
      UniquenessLevel2.document = "document";
      UniquenessLevel2.project = "project";
      UniquenessLevel2.group = "group";
      UniquenessLevel2.scheme = "scheme";
      UniquenessLevel2.global = "global";
    })(UniquenessLevel || (exports2.UniquenessLevel = UniquenessLevel = {}));
    var MonikerKind;
    (function(MonikerKind2) {
      MonikerKind2.$import = "import";
      MonikerKind2.$export = "export";
      MonikerKind2.local = "local";
    })(MonikerKind || (exports2.MonikerKind = MonikerKind = {}));
    var MonikerRequest;
    (function(MonikerRequest2) {
      MonikerRequest2.method = "textDocument/moniker";
      MonikerRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      MonikerRequest2.type = new messages_1.ProtocolRequestType(MonikerRequest2.method);
    })(MonikerRequest || (exports2.MonikerRequest = MonikerRequest = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js
var require_protocol_typeHierarchy = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeHierarchySubtypesRequest = exports2.TypeHierarchySupertypesRequest = exports2.TypeHierarchyPrepareRequest = void 0;
    var messages_1 = require_messages2();
    var TypeHierarchyPrepareRequest;
    (function(TypeHierarchyPrepareRequest2) {
      TypeHierarchyPrepareRequest2.method = "textDocument/prepareTypeHierarchy";
      TypeHierarchyPrepareRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeHierarchyPrepareRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchyPrepareRequest2.method);
    })(TypeHierarchyPrepareRequest || (exports2.TypeHierarchyPrepareRequest = TypeHierarchyPrepareRequest = {}));
    var TypeHierarchySupertypesRequest;
    (function(TypeHierarchySupertypesRequest2) {
      TypeHierarchySupertypesRequest2.method = "typeHierarchy/supertypes";
      TypeHierarchySupertypesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeHierarchySupertypesRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchySupertypesRequest2.method);
    })(TypeHierarchySupertypesRequest || (exports2.TypeHierarchySupertypesRequest = TypeHierarchySupertypesRequest = {}));
    var TypeHierarchySubtypesRequest;
    (function(TypeHierarchySubtypesRequest2) {
      TypeHierarchySubtypesRequest2.method = "typeHierarchy/subtypes";
      TypeHierarchySubtypesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeHierarchySubtypesRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchySubtypesRequest2.method);
    })(TypeHierarchySubtypesRequest || (exports2.TypeHierarchySubtypesRequest = TypeHierarchySubtypesRequest = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js
var require_protocol_inlineValue = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlineValueRefreshRequest = exports2.InlineValueRequest = void 0;
    var messages_1 = require_messages2();
    var InlineValueRequest;
    (function(InlineValueRequest2) {
      InlineValueRequest2.method = "textDocument/inlineValue";
      InlineValueRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlineValueRequest2.type = new messages_1.ProtocolRequestType(InlineValueRequest2.method);
    })(InlineValueRequest || (exports2.InlineValueRequest = InlineValueRequest = {}));
    var InlineValueRefreshRequest;
    (function(InlineValueRefreshRequest2) {
      InlineValueRefreshRequest2.method = `workspace/inlineValue/refresh`;
      InlineValueRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      InlineValueRefreshRequest2.type = new messages_1.ProtocolRequestType0(InlineValueRefreshRequest2.method);
    })(InlineValueRefreshRequest || (exports2.InlineValueRefreshRequest = InlineValueRefreshRequest = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js
var require_protocol_inlayHint = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlayHintRefreshRequest = exports2.InlayHintResolveRequest = exports2.InlayHintRequest = void 0;
    var messages_1 = require_messages2();
    var InlayHintRequest;
    (function(InlayHintRequest2) {
      InlayHintRequest2.method = "textDocument/inlayHint";
      InlayHintRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlayHintRequest2.type = new messages_1.ProtocolRequestType(InlayHintRequest2.method);
    })(InlayHintRequest || (exports2.InlayHintRequest = InlayHintRequest = {}));
    var InlayHintResolveRequest;
    (function(InlayHintResolveRequest2) {
      InlayHintResolveRequest2.method = "inlayHint/resolve";
      InlayHintResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlayHintResolveRequest2.type = new messages_1.ProtocolRequestType(InlayHintResolveRequest2.method);
    })(InlayHintResolveRequest || (exports2.InlayHintResolveRequest = InlayHintResolveRequest = {}));
    var InlayHintRefreshRequest;
    (function(InlayHintRefreshRequest2) {
      InlayHintRefreshRequest2.method = `workspace/inlayHint/refresh`;
      InlayHintRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      InlayHintRefreshRequest2.type = new messages_1.ProtocolRequestType0(InlayHintRefreshRequest2.method);
    })(InlayHintRefreshRequest || (exports2.InlayHintRefreshRequest = InlayHintRefreshRequest = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js
var require_protocol_diagnostic = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DiagnosticRefreshRequest = exports2.WorkspaceDiagnosticRequest = exports2.DocumentDiagnosticRequest = exports2.DocumentDiagnosticReportKind = exports2.DiagnosticServerCancellationData = void 0;
    var vscode_jsonrpc_1 = require_main();
    var Is = require_is3();
    var messages_1 = require_messages2();
    var DiagnosticServerCancellationData;
    (function(DiagnosticServerCancellationData2) {
      function is(value) {
        const candidate = value;
        return candidate && Is.boolean(candidate.retriggerRequest);
      }
      DiagnosticServerCancellationData2.is = is;
    })(DiagnosticServerCancellationData || (exports2.DiagnosticServerCancellationData = DiagnosticServerCancellationData = {}));
    var DocumentDiagnosticReportKind;
    (function(DocumentDiagnosticReportKind2) {
      DocumentDiagnosticReportKind2.Full = "full";
      DocumentDiagnosticReportKind2.Unchanged = "unchanged";
    })(DocumentDiagnosticReportKind || (exports2.DocumentDiagnosticReportKind = DocumentDiagnosticReportKind = {}));
    var DocumentDiagnosticRequest;
    (function(DocumentDiagnosticRequest2) {
      DocumentDiagnosticRequest2.method = "textDocument/diagnostic";
      DocumentDiagnosticRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentDiagnosticRequest2.type = new messages_1.ProtocolRequestType(DocumentDiagnosticRequest2.method);
      DocumentDiagnosticRequest2.partialResult = new vscode_jsonrpc_1.ProgressType();
    })(DocumentDiagnosticRequest || (exports2.DocumentDiagnosticRequest = DocumentDiagnosticRequest = {}));
    var WorkspaceDiagnosticRequest;
    (function(WorkspaceDiagnosticRequest2) {
      WorkspaceDiagnosticRequest2.method = "workspace/diagnostic";
      WorkspaceDiagnosticRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkspaceDiagnosticRequest2.type = new messages_1.ProtocolRequestType(WorkspaceDiagnosticRequest2.method);
      WorkspaceDiagnosticRequest2.partialResult = new vscode_jsonrpc_1.ProgressType();
    })(WorkspaceDiagnosticRequest || (exports2.WorkspaceDiagnosticRequest = WorkspaceDiagnosticRequest = {}));
    var DiagnosticRefreshRequest;
    (function(DiagnosticRefreshRequest2) {
      DiagnosticRefreshRequest2.method = `workspace/diagnostic/refresh`;
      DiagnosticRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      DiagnosticRefreshRequest2.type = new messages_1.ProtocolRequestType0(DiagnosticRefreshRequest2.method);
    })(DiagnosticRefreshRequest || (exports2.DiagnosticRefreshRequest = DiagnosticRefreshRequest = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js
var require_protocol_notebook = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DidCloseNotebookDocumentNotification = exports2.DidSaveNotebookDocumentNotification = exports2.DidChangeNotebookDocumentNotification = exports2.NotebookCellArrayChange = exports2.DidOpenNotebookDocumentNotification = exports2.NotebookDocumentSyncRegistrationType = exports2.NotebookDocument = exports2.NotebookCell = exports2.ExecutionSummary = exports2.NotebookCellKind = void 0;
    var vscode_languageserver_types_1 = require_main2();
    var Is = require_is3();
    var messages_1 = require_messages2();
    var NotebookCellKind;
    (function(NotebookCellKind2) {
      NotebookCellKind2.Markup = 1;
      NotebookCellKind2.Code = 2;
      function is(value) {
        return value === 1 || value === 2;
      }
      NotebookCellKind2.is = is;
    })(NotebookCellKind || (exports2.NotebookCellKind = NotebookCellKind = {}));
    var ExecutionSummary;
    (function(ExecutionSummary2) {
      function create(executionOrder, success) {
        const result = { executionOrder };
        if (success === true || success === false) {
          result.success = success;
        }
        return result;
      }
      ExecutionSummary2.create = create;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.executionOrder) && (candidate.success === void 0 || Is.boolean(candidate.success));
      }
      ExecutionSummary2.is = is;
      function equals(one, other) {
        if (one === other) {
          return true;
        }
        if (one === null || one === void 0 || other === null || other === void 0) {
          return false;
        }
        return one.executionOrder === other.executionOrder && one.success === other.success;
      }
      ExecutionSummary2.equals = equals;
    })(ExecutionSummary || (exports2.ExecutionSummary = ExecutionSummary = {}));
    var NotebookCell;
    (function(NotebookCell2) {
      function create(kind, document) {
        return { kind, document };
      }
      NotebookCell2.create = create;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && NotebookCellKind.is(candidate.kind) && vscode_languageserver_types_1.DocumentUri.is(candidate.document) && (candidate.metadata === void 0 || Is.objectLiteral(candidate.metadata));
      }
      NotebookCell2.is = is;
      function diff(one, two) {
        const result = /* @__PURE__ */ new Set();
        if (one.document !== two.document) {
          result.add("document");
        }
        if (one.kind !== two.kind) {
          result.add("kind");
        }
        if (one.executionSummary !== two.executionSummary) {
          result.add("executionSummary");
        }
        if ((one.metadata !== void 0 || two.metadata !== void 0) && !equalsMetadata(one.metadata, two.metadata)) {
          result.add("metadata");
        }
        if ((one.executionSummary !== void 0 || two.executionSummary !== void 0) && !ExecutionSummary.equals(one.executionSummary, two.executionSummary)) {
          result.add("executionSummary");
        }
        return result;
      }
      NotebookCell2.diff = diff;
      function equalsMetadata(one, other) {
        if (one === other) {
          return true;
        }
        if (one === null || one === void 0 || other === null || other === void 0) {
          return false;
        }
        if (typeof one !== typeof other) {
          return false;
        }
        if (typeof one !== "object") {
          return false;
        }
        const oneArray = Array.isArray(one);
        const otherArray = Array.isArray(other);
        if (oneArray !== otherArray) {
          return false;
        }
        if (oneArray && otherArray) {
          if (one.length !== other.length) {
            return false;
          }
          for (let i = 0; i < one.length; i++) {
            if (!equalsMetadata(one[i], other[i])) {
              return false;
            }
          }
        }
        if (Is.objectLiteral(one) && Is.objectLiteral(other)) {
          const oneKeys = Object.keys(one);
          const otherKeys = Object.keys(other);
          if (oneKeys.length !== otherKeys.length) {
            return false;
          }
          oneKeys.sort();
          otherKeys.sort();
          if (!equalsMetadata(oneKeys, otherKeys)) {
            return false;
          }
          for (let i = 0; i < oneKeys.length; i++) {
            const prop = oneKeys[i];
            if (!equalsMetadata(one[prop], other[prop])) {
              return false;
            }
          }
        }
        return true;
      }
    })(NotebookCell || (exports2.NotebookCell = NotebookCell = {}));
    var NotebookDocument;
    (function(NotebookDocument2) {
      function create(uri, notebookType, version, cells) {
        return { uri, notebookType, version, cells };
      }
      NotebookDocument2.create = create;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.uri) && vscode_languageserver_types_1.integer.is(candidate.version) && Is.typedArray(candidate.cells, NotebookCell.is);
      }
      NotebookDocument2.is = is;
    })(NotebookDocument || (exports2.NotebookDocument = NotebookDocument = {}));
    var NotebookDocumentSyncRegistrationType;
    (function(NotebookDocumentSyncRegistrationType2) {
      NotebookDocumentSyncRegistrationType2.method = "notebookDocument/sync";
      NotebookDocumentSyncRegistrationType2.messageDirection = messages_1.MessageDirection.clientToServer;
      NotebookDocumentSyncRegistrationType2.type = new messages_1.RegistrationType(NotebookDocumentSyncRegistrationType2.method);
    })(NotebookDocumentSyncRegistrationType || (exports2.NotebookDocumentSyncRegistrationType = NotebookDocumentSyncRegistrationType = {}));
    var DidOpenNotebookDocumentNotification;
    (function(DidOpenNotebookDocumentNotification2) {
      DidOpenNotebookDocumentNotification2.method = "notebookDocument/didOpen";
      DidOpenNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidOpenNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidOpenNotebookDocumentNotification2.method);
      DidOpenNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidOpenNotebookDocumentNotification || (exports2.DidOpenNotebookDocumentNotification = DidOpenNotebookDocumentNotification = {}));
    var NotebookCellArrayChange;
    (function(NotebookCellArrayChange2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.start) && vscode_languageserver_types_1.uinteger.is(candidate.deleteCount) && (candidate.cells === void 0 || Is.typedArray(candidate.cells, NotebookCell.is));
      }
      NotebookCellArrayChange2.is = is;
      function create(start, deleteCount, cells) {
        const result = { start, deleteCount };
        if (cells !== void 0) {
          result.cells = cells;
        }
        return result;
      }
      NotebookCellArrayChange2.create = create;
    })(NotebookCellArrayChange || (exports2.NotebookCellArrayChange = NotebookCellArrayChange = {}));
    var DidChangeNotebookDocumentNotification;
    (function(DidChangeNotebookDocumentNotification2) {
      DidChangeNotebookDocumentNotification2.method = "notebookDocument/didChange";
      DidChangeNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidChangeNotebookDocumentNotification2.method);
      DidChangeNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidChangeNotebookDocumentNotification || (exports2.DidChangeNotebookDocumentNotification = DidChangeNotebookDocumentNotification = {}));
    var DidSaveNotebookDocumentNotification;
    (function(DidSaveNotebookDocumentNotification2) {
      DidSaveNotebookDocumentNotification2.method = "notebookDocument/didSave";
      DidSaveNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidSaveNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidSaveNotebookDocumentNotification2.method);
      DidSaveNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidSaveNotebookDocumentNotification || (exports2.DidSaveNotebookDocumentNotification = DidSaveNotebookDocumentNotification = {}));
    var DidCloseNotebookDocumentNotification;
    (function(DidCloseNotebookDocumentNotification2) {
      DidCloseNotebookDocumentNotification2.method = "notebookDocument/didClose";
      DidCloseNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidCloseNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidCloseNotebookDocumentNotification2.method);
      DidCloseNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidCloseNotebookDocumentNotification || (exports2.DidCloseNotebookDocumentNotification = DidCloseNotebookDocumentNotification = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineCompletion.js
var require_protocol_inlineCompletion = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineCompletion.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlineCompletionRequest = void 0;
    var messages_1 = require_messages2();
    var InlineCompletionRequest;
    (function(InlineCompletionRequest2) {
      InlineCompletionRequest2.method = "textDocument/inlineCompletion";
      InlineCompletionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlineCompletionRequest2.type = new messages_1.ProtocolRequestType(InlineCompletionRequest2.method);
    })(InlineCompletionRequest || (exports2.InlineCompletionRequest = InlineCompletionRequest = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.js
var require_protocol = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkspaceSymbolRequest = exports2.CodeActionResolveRequest = exports2.CodeActionRequest = exports2.DocumentSymbolRequest = exports2.DocumentHighlightRequest = exports2.ReferencesRequest = exports2.DefinitionRequest = exports2.SignatureHelpRequest = exports2.SignatureHelpTriggerKind = exports2.HoverRequest = exports2.CompletionResolveRequest = exports2.CompletionRequest = exports2.CompletionTriggerKind = exports2.PublishDiagnosticsNotification = exports2.WatchKind = exports2.RelativePattern = exports2.FileChangeType = exports2.DidChangeWatchedFilesNotification = exports2.WillSaveTextDocumentWaitUntilRequest = exports2.WillSaveTextDocumentNotification = exports2.TextDocumentSaveReason = exports2.DidSaveTextDocumentNotification = exports2.DidCloseTextDocumentNotification = exports2.DidChangeTextDocumentNotification = exports2.TextDocumentContentChangeEvent = exports2.DidOpenTextDocumentNotification = exports2.TextDocumentSyncKind = exports2.TelemetryEventNotification = exports2.LogMessageNotification = exports2.ShowMessageRequest = exports2.ShowMessageNotification = exports2.MessageType = exports2.DidChangeConfigurationNotification = exports2.ExitNotification = exports2.ShutdownRequest = exports2.InitializedNotification = exports2.InitializeErrorCodes = exports2.InitializeRequest = exports2.WorkDoneProgressOptions = exports2.TextDocumentRegistrationOptions = exports2.StaticRegistrationOptions = exports2.PositionEncodingKind = exports2.FailureHandlingKind = exports2.ResourceOperationKind = exports2.UnregistrationRequest = exports2.RegistrationRequest = exports2.DocumentSelector = exports2.NotebookCellTextDocumentFilter = exports2.NotebookDocumentFilter = exports2.TextDocumentFilter = void 0;
    exports2.MonikerRequest = exports2.MonikerKind = exports2.UniquenessLevel = exports2.WillDeleteFilesRequest = exports2.DidDeleteFilesNotification = exports2.WillRenameFilesRequest = exports2.DidRenameFilesNotification = exports2.WillCreateFilesRequest = exports2.DidCreateFilesNotification = exports2.FileOperationPatternKind = exports2.LinkedEditingRangeRequest = exports2.ShowDocumentRequest = exports2.SemanticTokensRegistrationType = exports2.SemanticTokensRefreshRequest = exports2.SemanticTokensRangeRequest = exports2.SemanticTokensDeltaRequest = exports2.SemanticTokensRequest = exports2.TokenFormat = exports2.CallHierarchyPrepareRequest = exports2.CallHierarchyOutgoingCallsRequest = exports2.CallHierarchyIncomingCallsRequest = exports2.WorkDoneProgressCancelNotification = exports2.WorkDoneProgressCreateRequest = exports2.WorkDoneProgress = exports2.SelectionRangeRequest = exports2.DeclarationRequest = exports2.FoldingRangeRefreshRequest = exports2.FoldingRangeRequest = exports2.ColorPresentationRequest = exports2.DocumentColorRequest = exports2.ConfigurationRequest = exports2.DidChangeWorkspaceFoldersNotification = exports2.WorkspaceFoldersRequest = exports2.TypeDefinitionRequest = exports2.ImplementationRequest = exports2.ApplyWorkspaceEditRequest = exports2.ExecuteCommandRequest = exports2.PrepareRenameRequest = exports2.RenameRequest = exports2.PrepareSupportDefaultBehavior = exports2.DocumentOnTypeFormattingRequest = exports2.DocumentRangesFormattingRequest = exports2.DocumentRangeFormattingRequest = exports2.DocumentFormattingRequest = exports2.DocumentLinkResolveRequest = exports2.DocumentLinkRequest = exports2.CodeLensRefreshRequest = exports2.CodeLensResolveRequest = exports2.CodeLensRequest = exports2.WorkspaceSymbolResolveRequest = void 0;
    exports2.InlineCompletionRequest = exports2.DidCloseNotebookDocumentNotification = exports2.DidSaveNotebookDocumentNotification = exports2.DidChangeNotebookDocumentNotification = exports2.NotebookCellArrayChange = exports2.DidOpenNotebookDocumentNotification = exports2.NotebookDocumentSyncRegistrationType = exports2.NotebookDocument = exports2.NotebookCell = exports2.ExecutionSummary = exports2.NotebookCellKind = exports2.DiagnosticRefreshRequest = exports2.WorkspaceDiagnosticRequest = exports2.DocumentDiagnosticRequest = exports2.DocumentDiagnosticReportKind = exports2.DiagnosticServerCancellationData = exports2.InlayHintRefreshRequest = exports2.InlayHintResolveRequest = exports2.InlayHintRequest = exports2.InlineValueRefreshRequest = exports2.InlineValueRequest = exports2.TypeHierarchySupertypesRequest = exports2.TypeHierarchySubtypesRequest = exports2.TypeHierarchyPrepareRequest = void 0;
    var messages_1 = require_messages2();
    var vscode_languageserver_types_1 = require_main2();
    var Is = require_is3();
    var protocol_implementation_1 = require_protocol_implementation();
    Object.defineProperty(exports2, "ImplementationRequest", { enumerable: true, get: function() {
      return protocol_implementation_1.ImplementationRequest;
    } });
    var protocol_typeDefinition_1 = require_protocol_typeDefinition();
    Object.defineProperty(exports2, "TypeDefinitionRequest", { enumerable: true, get: function() {
      return protocol_typeDefinition_1.TypeDefinitionRequest;
    } });
    var protocol_workspaceFolder_1 = require_protocol_workspaceFolder();
    Object.defineProperty(exports2, "WorkspaceFoldersRequest", { enumerable: true, get: function() {
      return protocol_workspaceFolder_1.WorkspaceFoldersRequest;
    } });
    Object.defineProperty(exports2, "DidChangeWorkspaceFoldersNotification", { enumerable: true, get: function() {
      return protocol_workspaceFolder_1.DidChangeWorkspaceFoldersNotification;
    } });
    var protocol_configuration_1 = require_protocol_configuration();
    Object.defineProperty(exports2, "ConfigurationRequest", { enumerable: true, get: function() {
      return protocol_configuration_1.ConfigurationRequest;
    } });
    var protocol_colorProvider_1 = require_protocol_colorProvider();
    Object.defineProperty(exports2, "DocumentColorRequest", { enumerable: true, get: function() {
      return protocol_colorProvider_1.DocumentColorRequest;
    } });
    Object.defineProperty(exports2, "ColorPresentationRequest", { enumerable: true, get: function() {
      return protocol_colorProvider_1.ColorPresentationRequest;
    } });
    var protocol_foldingRange_1 = require_protocol_foldingRange();
    Object.defineProperty(exports2, "FoldingRangeRequest", { enumerable: true, get: function() {
      return protocol_foldingRange_1.FoldingRangeRequest;
    } });
    Object.defineProperty(exports2, "FoldingRangeRefreshRequest", { enumerable: true, get: function() {
      return protocol_foldingRange_1.FoldingRangeRefreshRequest;
    } });
    var protocol_declaration_1 = require_protocol_declaration();
    Object.defineProperty(exports2, "DeclarationRequest", { enumerable: true, get: function() {
      return protocol_declaration_1.DeclarationRequest;
    } });
    var protocol_selectionRange_1 = require_protocol_selectionRange();
    Object.defineProperty(exports2, "SelectionRangeRequest", { enumerable: true, get: function() {
      return protocol_selectionRange_1.SelectionRangeRequest;
    } });
    var protocol_progress_1 = require_protocol_progress();
    Object.defineProperty(exports2, "WorkDoneProgress", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgress;
    } });
    Object.defineProperty(exports2, "WorkDoneProgressCreateRequest", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgressCreateRequest;
    } });
    Object.defineProperty(exports2, "WorkDoneProgressCancelNotification", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgressCancelNotification;
    } });
    var protocol_callHierarchy_1 = require_protocol_callHierarchy();
    Object.defineProperty(exports2, "CallHierarchyIncomingCallsRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest;
    } });
    Object.defineProperty(exports2, "CallHierarchyOutgoingCallsRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest;
    } });
    Object.defineProperty(exports2, "CallHierarchyPrepareRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyPrepareRequest;
    } });
    var protocol_semanticTokens_1 = require_protocol_semanticTokens();
    Object.defineProperty(exports2, "TokenFormat", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.TokenFormat;
    } });
    Object.defineProperty(exports2, "SemanticTokensRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensDeltaRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensDeltaRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensRangeRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRangeRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensRefreshRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRefreshRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensRegistrationType", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRegistrationType;
    } });
    var protocol_showDocument_1 = require_protocol_showDocument();
    Object.defineProperty(exports2, "ShowDocumentRequest", { enumerable: true, get: function() {
      return protocol_showDocument_1.ShowDocumentRequest;
    } });
    var protocol_linkedEditingRange_1 = require_protocol_linkedEditingRange();
    Object.defineProperty(exports2, "LinkedEditingRangeRequest", { enumerable: true, get: function() {
      return protocol_linkedEditingRange_1.LinkedEditingRangeRequest;
    } });
    var protocol_fileOperations_1 = require_protocol_fileOperations();
    Object.defineProperty(exports2, "FileOperationPatternKind", { enumerable: true, get: function() {
      return protocol_fileOperations_1.FileOperationPatternKind;
    } });
    Object.defineProperty(exports2, "DidCreateFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidCreateFilesNotification;
    } });
    Object.defineProperty(exports2, "WillCreateFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillCreateFilesRequest;
    } });
    Object.defineProperty(exports2, "DidRenameFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidRenameFilesNotification;
    } });
    Object.defineProperty(exports2, "WillRenameFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillRenameFilesRequest;
    } });
    Object.defineProperty(exports2, "DidDeleteFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidDeleteFilesNotification;
    } });
    Object.defineProperty(exports2, "WillDeleteFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillDeleteFilesRequest;
    } });
    var protocol_moniker_1 = require_protocol_moniker();
    Object.defineProperty(exports2, "UniquenessLevel", { enumerable: true, get: function() {
      return protocol_moniker_1.UniquenessLevel;
    } });
    Object.defineProperty(exports2, "MonikerKind", { enumerable: true, get: function() {
      return protocol_moniker_1.MonikerKind;
    } });
    Object.defineProperty(exports2, "MonikerRequest", { enumerable: true, get: function() {
      return protocol_moniker_1.MonikerRequest;
    } });
    var protocol_typeHierarchy_1 = require_protocol_typeHierarchy();
    Object.defineProperty(exports2, "TypeHierarchyPrepareRequest", { enumerable: true, get: function() {
      return protocol_typeHierarchy_1.TypeHierarchyPrepareRequest;
    } });
    Object.defineProperty(exports2, "TypeHierarchySubtypesRequest", { enumerable: true, get: function() {
      return protocol_typeHierarchy_1.TypeHierarchySubtypesRequest;
    } });
    Object.defineProperty(exports2, "TypeHierarchySupertypesRequest", { enumerable: true, get: function() {
      return protocol_typeHierarchy_1.TypeHierarchySupertypesRequest;
    } });
    var protocol_inlineValue_1 = require_protocol_inlineValue();
    Object.defineProperty(exports2, "InlineValueRequest", { enumerable: true, get: function() {
      return protocol_inlineValue_1.InlineValueRequest;
    } });
    Object.defineProperty(exports2, "InlineValueRefreshRequest", { enumerable: true, get: function() {
      return protocol_inlineValue_1.InlineValueRefreshRequest;
    } });
    var protocol_inlayHint_1 = require_protocol_inlayHint();
    Object.defineProperty(exports2, "InlayHintRequest", { enumerable: true, get: function() {
      return protocol_inlayHint_1.InlayHintRequest;
    } });
    Object.defineProperty(exports2, "InlayHintResolveRequest", { enumerable: true, get: function() {
      return protocol_inlayHint_1.InlayHintResolveRequest;
    } });
    Object.defineProperty(exports2, "InlayHintRefreshRequest", { enumerable: true, get: function() {
      return protocol_inlayHint_1.InlayHintRefreshRequest;
    } });
    var protocol_diagnostic_1 = require_protocol_diagnostic();
    Object.defineProperty(exports2, "DiagnosticServerCancellationData", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DiagnosticServerCancellationData;
    } });
    Object.defineProperty(exports2, "DocumentDiagnosticReportKind", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DocumentDiagnosticReportKind;
    } });
    Object.defineProperty(exports2, "DocumentDiagnosticRequest", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DocumentDiagnosticRequest;
    } });
    Object.defineProperty(exports2, "WorkspaceDiagnosticRequest", { enumerable: true, get: function() {
      return protocol_diagnostic_1.WorkspaceDiagnosticRequest;
    } });
    Object.defineProperty(exports2, "DiagnosticRefreshRequest", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DiagnosticRefreshRequest;
    } });
    var protocol_notebook_1 = require_protocol_notebook();
    Object.defineProperty(exports2, "NotebookCellKind", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookCellKind;
    } });
    Object.defineProperty(exports2, "ExecutionSummary", { enumerable: true, get: function() {
      return protocol_notebook_1.ExecutionSummary;
    } });
    Object.defineProperty(exports2, "NotebookCell", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookCell;
    } });
    Object.defineProperty(exports2, "NotebookDocument", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookDocument;
    } });
    Object.defineProperty(exports2, "NotebookDocumentSyncRegistrationType", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookDocumentSyncRegistrationType;
    } });
    Object.defineProperty(exports2, "DidOpenNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidOpenNotebookDocumentNotification;
    } });
    Object.defineProperty(exports2, "NotebookCellArrayChange", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookCellArrayChange;
    } });
    Object.defineProperty(exports2, "DidChangeNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidChangeNotebookDocumentNotification;
    } });
    Object.defineProperty(exports2, "DidSaveNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidSaveNotebookDocumentNotification;
    } });
    Object.defineProperty(exports2, "DidCloseNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidCloseNotebookDocumentNotification;
    } });
    var protocol_inlineCompletion_1 = require_protocol_inlineCompletion();
    Object.defineProperty(exports2, "InlineCompletionRequest", { enumerable: true, get: function() {
      return protocol_inlineCompletion_1.InlineCompletionRequest;
    } });
    var TextDocumentFilter;
    (function(TextDocumentFilter2) {
      function is(value) {
        const candidate = value;
        return Is.string(candidate) || (Is.string(candidate.language) || Is.string(candidate.scheme) || Is.string(candidate.pattern));
      }
      TextDocumentFilter2.is = is;
    })(TextDocumentFilter || (exports2.TextDocumentFilter = TextDocumentFilter = {}));
    var NotebookDocumentFilter;
    (function(NotebookDocumentFilter2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (Is.string(candidate.notebookType) || Is.string(candidate.scheme) || Is.string(candidate.pattern));
      }
      NotebookDocumentFilter2.is = is;
    })(NotebookDocumentFilter || (exports2.NotebookDocumentFilter = NotebookDocumentFilter = {}));
    var NotebookCellTextDocumentFilter;
    (function(NotebookCellTextDocumentFilter2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (Is.string(candidate.notebook) || NotebookDocumentFilter.is(candidate.notebook)) && (candidate.language === void 0 || Is.string(candidate.language));
      }
      NotebookCellTextDocumentFilter2.is = is;
    })(NotebookCellTextDocumentFilter || (exports2.NotebookCellTextDocumentFilter = NotebookCellTextDocumentFilter = {}));
    var DocumentSelector;
    (function(DocumentSelector2) {
      function is(value) {
        if (!Array.isArray(value)) {
          return false;
        }
        for (let elem of value) {
          if (!Is.string(elem) && !TextDocumentFilter.is(elem) && !NotebookCellTextDocumentFilter.is(elem)) {
            return false;
          }
        }
        return true;
      }
      DocumentSelector2.is = is;
    })(DocumentSelector || (exports2.DocumentSelector = DocumentSelector = {}));
    var RegistrationRequest;
    (function(RegistrationRequest2) {
      RegistrationRequest2.method = "client/registerCapability";
      RegistrationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      RegistrationRequest2.type = new messages_1.ProtocolRequestType(RegistrationRequest2.method);
    })(RegistrationRequest || (exports2.RegistrationRequest = RegistrationRequest = {}));
    var UnregistrationRequest;
    (function(UnregistrationRequest2) {
      UnregistrationRequest2.method = "client/unregisterCapability";
      UnregistrationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      UnregistrationRequest2.type = new messages_1.ProtocolRequestType(UnregistrationRequest2.method);
    })(UnregistrationRequest || (exports2.UnregistrationRequest = UnregistrationRequest = {}));
    var ResourceOperationKind;
    (function(ResourceOperationKind2) {
      ResourceOperationKind2.Create = "create";
      ResourceOperationKind2.Rename = "rename";
      ResourceOperationKind2.Delete = "delete";
    })(ResourceOperationKind || (exports2.ResourceOperationKind = ResourceOperationKind = {}));
    var FailureHandlingKind;
    (function(FailureHandlingKind2) {
      FailureHandlingKind2.Abort = "abort";
      FailureHandlingKind2.Transactional = "transactional";
      FailureHandlingKind2.TextOnlyTransactional = "textOnlyTransactional";
      FailureHandlingKind2.Undo = "undo";
    })(FailureHandlingKind || (exports2.FailureHandlingKind = FailureHandlingKind = {}));
    var PositionEncodingKind;
    (function(PositionEncodingKind2) {
      PositionEncodingKind2.UTF8 = "utf-8";
      PositionEncodingKind2.UTF16 = "utf-16";
      PositionEncodingKind2.UTF32 = "utf-32";
    })(PositionEncodingKind || (exports2.PositionEncodingKind = PositionEncodingKind = {}));
    var StaticRegistrationOptions;
    (function(StaticRegistrationOptions2) {
      function hasId(value) {
        const candidate = value;
        return candidate && Is.string(candidate.id) && candidate.id.length > 0;
      }
      StaticRegistrationOptions2.hasId = hasId;
    })(StaticRegistrationOptions || (exports2.StaticRegistrationOptions = StaticRegistrationOptions = {}));
    var TextDocumentRegistrationOptions;
    (function(TextDocumentRegistrationOptions2) {
      function is(value) {
        const candidate = value;
        return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));
      }
      TextDocumentRegistrationOptions2.is = is;
    })(TextDocumentRegistrationOptions || (exports2.TextDocumentRegistrationOptions = TextDocumentRegistrationOptions = {}));
    var WorkDoneProgressOptions;
    (function(WorkDoneProgressOptions2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (candidate.workDoneProgress === void 0 || Is.boolean(candidate.workDoneProgress));
      }
      WorkDoneProgressOptions2.is = is;
      function hasWorkDoneProgress(value) {
        const candidate = value;
        return candidate && Is.boolean(candidate.workDoneProgress);
      }
      WorkDoneProgressOptions2.hasWorkDoneProgress = hasWorkDoneProgress;
    })(WorkDoneProgressOptions || (exports2.WorkDoneProgressOptions = WorkDoneProgressOptions = {}));
    var InitializeRequest;
    (function(InitializeRequest2) {
      InitializeRequest2.method = "initialize";
      InitializeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InitializeRequest2.type = new messages_1.ProtocolRequestType(InitializeRequest2.method);
    })(InitializeRequest || (exports2.InitializeRequest = InitializeRequest = {}));
    var InitializeErrorCodes;
    (function(InitializeErrorCodes2) {
      InitializeErrorCodes2.unknownProtocolVersion = 1;
    })(InitializeErrorCodes || (exports2.InitializeErrorCodes = InitializeErrorCodes = {}));
    var InitializedNotification;
    (function(InitializedNotification2) {
      InitializedNotification2.method = "initialized";
      InitializedNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      InitializedNotification2.type = new messages_1.ProtocolNotificationType(InitializedNotification2.method);
    })(InitializedNotification || (exports2.InitializedNotification = InitializedNotification = {}));
    var ShutdownRequest;
    (function(ShutdownRequest2) {
      ShutdownRequest2.method = "shutdown";
      ShutdownRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ShutdownRequest2.type = new messages_1.ProtocolRequestType0(ShutdownRequest2.method);
    })(ShutdownRequest || (exports2.ShutdownRequest = ShutdownRequest = {}));
    var ExitNotification;
    (function(ExitNotification2) {
      ExitNotification2.method = "exit";
      ExitNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      ExitNotification2.type = new messages_1.ProtocolNotificationType0(ExitNotification2.method);
    })(ExitNotification || (exports2.ExitNotification = ExitNotification = {}));
    var DidChangeConfigurationNotification;
    (function(DidChangeConfigurationNotification2) {
      DidChangeConfigurationNotification2.method = "workspace/didChangeConfiguration";
      DidChangeConfigurationNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeConfigurationNotification2.type = new messages_1.ProtocolNotificationType(DidChangeConfigurationNotification2.method);
    })(DidChangeConfigurationNotification || (exports2.DidChangeConfigurationNotification = DidChangeConfigurationNotification = {}));
    var MessageType;
    (function(MessageType2) {
      MessageType2.Error = 1;
      MessageType2.Warning = 2;
      MessageType2.Info = 3;
      MessageType2.Log = 4;
      MessageType2.Debug = 5;
    })(MessageType || (exports2.MessageType = MessageType = {}));
    var ShowMessageNotification;
    (function(ShowMessageNotification2) {
      ShowMessageNotification2.method = "window/showMessage";
      ShowMessageNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
      ShowMessageNotification2.type = new messages_1.ProtocolNotificationType(ShowMessageNotification2.method);
    })(ShowMessageNotification || (exports2.ShowMessageNotification = ShowMessageNotification = {}));
    var ShowMessageRequest;
    (function(ShowMessageRequest2) {
      ShowMessageRequest2.method = "window/showMessageRequest";
      ShowMessageRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      ShowMessageRequest2.type = new messages_1.ProtocolRequestType(ShowMessageRequest2.method);
    })(ShowMessageRequest || (exports2.ShowMessageRequest = ShowMessageRequest = {}));
    var LogMessageNotification;
    (function(LogMessageNotification2) {
      LogMessageNotification2.method = "window/logMessage";
      LogMessageNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
      LogMessageNotification2.type = new messages_1.ProtocolNotificationType(LogMessageNotification2.method);
    })(LogMessageNotification || (exports2.LogMessageNotification = LogMessageNotification = {}));
    var TelemetryEventNotification;
    (function(TelemetryEventNotification2) {
      TelemetryEventNotification2.method = "telemetry/event";
      TelemetryEventNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
      TelemetryEventNotification2.type = new messages_1.ProtocolNotificationType(TelemetryEventNotification2.method);
    })(TelemetryEventNotification || (exports2.TelemetryEventNotification = TelemetryEventNotification = {}));
    var TextDocumentSyncKind;
    (function(TextDocumentSyncKind2) {
      TextDocumentSyncKind2.None = 0;
      TextDocumentSyncKind2.Full = 1;
      TextDocumentSyncKind2.Incremental = 2;
    })(TextDocumentSyncKind || (exports2.TextDocumentSyncKind = TextDocumentSyncKind = {}));
    var DidOpenTextDocumentNotification;
    (function(DidOpenTextDocumentNotification2) {
      DidOpenTextDocumentNotification2.method = "textDocument/didOpen";
      DidOpenTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidOpenTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification2.method);
    })(DidOpenTextDocumentNotification || (exports2.DidOpenTextDocumentNotification = DidOpenTextDocumentNotification = {}));
    var TextDocumentContentChangeEvent;
    (function(TextDocumentContentChangeEvent2) {
      function isIncremental(event) {
        let candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
      }
      TextDocumentContentChangeEvent2.isIncremental = isIncremental;
      function isFull(event) {
        let candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
      }
      TextDocumentContentChangeEvent2.isFull = isFull;
    })(TextDocumentContentChangeEvent || (exports2.TextDocumentContentChangeEvent = TextDocumentContentChangeEvent = {}));
    var DidChangeTextDocumentNotification;
    (function(DidChangeTextDocumentNotification2) {
      DidChangeTextDocumentNotification2.method = "textDocument/didChange";
      DidChangeTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification2.method);
    })(DidChangeTextDocumentNotification || (exports2.DidChangeTextDocumentNotification = DidChangeTextDocumentNotification = {}));
    var DidCloseTextDocumentNotification;
    (function(DidCloseTextDocumentNotification2) {
      DidCloseTextDocumentNotification2.method = "textDocument/didClose";
      DidCloseTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidCloseTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification2.method);
    })(DidCloseTextDocumentNotification || (exports2.DidCloseTextDocumentNotification = DidCloseTextDocumentNotification = {}));
    var DidSaveTextDocumentNotification;
    (function(DidSaveTextDocumentNotification2) {
      DidSaveTextDocumentNotification2.method = "textDocument/didSave";
      DidSaveTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification2.method);
    })(DidSaveTextDocumentNotification || (exports2.DidSaveTextDocumentNotification = DidSaveTextDocumentNotification = {}));
    var TextDocumentSaveReason;
    (function(TextDocumentSaveReason2) {
      TextDocumentSaveReason2.Manual = 1;
      TextDocumentSaveReason2.AfterDelay = 2;
      TextDocumentSaveReason2.FocusOut = 3;
    })(TextDocumentSaveReason || (exports2.TextDocumentSaveReason = TextDocumentSaveReason = {}));
    var WillSaveTextDocumentNotification;
    (function(WillSaveTextDocumentNotification2) {
      WillSaveTextDocumentNotification2.method = "textDocument/willSave";
      WillSaveTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification2.method);
    })(WillSaveTextDocumentNotification || (exports2.WillSaveTextDocumentNotification = WillSaveTextDocumentNotification = {}));
    var WillSaveTextDocumentWaitUntilRequest;
    (function(WillSaveTextDocumentWaitUntilRequest2) {
      WillSaveTextDocumentWaitUntilRequest2.method = "textDocument/willSaveWaitUntil";
      WillSaveTextDocumentWaitUntilRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillSaveTextDocumentWaitUntilRequest2.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest2.method);
    })(WillSaveTextDocumentWaitUntilRequest || (exports2.WillSaveTextDocumentWaitUntilRequest = WillSaveTextDocumentWaitUntilRequest = {}));
    var DidChangeWatchedFilesNotification;
    (function(DidChangeWatchedFilesNotification2) {
      DidChangeWatchedFilesNotification2.method = "workspace/didChangeWatchedFiles";
      DidChangeWatchedFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeWatchedFilesNotification2.type = new messages_1.ProtocolNotificationType(DidChangeWatchedFilesNotification2.method);
    })(DidChangeWatchedFilesNotification || (exports2.DidChangeWatchedFilesNotification = DidChangeWatchedFilesNotification = {}));
    var FileChangeType;
    (function(FileChangeType2) {
      FileChangeType2.Created = 1;
      FileChangeType2.Changed = 2;
      FileChangeType2.Deleted = 3;
    })(FileChangeType || (exports2.FileChangeType = FileChangeType = {}));
    var RelativePattern;
    (function(RelativePattern2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (vscode_languageserver_types_1.URI.is(candidate.baseUri) || vscode_languageserver_types_1.WorkspaceFolder.is(candidate.baseUri)) && Is.string(candidate.pattern);
      }
      RelativePattern2.is = is;
    })(RelativePattern || (exports2.RelativePattern = RelativePattern = {}));
    var WatchKind;
    (function(WatchKind2) {
      WatchKind2.Create = 1;
      WatchKind2.Change = 2;
      WatchKind2.Delete = 4;
    })(WatchKind || (exports2.WatchKind = WatchKind = {}));
    var PublishDiagnosticsNotification;
    (function(PublishDiagnosticsNotification2) {
      PublishDiagnosticsNotification2.method = "textDocument/publishDiagnostics";
      PublishDiagnosticsNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
      PublishDiagnosticsNotification2.type = new messages_1.ProtocolNotificationType(PublishDiagnosticsNotification2.method);
    })(PublishDiagnosticsNotification || (exports2.PublishDiagnosticsNotification = PublishDiagnosticsNotification = {}));
    var CompletionTriggerKind;
    (function(CompletionTriggerKind2) {
      CompletionTriggerKind2.Invoked = 1;
      CompletionTriggerKind2.TriggerCharacter = 2;
      CompletionTriggerKind2.TriggerForIncompleteCompletions = 3;
    })(CompletionTriggerKind || (exports2.CompletionTriggerKind = CompletionTriggerKind = {}));
    var CompletionRequest;
    (function(CompletionRequest2) {
      CompletionRequest2.method = "textDocument/completion";
      CompletionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CompletionRequest2.type = new messages_1.ProtocolRequestType(CompletionRequest2.method);
    })(CompletionRequest || (exports2.CompletionRequest = CompletionRequest = {}));
    var CompletionResolveRequest;
    (function(CompletionResolveRequest2) {
      CompletionResolveRequest2.method = "completionItem/resolve";
      CompletionResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CompletionResolveRequest2.type = new messages_1.ProtocolRequestType(CompletionResolveRequest2.method);
    })(CompletionResolveRequest || (exports2.CompletionResolveRequest = CompletionResolveRequest = {}));
    var HoverRequest;
    (function(HoverRequest2) {
      HoverRequest2.method = "textDocument/hover";
      HoverRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      HoverRequest2.type = new messages_1.ProtocolRequestType(HoverRequest2.method);
    })(HoverRequest || (exports2.HoverRequest = HoverRequest = {}));
    var SignatureHelpTriggerKind;
    (function(SignatureHelpTriggerKind2) {
      SignatureHelpTriggerKind2.Invoked = 1;
      SignatureHelpTriggerKind2.TriggerCharacter = 2;
      SignatureHelpTriggerKind2.ContentChange = 3;
    })(SignatureHelpTriggerKind || (exports2.SignatureHelpTriggerKind = SignatureHelpTriggerKind = {}));
    var SignatureHelpRequest;
    (function(SignatureHelpRequest2) {
      SignatureHelpRequest2.method = "textDocument/signatureHelp";
      SignatureHelpRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SignatureHelpRequest2.type = new messages_1.ProtocolRequestType(SignatureHelpRequest2.method);
    })(SignatureHelpRequest || (exports2.SignatureHelpRequest = SignatureHelpRequest = {}));
    var DefinitionRequest;
    (function(DefinitionRequest2) {
      DefinitionRequest2.method = "textDocument/definition";
      DefinitionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DefinitionRequest2.type = new messages_1.ProtocolRequestType(DefinitionRequest2.method);
    })(DefinitionRequest || (exports2.DefinitionRequest = DefinitionRequest = {}));
    var ReferencesRequest;
    (function(ReferencesRequest2) {
      ReferencesRequest2.method = "textDocument/references";
      ReferencesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ReferencesRequest2.type = new messages_1.ProtocolRequestType(ReferencesRequest2.method);
    })(ReferencesRequest || (exports2.ReferencesRequest = ReferencesRequest = {}));
    var DocumentHighlightRequest;
    (function(DocumentHighlightRequest2) {
      DocumentHighlightRequest2.method = "textDocument/documentHighlight";
      DocumentHighlightRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentHighlightRequest2.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest2.method);
    })(DocumentHighlightRequest || (exports2.DocumentHighlightRequest = DocumentHighlightRequest = {}));
    var DocumentSymbolRequest;
    (function(DocumentSymbolRequest2) {
      DocumentSymbolRequest2.method = "textDocument/documentSymbol";
      DocumentSymbolRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentSymbolRequest2.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest2.method);
    })(DocumentSymbolRequest || (exports2.DocumentSymbolRequest = DocumentSymbolRequest = {}));
    var CodeActionRequest;
    (function(CodeActionRequest2) {
      CodeActionRequest2.method = "textDocument/codeAction";
      CodeActionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeActionRequest2.type = new messages_1.ProtocolRequestType(CodeActionRequest2.method);
    })(CodeActionRequest || (exports2.CodeActionRequest = CodeActionRequest = {}));
    var CodeActionResolveRequest;
    (function(CodeActionResolveRequest2) {
      CodeActionResolveRequest2.method = "codeAction/resolve";
      CodeActionResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeActionResolveRequest2.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest2.method);
    })(CodeActionResolveRequest || (exports2.CodeActionResolveRequest = CodeActionResolveRequest = {}));
    var WorkspaceSymbolRequest;
    (function(WorkspaceSymbolRequest2) {
      WorkspaceSymbolRequest2.method = "workspace/symbol";
      WorkspaceSymbolRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkspaceSymbolRequest2.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest2.method);
    })(WorkspaceSymbolRequest || (exports2.WorkspaceSymbolRequest = WorkspaceSymbolRequest = {}));
    var WorkspaceSymbolResolveRequest;
    (function(WorkspaceSymbolResolveRequest2) {
      WorkspaceSymbolResolveRequest2.method = "workspaceSymbol/resolve";
      WorkspaceSymbolResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkspaceSymbolResolveRequest2.type = new messages_1.ProtocolRequestType(WorkspaceSymbolResolveRequest2.method);
    })(WorkspaceSymbolResolveRequest || (exports2.WorkspaceSymbolResolveRequest = WorkspaceSymbolResolveRequest = {}));
    var CodeLensRequest;
    (function(CodeLensRequest2) {
      CodeLensRequest2.method = "textDocument/codeLens";
      CodeLensRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeLensRequest2.type = new messages_1.ProtocolRequestType(CodeLensRequest2.method);
    })(CodeLensRequest || (exports2.CodeLensRequest = CodeLensRequest = {}));
    var CodeLensResolveRequest;
    (function(CodeLensResolveRequest2) {
      CodeLensResolveRequest2.method = "codeLens/resolve";
      CodeLensResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeLensResolveRequest2.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest2.method);
    })(CodeLensResolveRequest || (exports2.CodeLensResolveRequest = CodeLensResolveRequest = {}));
    var CodeLensRefreshRequest;
    (function(CodeLensRefreshRequest2) {
      CodeLensRefreshRequest2.method = `workspace/codeLens/refresh`;
      CodeLensRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      CodeLensRefreshRequest2.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest2.method);
    })(CodeLensRefreshRequest || (exports2.CodeLensRefreshRequest = CodeLensRefreshRequest = {}));
    var DocumentLinkRequest;
    (function(DocumentLinkRequest2) {
      DocumentLinkRequest2.method = "textDocument/documentLink";
      DocumentLinkRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentLinkRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkRequest2.method);
    })(DocumentLinkRequest || (exports2.DocumentLinkRequest = DocumentLinkRequest = {}));
    var DocumentLinkResolveRequest;
    (function(DocumentLinkResolveRequest2) {
      DocumentLinkResolveRequest2.method = "documentLink/resolve";
      DocumentLinkResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentLinkResolveRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest2.method);
    })(DocumentLinkResolveRequest || (exports2.DocumentLinkResolveRequest = DocumentLinkResolveRequest = {}));
    var DocumentFormattingRequest;
    (function(DocumentFormattingRequest2) {
      DocumentFormattingRequest2.method = "textDocument/formatting";
      DocumentFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest2.method);
    })(DocumentFormattingRequest || (exports2.DocumentFormattingRequest = DocumentFormattingRequest = {}));
    var DocumentRangeFormattingRequest;
    (function(DocumentRangeFormattingRequest2) {
      DocumentRangeFormattingRequest2.method = "textDocument/rangeFormatting";
      DocumentRangeFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentRangeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest2.method);
    })(DocumentRangeFormattingRequest || (exports2.DocumentRangeFormattingRequest = DocumentRangeFormattingRequest = {}));
    var DocumentRangesFormattingRequest;
    (function(DocumentRangesFormattingRequest2) {
      DocumentRangesFormattingRequest2.method = "textDocument/rangesFormatting";
      DocumentRangesFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentRangesFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentRangesFormattingRequest2.method);
    })(DocumentRangesFormattingRequest || (exports2.DocumentRangesFormattingRequest = DocumentRangesFormattingRequest = {}));
    var DocumentOnTypeFormattingRequest;
    (function(DocumentOnTypeFormattingRequest2) {
      DocumentOnTypeFormattingRequest2.method = "textDocument/onTypeFormatting";
      DocumentOnTypeFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentOnTypeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest2.method);
    })(DocumentOnTypeFormattingRequest || (exports2.DocumentOnTypeFormattingRequest = DocumentOnTypeFormattingRequest = {}));
    var PrepareSupportDefaultBehavior;
    (function(PrepareSupportDefaultBehavior2) {
      PrepareSupportDefaultBehavior2.Identifier = 1;
    })(PrepareSupportDefaultBehavior || (exports2.PrepareSupportDefaultBehavior = PrepareSupportDefaultBehavior = {}));
    var RenameRequest;
    (function(RenameRequest2) {
      RenameRequest2.method = "textDocument/rename";
      RenameRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      RenameRequest2.type = new messages_1.ProtocolRequestType(RenameRequest2.method);
    })(RenameRequest || (exports2.RenameRequest = RenameRequest = {}));
    var PrepareRenameRequest;
    (function(PrepareRenameRequest2) {
      PrepareRenameRequest2.method = "textDocument/prepareRename";
      PrepareRenameRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      PrepareRenameRequest2.type = new messages_1.ProtocolRequestType(PrepareRenameRequest2.method);
    })(PrepareRenameRequest || (exports2.PrepareRenameRequest = PrepareRenameRequest = {}));
    var ExecuteCommandRequest;
    (function(ExecuteCommandRequest2) {
      ExecuteCommandRequest2.method = "workspace/executeCommand";
      ExecuteCommandRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ExecuteCommandRequest2.type = new messages_1.ProtocolRequestType(ExecuteCommandRequest2.method);
    })(ExecuteCommandRequest || (exports2.ExecuteCommandRequest = ExecuteCommandRequest = {}));
    var ApplyWorkspaceEditRequest;
    (function(ApplyWorkspaceEditRequest2) {
      ApplyWorkspaceEditRequest2.method = "workspace/applyEdit";
      ApplyWorkspaceEditRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      ApplyWorkspaceEditRequest2.type = new messages_1.ProtocolRequestType("workspace/applyEdit");
    })(ApplyWorkspaceEditRequest || (exports2.ApplyWorkspaceEditRequest = ApplyWorkspaceEditRequest = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/connection.js
var require_connection2 = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/connection.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createProtocolConnection = void 0;
    var vscode_jsonrpc_1 = require_main();
    function createProtocolConnection(input, output, logger, options) {
      if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
      }
      return (0, vscode_jsonrpc_1.createMessageConnection)(input, output, logger, options);
    }
    exports2.createProtocolConnection = createProtocolConnection;
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/api.js
var require_api2 = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/api.js"(exports2) {
    "use strict";
    init_importMeta();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LSPErrorCodes = exports2.createProtocolConnection = void 0;
    __exportStar(require_main(), exports2);
    __exportStar(require_main2(), exports2);
    __exportStar(require_messages2(), exports2);
    __exportStar(require_protocol(), exports2);
    var connection_1 = require_connection2();
    Object.defineProperty(exports2, "createProtocolConnection", { enumerable: true, get: function() {
      return connection_1.createProtocolConnection;
    } });
    var LSPErrorCodes;
    (function(LSPErrorCodes2) {
      LSPErrorCodes2.lspReservedErrorRangeStart = -32899;
      LSPErrorCodes2.RequestFailed = -32803;
      LSPErrorCodes2.ServerCancelled = -32802;
      LSPErrorCodes2.ContentModified = -32801;
      LSPErrorCodes2.RequestCancelled = -32800;
      LSPErrorCodes2.lspReservedErrorRangeEnd = -32800;
    })(LSPErrorCodes || (exports2.LSPErrorCodes = LSPErrorCodes = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/node/main.js
var require_main3 = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/node/main.js"(exports2) {
    "use strict";
    init_importMeta();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createProtocolConnection = void 0;
    var node_1 = require_node();
    __exportStar(require_node(), exports2);
    __exportStar(require_api2(), exports2);
    function createProtocolConnection(input, output, logger, options) {
      return (0, node_1.createMessageConnection)(input, output, logger, options);
    }
    exports2.createProtocolConnection = createProtocolConnection;
  }
});

// ../../node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/utils/uuid.js
var require_uuid = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/utils/uuid.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.generateUuid = exports2.parse = exports2.isUUID = exports2.v4 = exports2.empty = void 0;
    var ValueUUID = class {
      constructor(_value) {
        this._value = _value;
      }
      asHex() {
        return this._value;
      }
      equals(other) {
        return this.asHex() === other.asHex();
      }
    };
    var V4UUID = class _V4UUID extends ValueUUID {
      static _oneOf(array) {
        return array[Math.floor(array.length * Math.random())];
      }
      static _randomHex() {
        return _V4UUID._oneOf(_V4UUID._chars);
      }
      constructor() {
        super([
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          "-",
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          "-",
          "4",
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          "-",
          _V4UUID._oneOf(_V4UUID._timeHighBits),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          "-",
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex()
        ].join(""));
      }
    };
    V4UUID._chars = ["0", "1", "2", "3", "4", "5", "6", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
    V4UUID._timeHighBits = ["8", "9", "a", "b"];
    exports2.empty = new ValueUUID("00000000-0000-0000-0000-000000000000");
    function v4() {
      return new V4UUID();
    }
    exports2.v4 = v4;
    var _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    function isUUID(value) {
      return _UUIDPattern.test(value);
    }
    exports2.isUUID = isUUID;
    function parse(value) {
      if (!isUUID(value)) {
        throw new Error("invalid uuid");
      }
      return new ValueUUID(value);
    }
    exports2.parse = parse;
    function generateUuid() {
      return v4().asHex();
    }
    exports2.generateUuid = generateUuid;
  }
});

// ../../node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/progress.js
var require_progress = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/progress.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.attachPartialResult = exports2.ProgressFeature = exports2.attachWorkDone = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var uuid_1 = require_uuid();
    var WorkDoneProgressReporterImpl = class _WorkDoneProgressReporterImpl {
      constructor(_connection, _token) {
        this._connection = _connection;
        this._token = _token;
        _WorkDoneProgressReporterImpl.Instances.set(this._token, this);
      }
      begin(title, percentage, message, cancellable) {
        let param = {
          kind: "begin",
          title,
          percentage,
          message,
          cancellable
        };
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);
      }
      report(arg0, arg1) {
        let param = {
          kind: "report"
        };
        if (typeof arg0 === "number") {
          param.percentage = arg0;
          if (arg1 !== void 0) {
            param.message = arg1;
          }
        } else {
          param.message = arg0;
        }
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);
      }
      done() {
        _WorkDoneProgressReporterImpl.Instances.delete(this._token);
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, { kind: "end" });
      }
    };
    WorkDoneProgressReporterImpl.Instances = /* @__PURE__ */ new Map();
    var WorkDoneProgressServerReporterImpl = class extends WorkDoneProgressReporterImpl {
      constructor(connection2, token) {
        super(connection2, token);
        this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();
      }
      get token() {
        return this._source.token;
      }
      done() {
        this._source.dispose();
        super.done();
      }
      cancel() {
        this._source.cancel();
      }
    };
    var NullProgressReporter = class {
      constructor() {
      }
      begin() {
      }
      report() {
      }
      done() {
      }
    };
    var NullProgressServerReporter = class extends NullProgressReporter {
      constructor() {
        super();
        this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();
      }
      get token() {
        return this._source.token;
      }
      done() {
        this._source.dispose();
      }
      cancel() {
        this._source.cancel();
      }
    };
    function attachWorkDone(connection2, params) {
      if (params === void 0 || params.workDoneToken === void 0) {
        return new NullProgressReporter();
      }
      const token = params.workDoneToken;
      delete params.workDoneToken;
      return new WorkDoneProgressReporterImpl(connection2, token);
    }
    exports2.attachWorkDone = attachWorkDone;
    var ProgressFeature = (Base) => {
      return class extends Base {
        constructor() {
          super();
          this._progressSupported = false;
        }
        initialize(capabilities) {
          super.initialize(capabilities);
          if (capabilities?.window?.workDoneProgress === true) {
            this._progressSupported = true;
            this.connection.onNotification(vscode_languageserver_protocol_1.WorkDoneProgressCancelNotification.type, (params) => {
              let progress = WorkDoneProgressReporterImpl.Instances.get(params.token);
              if (progress instanceof WorkDoneProgressServerReporterImpl || progress instanceof NullProgressServerReporter) {
                progress.cancel();
              }
            });
          }
        }
        attachWorkDoneProgress(token) {
          if (token === void 0) {
            return new NullProgressReporter();
          } else {
            return new WorkDoneProgressReporterImpl(this.connection, token);
          }
        }
        createWorkDoneProgress() {
          if (this._progressSupported) {
            const token = (0, uuid_1.generateUuid)();
            return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkDoneProgressCreateRequest.type, { token }).then(() => {
              const result = new WorkDoneProgressServerReporterImpl(this.connection, token);
              return result;
            });
          } else {
            return Promise.resolve(new NullProgressServerReporter());
          }
        }
      };
    };
    exports2.ProgressFeature = ProgressFeature;
    var ResultProgress;
    (function(ResultProgress2) {
      ResultProgress2.type = new vscode_languageserver_protocol_1.ProgressType();
    })(ResultProgress || (ResultProgress = {}));
    var ResultProgressReporterImpl = class {
      constructor(_connection, _token) {
        this._connection = _connection;
        this._token = _token;
      }
      report(data) {
        this._connection.sendProgress(ResultProgress.type, this._token, data);
      }
    };
    function attachPartialResult(connection2, params) {
      if (params === void 0 || params.partialResultToken === void 0) {
        return void 0;
      }
      const token = params.partialResultToken;
      delete params.partialResultToken;
      return new ResultProgressReporterImpl(connection2, token);
    }
    exports2.attachPartialResult = attachPartialResult;
  }
});

// ../../node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/configuration.js
var require_configuration = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/configuration.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConfigurationFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var Is = require_is();
    var ConfigurationFeature = (Base) => {
      return class extends Base {
        getConfiguration(arg) {
          if (!arg) {
            return this._getConfiguration({});
          } else if (Is.string(arg)) {
            return this._getConfiguration({ section: arg });
          } else {
            return this._getConfiguration(arg);
          }
        }
        _getConfiguration(arg) {
          let params = {
            items: Array.isArray(arg) ? arg : [arg]
          };
          return this.connection.sendRequest(vscode_languageserver_protocol_1.ConfigurationRequest.type, params).then((result) => {
            if (Array.isArray(result)) {
              return Array.isArray(arg) ? result : result[0];
            } else {
              return Array.isArray(arg) ? [] : null;
            }
          });
        }
      };
    };
    exports2.ConfigurationFeature = ConfigurationFeature;
  }
});

// ../../node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/workspaceFolder.js
var require_workspaceFolder = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/workspaceFolder.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkspaceFoldersFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var WorkspaceFoldersFeature = (Base) => {
      return class extends Base {
        constructor() {
          super();
          this._notificationIsAutoRegistered = false;
        }
        initialize(capabilities) {
          super.initialize(capabilities);
          let workspaceCapabilities = capabilities.workspace;
          if (workspaceCapabilities && workspaceCapabilities.workspaceFolders) {
            this._onDidChangeWorkspaceFolders = new vscode_languageserver_protocol_1.Emitter();
            this.connection.onNotification(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type, (params) => {
              this._onDidChangeWorkspaceFolders.fire(params.event);
            });
          }
        }
        fillServerCapabilities(capabilities) {
          super.fillServerCapabilities(capabilities);
          const changeNotifications = capabilities.workspace?.workspaceFolders?.changeNotifications;
          this._notificationIsAutoRegistered = changeNotifications === true || typeof changeNotifications === "string";
        }
        getWorkspaceFolders() {
          return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkspaceFoldersRequest.type);
        }
        get onDidChangeWorkspaceFolders() {
          if (!this._onDidChangeWorkspaceFolders) {
            throw new Error("Client doesn't support sending workspace folder change events.");
          }
          if (!this._notificationIsAutoRegistered && !this._unregistration) {
            this._unregistration = this.connection.client.register(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type);
          }
          return this._onDidChangeWorkspaceFolders.event;
        }
      };
    };
    exports2.WorkspaceFoldersFeature = WorkspaceFoldersFeature;
  }
});

// ../../node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/callHierarchy.js
var require_callHierarchy = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/callHierarchy.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CallHierarchyFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var CallHierarchyFeature = (Base) => {
      return class extends Base {
        get callHierarchy() {
          return {
            onPrepare: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), void 0);
              });
            },
            onIncomingCalls: (handler) => {
              const type = vscode_languageserver_protocol_1.CallHierarchyIncomingCallsRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            },
            onOutgoingCalls: (handler) => {
              const type = vscode_languageserver_protocol_1.CallHierarchyOutgoingCallsRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            }
          };
        }
      };
    };
    exports2.CallHierarchyFeature = CallHierarchyFeature;
  }
});

// ../../node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/semanticTokens.js
var require_semanticTokens = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/semanticTokens.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SemanticTokensBuilder = exports2.SemanticTokensDiff = exports2.SemanticTokensFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var SemanticTokensFeature = (Base) => {
      return class extends Base {
        get semanticTokens() {
          return {
            refresh: () => {
              return this.connection.sendRequest(vscode_languageserver_protocol_1.SemanticTokensRefreshRequest.type);
            },
            on: (handler) => {
              const type = vscode_languageserver_protocol_1.SemanticTokensRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            },
            onDelta: (handler) => {
              const type = vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            },
            onRange: (handler) => {
              const type = vscode_languageserver_protocol_1.SemanticTokensRangeRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            }
          };
        }
      };
    };
    exports2.SemanticTokensFeature = SemanticTokensFeature;
    var SemanticTokensDiff = class {
      constructor(originalSequence, modifiedSequence) {
        this.originalSequence = originalSequence;
        this.modifiedSequence = modifiedSequence;
      }
      computeDiff() {
        const originalLength = this.originalSequence.length;
        const modifiedLength = this.modifiedSequence.length;
        let startIndex = 0;
        while (startIndex < modifiedLength && startIndex < originalLength && this.originalSequence[startIndex] === this.modifiedSequence[startIndex]) {
          startIndex++;
        }
        if (startIndex < modifiedLength && startIndex < originalLength) {
          let originalEndIndex = originalLength - 1;
          let modifiedEndIndex = modifiedLength - 1;
          while (originalEndIndex >= startIndex && modifiedEndIndex >= startIndex && this.originalSequence[originalEndIndex] === this.modifiedSequence[modifiedEndIndex]) {
            originalEndIndex--;
            modifiedEndIndex--;
          }
          if (originalEndIndex < startIndex || modifiedEndIndex < startIndex) {
            originalEndIndex++;
            modifiedEndIndex++;
          }
          const deleteCount = originalEndIndex - startIndex + 1;
          const newData = this.modifiedSequence.slice(startIndex, modifiedEndIndex + 1);
          if (newData.length === 1 && newData[0] === this.originalSequence[originalEndIndex]) {
            return [
              { start: startIndex, deleteCount: deleteCount - 1 }
            ];
          } else {
            return [
              { start: startIndex, deleteCount, data: newData }
            ];
          }
        } else if (startIndex < modifiedLength) {
          return [
            { start: startIndex, deleteCount: 0, data: this.modifiedSequence.slice(startIndex) }
          ];
        } else if (startIndex < originalLength) {
          return [
            { start: startIndex, deleteCount: originalLength - startIndex }
          ];
        } else {
          return [];
        }
      }
    };
    exports2.SemanticTokensDiff = SemanticTokensDiff;
    var SemanticTokensBuilder = class {
      constructor() {
        this._prevData = void 0;
        this.initialize();
      }
      initialize() {
        this._id = Date.now();
        this._prevLine = 0;
        this._prevChar = 0;
        this._data = [];
        this._dataLen = 0;
      }
      push(line, char, length, tokenType, tokenModifiers) {
        let pushLine = line;
        let pushChar = char;
        if (this._dataLen > 0) {
          pushLine -= this._prevLine;
          if (pushLine === 0) {
            pushChar -= this._prevChar;
          }
        }
        this._data[this._dataLen++] = pushLine;
        this._data[this._dataLen++] = pushChar;
        this._data[this._dataLen++] = length;
        this._data[this._dataLen++] = tokenType;
        this._data[this._dataLen++] = tokenModifiers;
        this._prevLine = line;
        this._prevChar = char;
      }
      get id() {
        return this._id.toString();
      }
      previousResult(id) {
        if (this.id === id) {
          this._prevData = this._data;
        }
        this.initialize();
      }
      build() {
        this._prevData = void 0;
        return {
          resultId: this.id,
          data: this._data
        };
      }
      canBuildEdits() {
        return this._prevData !== void 0;
      }
      buildEdits() {
        if (this._prevData !== void 0) {
          return {
            resultId: this.id,
            edits: new SemanticTokensDiff(this._prevData, this._data).computeDiff()
          };
        } else {
          return this.build();
        }
      }
    };
    exports2.SemanticTokensBuilder = SemanticTokensBuilder;
  }
});

// ../../node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/showDocument.js
var require_showDocument = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/showDocument.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ShowDocumentFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var ShowDocumentFeature = (Base) => {
      return class extends Base {
        showDocument(params) {
          return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowDocumentRequest.type, params);
        }
      };
    };
    exports2.ShowDocumentFeature = ShowDocumentFeature;
  }
});

// ../../node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/fileOperations.js
var require_fileOperations = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/fileOperations.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FileOperationsFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var FileOperationsFeature = (Base) => {
      return class extends Base {
        onDidCreateFiles(handler) {
          return this.connection.onNotification(vscode_languageserver_protocol_1.DidCreateFilesNotification.type, (params) => {
            handler(params);
          });
        }
        onDidRenameFiles(handler) {
          return this.connection.onNotification(vscode_languageserver_protocol_1.DidRenameFilesNotification.type, (params) => {
            handler(params);
          });
        }
        onDidDeleteFiles(handler) {
          return this.connection.onNotification(vscode_languageserver_protocol_1.DidDeleteFilesNotification.type, (params) => {
            handler(params);
          });
        }
        onWillCreateFiles(handler) {
          return this.connection.onRequest(vscode_languageserver_protocol_1.WillCreateFilesRequest.type, (params, cancel) => {
            return handler(params, cancel);
          });
        }
        onWillRenameFiles(handler) {
          return this.connection.onRequest(vscode_languageserver_protocol_1.WillRenameFilesRequest.type, (params, cancel) => {
            return handler(params, cancel);
          });
        }
        onWillDeleteFiles(handler) {
          return this.connection.onRequest(vscode_languageserver_protocol_1.WillDeleteFilesRequest.type, (params, cancel) => {
            return handler(params, cancel);
          });
        }
      };
    };
    exports2.FileOperationsFeature = FileOperationsFeature;
  }
});

// ../../node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/linkedEditingRange.js
var require_linkedEditingRange = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/linkedEditingRange.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LinkedEditingRangeFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var LinkedEditingRangeFeature = (Base) => {
      return class extends Base {
        onLinkedEditingRange(handler) {
          return this.connection.onRequest(vscode_languageserver_protocol_1.LinkedEditingRangeRequest.type, (params, cancel) => {
            return handler(params, cancel, this.attachWorkDoneProgress(params), void 0);
          });
        }
      };
    };
    exports2.LinkedEditingRangeFeature = LinkedEditingRangeFeature;
  }
});

// ../../node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/typeHierarchy.js
var require_typeHierarchy = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/typeHierarchy.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeHierarchyFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var TypeHierarchyFeature = (Base) => {
      return class extends Base {
        get typeHierarchy() {
          return {
            onPrepare: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.TypeHierarchyPrepareRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), void 0);
              });
            },
            onSupertypes: (handler) => {
              const type = vscode_languageserver_protocol_1.TypeHierarchySupertypesRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            },
            onSubtypes: (handler) => {
              const type = vscode_languageserver_protocol_1.TypeHierarchySubtypesRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            }
          };
        }
      };
    };
    exports2.TypeHierarchyFeature = TypeHierarchyFeature;
  }
});

// ../../node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/inlineValue.js
var require_inlineValue = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/inlineValue.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlineValueFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var InlineValueFeature = (Base) => {
      return class extends Base {
        get inlineValue() {
          return {
            refresh: () => {
              return this.connection.sendRequest(vscode_languageserver_protocol_1.InlineValueRefreshRequest.type);
            },
            on: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.InlineValueRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params));
              });
            }
          };
        }
      };
    };
    exports2.InlineValueFeature = InlineValueFeature;
  }
});

// ../../node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/foldingRange.js
var require_foldingRange = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/foldingRange.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FoldingRangeFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var FoldingRangeFeature = (Base) => {
      return class extends Base {
        get foldingRange() {
          return {
            refresh: () => {
              return this.connection.sendRequest(vscode_languageserver_protocol_1.FoldingRangeRefreshRequest.type);
            },
            on: (handler) => {
              const type = vscode_languageserver_protocol_1.FoldingRangeRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            }
          };
        }
      };
    };
    exports2.FoldingRangeFeature = FoldingRangeFeature;
  }
});

// ../../node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/inlayHint.js
var require_inlayHint = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/inlayHint.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlayHintFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var InlayHintFeature = (Base) => {
      return class extends Base {
        get inlayHint() {
          return {
            refresh: () => {
              return this.connection.sendRequest(vscode_languageserver_protocol_1.InlayHintRefreshRequest.type);
            },
            on: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.InlayHintRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params));
              });
            },
            resolve: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.InlayHintResolveRequest.type, (params, cancel) => {
                return handler(params, cancel);
              });
            }
          };
        }
      };
    };
    exports2.InlayHintFeature = InlayHintFeature;
  }
});

// ../../node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/diagnostic.js
var require_diagnostic = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/diagnostic.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DiagnosticFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var DiagnosticFeature = (Base) => {
      return class extends Base {
        get diagnostics() {
          return {
            refresh: () => {
              return this.connection.sendRequest(vscode_languageserver_protocol_1.DiagnosticRefreshRequest.type);
            },
            on: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.partialResult, params));
              });
            },
            onWorkspace: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.partialResult, params));
              });
            }
          };
        }
      };
    };
    exports2.DiagnosticFeature = DiagnosticFeature;
  }
});

// ../../node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/textDocuments.js
var require_textDocuments = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/textDocuments.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TextDocuments = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var TextDocuments2 = class {
      /**
       * Create a new text document manager.
       */
      constructor(configuration) {
        this._configuration = configuration;
        this._syncedDocuments = /* @__PURE__ */ new Map();
        this._onDidChangeContent = new vscode_languageserver_protocol_1.Emitter();
        this._onDidOpen = new vscode_languageserver_protocol_1.Emitter();
        this._onDidClose = new vscode_languageserver_protocol_1.Emitter();
        this._onDidSave = new vscode_languageserver_protocol_1.Emitter();
        this._onWillSave = new vscode_languageserver_protocol_1.Emitter();
      }
      /**
       * An event that fires when a text document managed by this manager
       * has been opened.
       */
      get onDidOpen() {
        return this._onDidOpen.event;
      }
      /**
       * An event that fires when a text document managed by this manager
       * has been opened or the content changes.
       */
      get onDidChangeContent() {
        return this._onDidChangeContent.event;
      }
      /**
       * An event that fires when a text document managed by this manager
       * will be saved.
       */
      get onWillSave() {
        return this._onWillSave.event;
      }
      /**
       * Sets a handler that will be called if a participant wants to provide
       * edits during a text document save.
       */
      onWillSaveWaitUntil(handler) {
        this._willSaveWaitUntil = handler;
      }
      /**
       * An event that fires when a text document managed by this manager
       * has been saved.
       */
      get onDidSave() {
        return this._onDidSave.event;
      }
      /**
       * An event that fires when a text document managed by this manager
       * has been closed.
       */
      get onDidClose() {
        return this._onDidClose.event;
      }
      /**
       * Returns the document for the given URI. Returns undefined if
       * the document is not managed by this instance.
       *
       * @param uri The text document's URI to retrieve.
       * @return the text document or `undefined`.
       */
      get(uri) {
        return this._syncedDocuments.get(uri);
      }
      /**
       * Returns all text documents managed by this instance.
       *
       * @return all text documents.
       */
      all() {
        return Array.from(this._syncedDocuments.values());
      }
      /**
       * Returns the URIs of all text documents managed by this instance.
       *
       * @return the URI's of all text documents.
       */
      keys() {
        return Array.from(this._syncedDocuments.keys());
      }
      /**
       * Listens for `low level` notification on the given connection to
       * update the text documents managed by this instance.
       *
       * Please note that the connection only provides handlers not an event model. Therefore
       * listening on a connection will overwrite the following handlers on a connection:
       * `onDidOpenTextDocument`, `onDidChangeTextDocument`, `onDidCloseTextDocument`,
       * `onWillSaveTextDocument`, `onWillSaveTextDocumentWaitUntil` and `onDidSaveTextDocument`.
       *
       * Use the corresponding events on the TextDocuments instance instead.
       *
       * @param connection The connection to listen on.
       */
      listen(connection2) {
        connection2.__textDocumentSync = vscode_languageserver_protocol_1.TextDocumentSyncKind.Incremental;
        const disposables = [];
        disposables.push(connection2.onDidOpenTextDocument((event) => {
          const td = event.textDocument;
          const document = this._configuration.create(td.uri, td.languageId, td.version, td.text);
          this._syncedDocuments.set(td.uri, document);
          const toFire = Object.freeze({ document });
          this._onDidOpen.fire(toFire);
          this._onDidChangeContent.fire(toFire);
        }));
        disposables.push(connection2.onDidChangeTextDocument((event) => {
          const td = event.textDocument;
          const changes = event.contentChanges;
          if (changes.length === 0) {
            return;
          }
          const { version } = td;
          if (version === null || version === void 0) {
            throw new Error(`Received document change event for ${td.uri} without valid version identifier`);
          }
          let syncedDocument = this._syncedDocuments.get(td.uri);
          if (syncedDocument !== void 0) {
            syncedDocument = this._configuration.update(syncedDocument, changes, version);
            this._syncedDocuments.set(td.uri, syncedDocument);
            this._onDidChangeContent.fire(Object.freeze({ document: syncedDocument }));
          }
        }));
        disposables.push(connection2.onDidCloseTextDocument((event) => {
          let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
          if (syncedDocument !== void 0) {
            this._syncedDocuments.delete(event.textDocument.uri);
            this._onDidClose.fire(Object.freeze({ document: syncedDocument }));
          }
        }));
        disposables.push(connection2.onWillSaveTextDocument((event) => {
          let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
          if (syncedDocument !== void 0) {
            this._onWillSave.fire(Object.freeze({ document: syncedDocument, reason: event.reason }));
          }
        }));
        disposables.push(connection2.onWillSaveTextDocumentWaitUntil((event, token) => {
          let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
          if (syncedDocument !== void 0 && this._willSaveWaitUntil) {
            return this._willSaveWaitUntil(Object.freeze({ document: syncedDocument, reason: event.reason }), token);
          } else {
            return [];
          }
        }));
        disposables.push(connection2.onDidSaveTextDocument((event) => {
          let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
          if (syncedDocument !== void 0) {
            this._onDidSave.fire(Object.freeze({ document: syncedDocument }));
          }
        }));
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          disposables.forEach((disposable) => disposable.dispose());
        });
      }
    };
    exports2.TextDocuments = TextDocuments2;
  }
});

// ../../node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/notebook.js
var require_notebook = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/notebook.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NotebookDocuments = exports2.NotebookSyncFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var textDocuments_1 = require_textDocuments();
    var NotebookSyncFeature = (Base) => {
      return class extends Base {
        get synchronization() {
          return {
            onDidOpenNotebookDocument: (handler) => {
              return this.connection.onNotification(vscode_languageserver_protocol_1.DidOpenNotebookDocumentNotification.type, (params) => {
                handler(params);
              });
            },
            onDidChangeNotebookDocument: (handler) => {
              return this.connection.onNotification(vscode_languageserver_protocol_1.DidChangeNotebookDocumentNotification.type, (params) => {
                handler(params);
              });
            },
            onDidSaveNotebookDocument: (handler) => {
              return this.connection.onNotification(vscode_languageserver_protocol_1.DidSaveNotebookDocumentNotification.type, (params) => {
                handler(params);
              });
            },
            onDidCloseNotebookDocument: (handler) => {
              return this.connection.onNotification(vscode_languageserver_protocol_1.DidCloseNotebookDocumentNotification.type, (params) => {
                handler(params);
              });
            }
          };
        }
      };
    };
    exports2.NotebookSyncFeature = NotebookSyncFeature;
    var CellTextDocumentConnection = class _CellTextDocumentConnection {
      onDidOpenTextDocument(handler) {
        this.openHandler = handler;
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          this.openHandler = void 0;
        });
      }
      openTextDocument(params) {
        this.openHandler && this.openHandler(params);
      }
      onDidChangeTextDocument(handler) {
        this.changeHandler = handler;
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          this.changeHandler = handler;
        });
      }
      changeTextDocument(params) {
        this.changeHandler && this.changeHandler(params);
      }
      onDidCloseTextDocument(handler) {
        this.closeHandler = handler;
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          this.closeHandler = void 0;
        });
      }
      closeTextDocument(params) {
        this.closeHandler && this.closeHandler(params);
      }
      onWillSaveTextDocument() {
        return _CellTextDocumentConnection.NULL_DISPOSE;
      }
      onWillSaveTextDocumentWaitUntil() {
        return _CellTextDocumentConnection.NULL_DISPOSE;
      }
      onDidSaveTextDocument() {
        return _CellTextDocumentConnection.NULL_DISPOSE;
      }
    };
    CellTextDocumentConnection.NULL_DISPOSE = Object.freeze({ dispose: () => {
    } });
    var NotebookDocuments = class {
      constructor(configurationOrTextDocuments) {
        if (configurationOrTextDocuments instanceof textDocuments_1.TextDocuments) {
          this._cellTextDocuments = configurationOrTextDocuments;
        } else {
          this._cellTextDocuments = new textDocuments_1.TextDocuments(configurationOrTextDocuments);
        }
        this.notebookDocuments = /* @__PURE__ */ new Map();
        this.notebookCellMap = /* @__PURE__ */ new Map();
        this._onDidOpen = new vscode_languageserver_protocol_1.Emitter();
        this._onDidChange = new vscode_languageserver_protocol_1.Emitter();
        this._onDidSave = new vscode_languageserver_protocol_1.Emitter();
        this._onDidClose = new vscode_languageserver_protocol_1.Emitter();
      }
      get cellTextDocuments() {
        return this._cellTextDocuments;
      }
      getCellTextDocument(cell) {
        return this._cellTextDocuments.get(cell.document);
      }
      getNotebookDocument(uri) {
        return this.notebookDocuments.get(uri);
      }
      getNotebookCell(uri) {
        const value = this.notebookCellMap.get(uri);
        return value && value[0];
      }
      findNotebookDocumentForCell(cell) {
        const key = typeof cell === "string" ? cell : cell.document;
        const value = this.notebookCellMap.get(key);
        return value && value[1];
      }
      get onDidOpen() {
        return this._onDidOpen.event;
      }
      get onDidSave() {
        return this._onDidSave.event;
      }
      get onDidChange() {
        return this._onDidChange.event;
      }
      get onDidClose() {
        return this._onDidClose.event;
      }
      /**
       * Listens for `low level` notification on the given connection to
       * update the notebook documents managed by this instance.
       *
       * Please note that the connection only provides handlers not an event model. Therefore
       * listening on a connection will overwrite the following handlers on a connection:
       * `onDidOpenNotebookDocument`, `onDidChangeNotebookDocument`, `onDidSaveNotebookDocument`,
       *  and `onDidCloseNotebookDocument`.
       *
       * @param connection The connection to listen on.
       */
      listen(connection2) {
        const cellTextDocumentConnection = new CellTextDocumentConnection();
        const disposables = [];
        disposables.push(this.cellTextDocuments.listen(cellTextDocumentConnection));
        disposables.push(connection2.notebooks.synchronization.onDidOpenNotebookDocument((params) => {
          this.notebookDocuments.set(params.notebookDocument.uri, params.notebookDocument);
          for (const cellTextDocument of params.cellTextDocuments) {
            cellTextDocumentConnection.openTextDocument({ textDocument: cellTextDocument });
          }
          this.updateCellMap(params.notebookDocument);
          this._onDidOpen.fire(params.notebookDocument);
        }));
        disposables.push(connection2.notebooks.synchronization.onDidChangeNotebookDocument((params) => {
          const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
          if (notebookDocument === void 0) {
            return;
          }
          notebookDocument.version = params.notebookDocument.version;
          const oldMetadata = notebookDocument.metadata;
          let metadataChanged = false;
          const change = params.change;
          if (change.metadata !== void 0) {
            metadataChanged = true;
            notebookDocument.metadata = change.metadata;
          }
          const opened = [];
          const closed = [];
          const data = [];
          const text = [];
          if (change.cells !== void 0) {
            const changedCells = change.cells;
            if (changedCells.structure !== void 0) {
              const array = changedCells.structure.array;
              notebookDocument.cells.splice(array.start, array.deleteCount, ...array.cells !== void 0 ? array.cells : []);
              if (changedCells.structure.didOpen !== void 0) {
                for (const open of changedCells.structure.didOpen) {
                  cellTextDocumentConnection.openTextDocument({ textDocument: open });
                  opened.push(open.uri);
                }
              }
              if (changedCells.structure.didClose) {
                for (const close of changedCells.structure.didClose) {
                  cellTextDocumentConnection.closeTextDocument({ textDocument: close });
                  closed.push(close.uri);
                }
              }
            }
            if (changedCells.data !== void 0) {
              const cellUpdates = new Map(changedCells.data.map((cell) => [cell.document, cell]));
              for (let i = 0; i <= notebookDocument.cells.length; i++) {
                const change2 = cellUpdates.get(notebookDocument.cells[i].document);
                if (change2 !== void 0) {
                  const old = notebookDocument.cells.splice(i, 1, change2);
                  data.push({ old: old[0], new: change2 });
                  cellUpdates.delete(change2.document);
                  if (cellUpdates.size === 0) {
                    break;
                  }
                }
              }
            }
            if (changedCells.textContent !== void 0) {
              for (const cellTextDocument of changedCells.textContent) {
                cellTextDocumentConnection.changeTextDocument({ textDocument: cellTextDocument.document, contentChanges: cellTextDocument.changes });
                text.push(cellTextDocument.document.uri);
              }
            }
          }
          this.updateCellMap(notebookDocument);
          const changeEvent = { notebookDocument };
          if (metadataChanged) {
            changeEvent.metadata = { old: oldMetadata, new: notebookDocument.metadata };
          }
          const added = [];
          for (const open of opened) {
            added.push(this.getNotebookCell(open));
          }
          const removed = [];
          for (const close of closed) {
            removed.push(this.getNotebookCell(close));
          }
          const textContent = [];
          for (const change2 of text) {
            textContent.push(this.getNotebookCell(change2));
          }
          if (added.length > 0 || removed.length > 0 || data.length > 0 || textContent.length > 0) {
            changeEvent.cells = { added, removed, changed: { data, textContent } };
          }
          if (changeEvent.metadata !== void 0 || changeEvent.cells !== void 0) {
            this._onDidChange.fire(changeEvent);
          }
        }));
        disposables.push(connection2.notebooks.synchronization.onDidSaveNotebookDocument((params) => {
          const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
          if (notebookDocument === void 0) {
            return;
          }
          this._onDidSave.fire(notebookDocument);
        }));
        disposables.push(connection2.notebooks.synchronization.onDidCloseNotebookDocument((params) => {
          const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
          if (notebookDocument === void 0) {
            return;
          }
          this._onDidClose.fire(notebookDocument);
          for (const cellTextDocument of params.cellTextDocuments) {
            cellTextDocumentConnection.closeTextDocument({ textDocument: cellTextDocument });
          }
          this.notebookDocuments.delete(params.notebookDocument.uri);
          for (const cell of notebookDocument.cells) {
            this.notebookCellMap.delete(cell.document);
          }
        }));
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          disposables.forEach((disposable) => disposable.dispose());
        });
      }
      updateCellMap(notebookDocument) {
        for (const cell of notebookDocument.cells) {
          this.notebookCellMap.set(cell.document, [cell, notebookDocument]);
        }
      }
    };
    exports2.NotebookDocuments = NotebookDocuments;
  }
});

// ../../node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/moniker.js
var require_moniker = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/moniker.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MonikerFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var MonikerFeature = (Base) => {
      return class extends Base {
        get moniker() {
          return {
            on: (handler) => {
              const type = vscode_languageserver_protocol_1.MonikerRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            }
          };
        }
      };
    };
    exports2.MonikerFeature = MonikerFeature;
  }
});

// ../../node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/server.js
var require_server = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/server.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createConnection = exports2.combineFeatures = exports2.combineNotebooksFeatures = exports2.combineLanguagesFeatures = exports2.combineWorkspaceFeatures = exports2.combineWindowFeatures = exports2.combineClientFeatures = exports2.combineTracerFeatures = exports2.combineTelemetryFeatures = exports2.combineConsoleFeatures = exports2._NotebooksImpl = exports2._LanguagesImpl = exports2.BulkUnregistration = exports2.BulkRegistration = exports2.ErrorMessageTracker = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var Is = require_is();
    var UUID = require_uuid();
    var progress_1 = require_progress();
    var configuration_1 = require_configuration();
    var workspaceFolder_1 = require_workspaceFolder();
    var callHierarchy_1 = require_callHierarchy();
    var semanticTokens_1 = require_semanticTokens();
    var showDocument_1 = require_showDocument();
    var fileOperations_1 = require_fileOperations();
    var linkedEditingRange_1 = require_linkedEditingRange();
    var typeHierarchy_1 = require_typeHierarchy();
    var inlineValue_1 = require_inlineValue();
    var foldingRange_1 = require_foldingRange();
    var inlayHint_1 = require_inlayHint();
    var diagnostic_1 = require_diagnostic();
    var notebook_1 = require_notebook();
    var moniker_1 = require_moniker();
    function null2Undefined(value) {
      if (value === null) {
        return void 0;
      }
      return value;
    }
    var ErrorMessageTracker = class {
      constructor() {
        this._messages = /* @__PURE__ */ Object.create(null);
      }
      /**
       * Add a message to the tracker.
       *
       * @param message The message to add.
       */
      add(message) {
        let count = this._messages[message];
        if (!count) {
          count = 0;
        }
        count++;
        this._messages[message] = count;
      }
      /**
       * Send all tracked messages to the connection's window.
       *
       * @param connection The connection established between client and server.
       */
      sendErrors(connection2) {
        Object.keys(this._messages).forEach((message) => {
          connection2.window.showErrorMessage(message);
        });
      }
    };
    exports2.ErrorMessageTracker = ErrorMessageTracker;
    var RemoteConsoleImpl = class {
      constructor() {
      }
      rawAttach(connection2) {
        this._rawConnection = connection2;
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      fillServerCapabilities(_capabilities) {
      }
      initialize(_capabilities) {
      }
      error(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Error, message);
      }
      warn(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Warning, message);
      }
      info(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Info, message);
      }
      log(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Log, message);
      }
      debug(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Debug, message);
      }
      send(type, message) {
        if (this._rawConnection) {
          this._rawConnection.sendNotification(vscode_languageserver_protocol_1.LogMessageNotification.type, { type, message }).catch(() => {
            (0, vscode_languageserver_protocol_1.RAL)().console.error(`Sending log message failed`);
          });
        }
      }
    };
    var _RemoteWindowImpl = class {
      constructor() {
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      showErrorMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Error, message, actions };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
      }
      showWarningMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Warning, message, actions };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
      }
      showInformationMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Info, message, actions };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
      }
    };
    var RemoteWindowImpl = (0, showDocument_1.ShowDocumentFeature)((0, progress_1.ProgressFeature)(_RemoteWindowImpl));
    var BulkRegistration;
    (function(BulkRegistration2) {
      function create() {
        return new BulkRegistrationImpl();
      }
      BulkRegistration2.create = create;
    })(BulkRegistration || (exports2.BulkRegistration = BulkRegistration = {}));
    var BulkRegistrationImpl = class {
      constructor() {
        this._registrations = [];
        this._registered = /* @__PURE__ */ new Set();
      }
      add(type, registerOptions) {
        const method = Is.string(type) ? type : type.method;
        if (this._registered.has(method)) {
          throw new Error(`${method} is already added to this registration`);
        }
        const id = UUID.generateUuid();
        this._registrations.push({
          id,
          method,
          registerOptions: registerOptions || {}
        });
        this._registered.add(method);
      }
      asRegistrationParams() {
        return {
          registrations: this._registrations
        };
      }
    };
    var BulkUnregistration;
    (function(BulkUnregistration2) {
      function create() {
        return new BulkUnregistrationImpl(void 0, []);
      }
      BulkUnregistration2.create = create;
    })(BulkUnregistration || (exports2.BulkUnregistration = BulkUnregistration = {}));
    var BulkUnregistrationImpl = class {
      constructor(_connection, unregistrations) {
        this._connection = _connection;
        this._unregistrations = /* @__PURE__ */ new Map();
        unregistrations.forEach((unregistration) => {
          this._unregistrations.set(unregistration.method, unregistration);
        });
      }
      get isAttached() {
        return !!this._connection;
      }
      attach(connection2) {
        this._connection = connection2;
      }
      add(unregistration) {
        this._unregistrations.set(unregistration.method, unregistration);
      }
      dispose() {
        let unregistrations = [];
        for (let unregistration of this._unregistrations.values()) {
          unregistrations.push(unregistration);
        }
        let params = {
          unregisterations: unregistrations
        };
        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).catch(() => {
          this._connection.console.info(`Bulk unregistration failed.`);
        });
      }
      disposeSingle(arg) {
        const method = Is.string(arg) ? arg : arg.method;
        const unregistration = this._unregistrations.get(method);
        if (!unregistration) {
          return false;
        }
        let params = {
          unregisterations: [unregistration]
        };
        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(() => {
          this._unregistrations.delete(method);
        }, (_error) => {
          this._connection.console.info(`Un-registering request handler for ${unregistration.id} failed.`);
        });
        return true;
      }
    };
    var RemoteClientImpl = class {
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      register(typeOrRegistrations, registerOptionsOrType, registerOptions) {
        if (typeOrRegistrations instanceof BulkRegistrationImpl) {
          return this.registerMany(typeOrRegistrations);
        } else if (typeOrRegistrations instanceof BulkUnregistrationImpl) {
          return this.registerSingle1(typeOrRegistrations, registerOptionsOrType, registerOptions);
        } else {
          return this.registerSingle2(typeOrRegistrations, registerOptionsOrType);
        }
      }
      registerSingle1(unregistration, type, registerOptions) {
        const method = Is.string(type) ? type : type.method;
        const id = UUID.generateUuid();
        let params = {
          registrations: [{ id, method, registerOptions: registerOptions || {} }]
        };
        if (!unregistration.isAttached) {
          unregistration.attach(this.connection);
        }
        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
          unregistration.add({ id, method });
          return unregistration;
        }, (_error) => {
          this.connection.console.info(`Registering request handler for ${method} failed.`);
          return Promise.reject(_error);
        });
      }
      registerSingle2(type, registerOptions) {
        const method = Is.string(type) ? type : type.method;
        const id = UUID.generateUuid();
        let params = {
          registrations: [{ id, method, registerOptions: registerOptions || {} }]
        };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
          return vscode_languageserver_protocol_1.Disposable.create(() => {
            this.unregisterSingle(id, method).catch(() => {
              this.connection.console.info(`Un-registering capability with id ${id} failed.`);
            });
          });
        }, (_error) => {
          this.connection.console.info(`Registering request handler for ${method} failed.`);
          return Promise.reject(_error);
        });
      }
      unregisterSingle(id, method) {
        let params = {
          unregisterations: [{ id, method }]
        };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).catch(() => {
          this.connection.console.info(`Un-registering request handler for ${id} failed.`);
        });
      }
      registerMany(registrations) {
        let params = registrations.asRegistrationParams();
        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then(() => {
          return new BulkUnregistrationImpl(this._connection, params.registrations.map((registration) => {
            return { id: registration.id, method: registration.method };
          }));
        }, (_error) => {
          this.connection.console.info(`Bulk registration failed.`);
          return Promise.reject(_error);
        });
      }
    };
    var _RemoteWorkspaceImpl = class {
      constructor() {
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      applyEdit(paramOrEdit) {
        function isApplyWorkspaceEditParams(value) {
          return value && !!value.edit;
        }
        let params = isApplyWorkspaceEditParams(paramOrEdit) ? paramOrEdit : { edit: paramOrEdit };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ApplyWorkspaceEditRequest.type, params);
      }
    };
    var RemoteWorkspaceImpl = (0, fileOperations_1.FileOperationsFeature)((0, workspaceFolder_1.WorkspaceFoldersFeature)((0, configuration_1.ConfigurationFeature)(_RemoteWorkspaceImpl)));
    var TracerImpl = class {
      constructor() {
        this._trace = vscode_languageserver_protocol_1.Trace.Off;
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      set trace(value) {
        this._trace = value;
      }
      log(message, verbose) {
        if (this._trace === vscode_languageserver_protocol_1.Trace.Off) {
          return;
        }
        this.connection.sendNotification(vscode_languageserver_protocol_1.LogTraceNotification.type, {
          message,
          verbose: this._trace === vscode_languageserver_protocol_1.Trace.Verbose ? verbose : void 0
        }).catch(() => {
        });
      }
    };
    var TelemetryImpl = class {
      constructor() {
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      logEvent(data) {
        this.connection.sendNotification(vscode_languageserver_protocol_1.TelemetryEventNotification.type, data).catch(() => {
          this.connection.console.log(`Sending TelemetryEventNotification failed`);
        });
      }
    };
    var _LanguagesImpl = class {
      constructor() {
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      attachWorkDoneProgress(params) {
        return (0, progress_1.attachWorkDone)(this.connection, params);
      }
      attachPartialResultProgress(_type, params) {
        return (0, progress_1.attachPartialResult)(this.connection, params);
      }
    };
    exports2._LanguagesImpl = _LanguagesImpl;
    var LanguagesImpl = (0, foldingRange_1.FoldingRangeFeature)((0, moniker_1.MonikerFeature)((0, diagnostic_1.DiagnosticFeature)((0, inlayHint_1.InlayHintFeature)((0, inlineValue_1.InlineValueFeature)((0, typeHierarchy_1.TypeHierarchyFeature)((0, linkedEditingRange_1.LinkedEditingRangeFeature)((0, semanticTokens_1.SemanticTokensFeature)((0, callHierarchy_1.CallHierarchyFeature)(_LanguagesImpl)))))))));
    var _NotebooksImpl = class {
      constructor() {
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      attachWorkDoneProgress(params) {
        return (0, progress_1.attachWorkDone)(this.connection, params);
      }
      attachPartialResultProgress(_type, params) {
        return (0, progress_1.attachPartialResult)(this.connection, params);
      }
    };
    exports2._NotebooksImpl = _NotebooksImpl;
    var NotebooksImpl = (0, notebook_1.NotebookSyncFeature)(_NotebooksImpl);
    function combineConsoleFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineConsoleFeatures = combineConsoleFeatures;
    function combineTelemetryFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineTelemetryFeatures = combineTelemetryFeatures;
    function combineTracerFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineTracerFeatures = combineTracerFeatures;
    function combineClientFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineClientFeatures = combineClientFeatures;
    function combineWindowFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineWindowFeatures = combineWindowFeatures;
    function combineWorkspaceFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineWorkspaceFeatures = combineWorkspaceFeatures;
    function combineLanguagesFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineLanguagesFeatures = combineLanguagesFeatures;
    function combineNotebooksFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineNotebooksFeatures = combineNotebooksFeatures;
    function combineFeatures(one, two) {
      function combine(one2, two2, func) {
        if (one2 && two2) {
          return func(one2, two2);
        } else if (one2) {
          return one2;
        } else {
          return two2;
        }
      }
      let result = {
        __brand: "features",
        console: combine(one.console, two.console, combineConsoleFeatures),
        tracer: combine(one.tracer, two.tracer, combineTracerFeatures),
        telemetry: combine(one.telemetry, two.telemetry, combineTelemetryFeatures),
        client: combine(one.client, two.client, combineClientFeatures),
        window: combine(one.window, two.window, combineWindowFeatures),
        workspace: combine(one.workspace, two.workspace, combineWorkspaceFeatures),
        languages: combine(one.languages, two.languages, combineLanguagesFeatures),
        notebooks: combine(one.notebooks, two.notebooks, combineNotebooksFeatures)
      };
      return result;
    }
    exports2.combineFeatures = combineFeatures;
    function createConnection2(connectionFactory, watchDog, factories) {
      const logger = factories && factories.console ? new (factories.console(RemoteConsoleImpl))() : new RemoteConsoleImpl();
      const connection2 = connectionFactory(logger);
      logger.rawAttach(connection2);
      const tracer = factories && factories.tracer ? new (factories.tracer(TracerImpl))() : new TracerImpl();
      const telemetry = factories && factories.telemetry ? new (factories.telemetry(TelemetryImpl))() : new TelemetryImpl();
      const client = factories && factories.client ? new (factories.client(RemoteClientImpl))() : new RemoteClientImpl();
      const remoteWindow = factories && factories.window ? new (factories.window(RemoteWindowImpl))() : new RemoteWindowImpl();
      const workspace = factories && factories.workspace ? new (factories.workspace(RemoteWorkspaceImpl))() : new RemoteWorkspaceImpl();
      const languages = factories && factories.languages ? new (factories.languages(LanguagesImpl))() : new LanguagesImpl();
      const notebooks = factories && factories.notebooks ? new (factories.notebooks(NotebooksImpl))() : new NotebooksImpl();
      const allRemotes = [logger, tracer, telemetry, client, remoteWindow, workspace, languages, notebooks];
      function asPromise(value) {
        if (value instanceof Promise) {
          return value;
        } else if (Is.thenable(value)) {
          return new Promise((resolve, reject) => {
            value.then((resolved) => resolve(resolved), (error) => reject(error));
          });
        } else {
          return Promise.resolve(value);
        }
      }
      let shutdownHandler = void 0;
      let initializeHandler = void 0;
      let exitHandler = void 0;
      let protocolConnection = {
        listen: () => connection2.listen(),
        sendRequest: (type, ...params) => connection2.sendRequest(Is.string(type) ? type : type.method, ...params),
        onRequest: (type, handler) => connection2.onRequest(type, handler),
        sendNotification: (type, param) => {
          const method = Is.string(type) ? type : type.method;
          return connection2.sendNotification(method, param);
        },
        onNotification: (type, handler) => connection2.onNotification(type, handler),
        onProgress: connection2.onProgress,
        sendProgress: connection2.sendProgress,
        onInitialize: (handler) => {
          initializeHandler = handler;
          return {
            dispose: () => {
              initializeHandler = void 0;
            }
          };
        },
        onInitialized: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.InitializedNotification.type, handler),
        onShutdown: (handler) => {
          shutdownHandler = handler;
          return {
            dispose: () => {
              shutdownHandler = void 0;
            }
          };
        },
        onExit: (handler) => {
          exitHandler = handler;
          return {
            dispose: () => {
              exitHandler = void 0;
            }
          };
        },
        get console() {
          return logger;
        },
        get telemetry() {
          return telemetry;
        },
        get tracer() {
          return tracer;
        },
        get client() {
          return client;
        },
        get window() {
          return remoteWindow;
        },
        get workspace() {
          return workspace;
        },
        get languages() {
          return languages;
        },
        get notebooks() {
          return notebooks;
        },
        onDidChangeConfiguration: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, handler),
        onDidChangeWatchedFiles: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type, handler),
        __textDocumentSync: void 0,
        onDidOpenTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, handler),
        onDidChangeTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, handler),
        onDidCloseTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, handler),
        onWillSaveTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type, handler),
        onWillSaveTextDocumentWaitUntil: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type, handler),
        onDidSaveTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, handler),
        sendDiagnostics: (params) => connection2.sendNotification(vscode_languageserver_protocol_1.PublishDiagnosticsNotification.type, params),
        onHover: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.HoverRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
        }),
        onCompletion: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CompletionRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onCompletionResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, handler),
        onSignatureHelp: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
        }),
        onDeclaration: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onDefinition: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onTypeDefinition: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onImplementation: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onReferences: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onDocumentHighlight: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onDocumentSymbol: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onWorkspaceSymbol: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onWorkspaceSymbolResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolResolveRequest.type, handler),
        onCodeAction: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onCodeActionResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CodeActionResolveRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onCodeLens: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onCodeLensResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onDocumentFormatting: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
        }),
        onDocumentRangeFormatting: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
        }),
        onDocumentOnTypeFormatting: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onRenameRequest: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.RenameRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
        }),
        onPrepareRename: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.PrepareRenameRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onDocumentLinks: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onDocumentLinkResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onDocumentColor: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onColorPresentation: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onFoldingRanges: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onSelectionRanges: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onExecuteCommand: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
        }),
        dispose: () => connection2.dispose()
      };
      for (let remote of allRemotes) {
        remote.attach(protocolConnection);
      }
      connection2.onRequest(vscode_languageserver_protocol_1.InitializeRequest.type, (params) => {
        watchDog.initialize(params);
        if (Is.string(params.trace)) {
          tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.trace);
        }
        for (let remote of allRemotes) {
          remote.initialize(params.capabilities);
        }
        if (initializeHandler) {
          let result = initializeHandler(params, new vscode_languageserver_protocol_1.CancellationTokenSource().token, (0, progress_1.attachWorkDone)(connection2, params), void 0);
          return asPromise(result).then((value) => {
            if (value instanceof vscode_languageserver_protocol_1.ResponseError) {
              return value;
            }
            let result2 = value;
            if (!result2) {
              result2 = { capabilities: {} };
            }
            let capabilities = result2.capabilities;
            if (!capabilities) {
              capabilities = {};
              result2.capabilities = capabilities;
            }
            if (capabilities.textDocumentSync === void 0 || capabilities.textDocumentSync === null) {
              capabilities.textDocumentSync = Is.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
            } else if (!Is.number(capabilities.textDocumentSync) && !Is.number(capabilities.textDocumentSync.change)) {
              capabilities.textDocumentSync.change = Is.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
            }
            for (let remote of allRemotes) {
              remote.fillServerCapabilities(capabilities);
            }
            return result2;
          });
        } else {
          let result = { capabilities: { textDocumentSync: vscode_languageserver_protocol_1.TextDocumentSyncKind.None } };
          for (let remote of allRemotes) {
            remote.fillServerCapabilities(result.capabilities);
          }
          return result;
        }
      });
      connection2.onRequest(vscode_languageserver_protocol_1.ShutdownRequest.type, () => {
        watchDog.shutdownReceived = true;
        if (shutdownHandler) {
          return shutdownHandler(new vscode_languageserver_protocol_1.CancellationTokenSource().token);
        } else {
          return void 0;
        }
      });
      connection2.onNotification(vscode_languageserver_protocol_1.ExitNotification.type, () => {
        try {
          if (exitHandler) {
            exitHandler();
          }
        } finally {
          if (watchDog.shutdownReceived) {
            watchDog.exit(0);
          } else {
            watchDog.exit(1);
          }
        }
      });
      connection2.onNotification(vscode_languageserver_protocol_1.SetTraceNotification.type, (params) => {
        tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.value);
      });
      return protocolConnection;
    }
    exports2.createConnection = createConnection2;
  }
});

// ../../node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/node/files.js
var require_files = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/node/files.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveModulePath = exports2.FileSystem = exports2.resolveGlobalYarnPath = exports2.resolveGlobalNodePath = exports2.resolve = exports2.uriToFilePath = void 0;
    var url = require("url");
    var path2 = require("path");
    var fs = require("fs");
    var child_process_1 = require("child_process");
    function uriToFilePath(uri) {
      let parsed = url.parse(uri);
      if (parsed.protocol !== "file:" || !parsed.path) {
        return void 0;
      }
      let segments = parsed.path.split("/");
      for (var i = 0, len = segments.length; i < len; i++) {
        segments[i] = decodeURIComponent(segments[i]);
      }
      if (process.platform === "win32" && segments.length > 1) {
        let first = segments[0];
        let second = segments[1];
        if (first.length === 0 && second.length > 1 && second[1] === ":") {
          segments.shift();
        }
      }
      return path2.normalize(segments.join("/"));
    }
    exports2.uriToFilePath = uriToFilePath;
    function isWindows() {
      return process.platform === "win32";
    }
    function resolve(moduleName, nodePath, cwd, tracer) {
      const nodePathKey = "NODE_PATH";
      const app = [
        "var p = process;",
        "p.on('message',function(m){",
        "if(m.c==='e'){",
        "p.exit(0);",
        "}",
        "else if(m.c==='rs'){",
        "try{",
        "var r=require.resolve(m.a);",
        "p.send({c:'r',s:true,r:r});",
        "}",
        "catch(err){",
        "p.send({c:'r',s:false});",
        "}",
        "}",
        "});"
      ].join("");
      return new Promise((resolve2, reject) => {
        let env = process.env;
        let newEnv = /* @__PURE__ */ Object.create(null);
        Object.keys(env).forEach((key) => newEnv[key] = env[key]);
        if (nodePath && fs.existsSync(nodePath)) {
          if (newEnv[nodePathKey]) {
            newEnv[nodePathKey] = nodePath + path2.delimiter + newEnv[nodePathKey];
          } else {
            newEnv[nodePathKey] = nodePath;
          }
          if (tracer) {
            tracer(`NODE_PATH value is: ${newEnv[nodePathKey]}`);
          }
        }
        newEnv["ELECTRON_RUN_AS_NODE"] = "1";
        try {
          let cp = (0, child_process_1.fork)("", [], {
            cwd,
            env: newEnv,
            execArgv: ["-e", app]
          });
          if (cp.pid === void 0) {
            reject(new Error(`Starting process to resolve node module  ${moduleName} failed`));
            return;
          }
          cp.on("error", (error) => {
            reject(error);
          });
          cp.on("message", (message2) => {
            if (message2.c === "r") {
              cp.send({ c: "e" });
              if (message2.s) {
                resolve2(message2.r);
              } else {
                reject(new Error(`Failed to resolve module: ${moduleName}`));
              }
            }
          });
          let message = {
            c: "rs",
            a: moduleName
          };
          cp.send(message);
        } catch (error) {
          reject(error);
        }
      });
    }
    exports2.resolve = resolve;
    function resolveGlobalNodePath(tracer) {
      let npmCommand = "npm";
      const env = /* @__PURE__ */ Object.create(null);
      Object.keys(process.env).forEach((key) => env[key] = process.env[key]);
      env["NO_UPDATE_NOTIFIER"] = "true";
      const options = {
        encoding: "utf8",
        env
      };
      if (isWindows()) {
        npmCommand = "npm.cmd";
        options.shell = true;
      }
      let handler = () => {
      };
      try {
        process.on("SIGPIPE", handler);
        let stdout = (0, child_process_1.spawnSync)(npmCommand, ["config", "get", "prefix"], options).stdout;
        if (!stdout) {
          if (tracer) {
            tracer(`'npm config get prefix' didn't return a value.`);
          }
          return void 0;
        }
        let prefix = stdout.trim();
        if (tracer) {
          tracer(`'npm config get prefix' value is: ${prefix}`);
        }
        if (prefix.length > 0) {
          if (isWindows()) {
            return path2.join(prefix, "node_modules");
          } else {
            return path2.join(prefix, "lib", "node_modules");
          }
        }
        return void 0;
      } catch (err) {
        return void 0;
      } finally {
        process.removeListener("SIGPIPE", handler);
      }
    }
    exports2.resolveGlobalNodePath = resolveGlobalNodePath;
    function resolveGlobalYarnPath(tracer) {
      let yarnCommand = "yarn";
      let options = {
        encoding: "utf8"
      };
      if (isWindows()) {
        yarnCommand = "yarn.cmd";
        options.shell = true;
      }
      let handler = () => {
      };
      try {
        process.on("SIGPIPE", handler);
        let results = (0, child_process_1.spawnSync)(yarnCommand, ["global", "dir", "--json"], options);
        let stdout = results.stdout;
        if (!stdout) {
          if (tracer) {
            tracer(`'yarn global dir' didn't return a value.`);
            if (results.stderr) {
              tracer(results.stderr);
            }
          }
          return void 0;
        }
        let lines = stdout.trim().split(/\r?\n/);
        for (let line of lines) {
          try {
            let yarn = JSON.parse(line);
            if (yarn.type === "log") {
              return path2.join(yarn.data, "node_modules");
            }
          } catch (e) {
          }
        }
        return void 0;
      } catch (err) {
        return void 0;
      } finally {
        process.removeListener("SIGPIPE", handler);
      }
    }
    exports2.resolveGlobalYarnPath = resolveGlobalYarnPath;
    var FileSystem;
    (function(FileSystem2) {
      let _isCaseSensitive = void 0;
      function isCaseSensitive() {
        if (_isCaseSensitive !== void 0) {
          return _isCaseSensitive;
        }
        if (process.platform === "win32") {
          _isCaseSensitive = false;
        } else {
          _isCaseSensitive = !fs.existsSync(__filename.toUpperCase()) || !fs.existsSync(__filename.toLowerCase());
        }
        return _isCaseSensitive;
      }
      FileSystem2.isCaseSensitive = isCaseSensitive;
      function isParent(parent, child) {
        if (isCaseSensitive()) {
          return path2.normalize(child).indexOf(path2.normalize(parent)) === 0;
        } else {
          return path2.normalize(child).toLowerCase().indexOf(path2.normalize(parent).toLowerCase()) === 0;
        }
      }
      FileSystem2.isParent = isParent;
    })(FileSystem || (exports2.FileSystem = FileSystem = {}));
    function resolveModulePath(workspaceRoot, moduleName, nodePath, tracer) {
      if (nodePath) {
        if (!path2.isAbsolute(nodePath)) {
          nodePath = path2.join(workspaceRoot, nodePath);
        }
        return resolve(moduleName, nodePath, nodePath, tracer).then((value) => {
          if (FileSystem.isParent(nodePath, value)) {
            return value;
          } else {
            return Promise.reject(new Error(`Failed to load ${moduleName} from node path location.`));
          }
        }).then(void 0, (_error) => {
          return resolve(moduleName, resolveGlobalNodePath(tracer), workspaceRoot, tracer);
        });
      } else {
        return resolve(moduleName, resolveGlobalNodePath(tracer), workspaceRoot, tracer);
      }
    }
    exports2.resolveModulePath = resolveModulePath;
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/node.js
var require_node2 = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/node.js"(exports2, module2) {
    "use strict";
    init_importMeta();
    module2.exports = require_main3();
  }
});

// ../../node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/inlineCompletion.proposed.js
var require_inlineCompletion_proposed = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/inlineCompletion.proposed.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlineCompletionFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var InlineCompletionFeature = (Base) => {
      return class extends Base {
        get inlineCompletion() {
          return {
            on: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.InlineCompletionRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params));
              });
            }
          };
        }
      };
    };
    exports2.InlineCompletionFeature = InlineCompletionFeature;
  }
});

// ../../node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/api.js
var require_api3 = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/api.js"(exports2) {
    "use strict";
    init_importMeta();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProposedFeatures = exports2.NotebookDocuments = exports2.TextDocuments = exports2.SemanticTokensBuilder = void 0;
    var semanticTokens_1 = require_semanticTokens();
    Object.defineProperty(exports2, "SemanticTokensBuilder", { enumerable: true, get: function() {
      return semanticTokens_1.SemanticTokensBuilder;
    } });
    var ic = require_inlineCompletion_proposed();
    __exportStar(require_main3(), exports2);
    var textDocuments_1 = require_textDocuments();
    Object.defineProperty(exports2, "TextDocuments", { enumerable: true, get: function() {
      return textDocuments_1.TextDocuments;
    } });
    var notebook_1 = require_notebook();
    Object.defineProperty(exports2, "NotebookDocuments", { enumerable: true, get: function() {
      return notebook_1.NotebookDocuments;
    } });
    __exportStar(require_server(), exports2);
    var ProposedFeatures2;
    (function(ProposedFeatures3) {
      ProposedFeatures3.all = {
        __brand: "features",
        languages: ic.InlineCompletionFeature
      };
    })(ProposedFeatures2 || (exports2.ProposedFeatures = ProposedFeatures2 = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/node/main.js
var require_main4 = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/node/main.js"(exports2) {
    "use strict";
    init_importMeta();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createConnection = exports2.Files = void 0;
    var node_util_1 = require("node:util");
    var Is = require_is();
    var server_1 = require_server();
    var fm = require_files();
    var node_1 = require_node2();
    __exportStar(require_node2(), exports2);
    __exportStar(require_api3(), exports2);
    var Files;
    (function(Files2) {
      Files2.uriToFilePath = fm.uriToFilePath;
      Files2.resolveGlobalNodePath = fm.resolveGlobalNodePath;
      Files2.resolveGlobalYarnPath = fm.resolveGlobalYarnPath;
      Files2.resolve = fm.resolve;
      Files2.resolveModulePath = fm.resolveModulePath;
    })(Files || (exports2.Files = Files = {}));
    var _protocolConnection;
    function endProtocolConnection() {
      if (_protocolConnection === void 0) {
        return;
      }
      try {
        _protocolConnection.end();
      } catch (_err) {
      }
    }
    var _shutdownReceived = false;
    var exitTimer = void 0;
    function setupExitTimer() {
      const argName = "--clientProcessId";
      function runTimer(value) {
        try {
          let processId = parseInt(value);
          if (!isNaN(processId)) {
            exitTimer = setInterval(() => {
              try {
                process.kill(processId, 0);
              } catch (ex) {
                endProtocolConnection();
                process.exit(_shutdownReceived ? 0 : 1);
              }
            }, 3e3);
          }
        } catch (e) {
        }
      }
      for (let i = 2; i < process.argv.length; i++) {
        let arg = process.argv[i];
        if (arg === argName && i + 1 < process.argv.length) {
          runTimer(process.argv[i + 1]);
          return;
        } else {
          let args = arg.split("=");
          if (args[0] === argName) {
            runTimer(args[1]);
          }
        }
      }
    }
    setupExitTimer();
    var watchDog = {
      initialize: (params) => {
        const processId = params.processId;
        if (Is.number(processId) && exitTimer === void 0) {
          setInterval(() => {
            try {
              process.kill(processId, 0);
            } catch (ex) {
              process.exit(_shutdownReceived ? 0 : 1);
            }
          }, 3e3);
        }
      },
      get shutdownReceived() {
        return _shutdownReceived;
      },
      set shutdownReceived(value) {
        _shutdownReceived = value;
      },
      exit: (code) => {
        endProtocolConnection();
        process.exit(code);
      }
    };
    function createConnection2(arg1, arg2, arg3, arg4) {
      let factories;
      let input;
      let output;
      let options;
      if (arg1 !== void 0 && arg1.__brand === "features") {
        factories = arg1;
        arg1 = arg2;
        arg2 = arg3;
        arg3 = arg4;
      }
      if (node_1.ConnectionStrategy.is(arg1) || node_1.ConnectionOptions.is(arg1)) {
        options = arg1;
      } else {
        input = arg1;
        output = arg2;
        options = arg3;
      }
      return _createConnection(input, output, options, factories);
    }
    exports2.createConnection = createConnection2;
    function _createConnection(input, output, options, factories) {
      let stdio = false;
      if (!input && !output && process.argv.length > 2) {
        let port = void 0;
        let pipeName = void 0;
        let argv = process.argv.slice(2);
        for (let i = 0; i < argv.length; i++) {
          let arg = argv[i];
          if (arg === "--node-ipc") {
            input = new node_1.IPCMessageReader(process);
            output = new node_1.IPCMessageWriter(process);
            break;
          } else if (arg === "--stdio") {
            stdio = true;
            input = process.stdin;
            output = process.stdout;
            break;
          } else if (arg === "--socket") {
            port = parseInt(argv[i + 1]);
            break;
          } else if (arg === "--pipe") {
            pipeName = argv[i + 1];
            break;
          } else {
            var args = arg.split("=");
            if (args[0] === "--socket") {
              port = parseInt(args[1]);
              break;
            } else if (args[0] === "--pipe") {
              pipeName = args[1];
              break;
            }
          }
        }
        if (port) {
          let transport = (0, node_1.createServerSocketTransport)(port);
          input = transport[0];
          output = transport[1];
        } else if (pipeName) {
          let transport = (0, node_1.createServerPipeTransport)(pipeName);
          input = transport[0];
          output = transport[1];
        }
      }
      var commandLineMessage = "Use arguments of createConnection or set command line parameters: '--node-ipc', '--stdio' or '--socket={number}'";
      if (!input) {
        throw new Error("Connection input stream is not set. " + commandLineMessage);
      }
      if (!output) {
        throw new Error("Connection output stream is not set. " + commandLineMessage);
      }
      if (Is.func(input.read) && Is.func(input.on)) {
        let inputStream = input;
        inputStream.on("end", () => {
          endProtocolConnection();
          process.exit(_shutdownReceived ? 0 : 1);
        });
        inputStream.on("close", () => {
          endProtocolConnection();
          process.exit(_shutdownReceived ? 0 : 1);
        });
      }
      const connectionFactory = (logger) => {
        const result = (0, node_1.createProtocolConnection)(input, output, logger, options);
        if (stdio) {
          patchConsole(logger);
        }
        return result;
      };
      return (0, server_1.createConnection)(connectionFactory, watchDog, factories);
    }
    function patchConsole(logger) {
      function serialize(args) {
        return args.map((arg) => typeof arg === "string" ? arg : (0, node_util_1.inspect)(arg)).join(" ");
      }
      const counters = /* @__PURE__ */ new Map();
      console.assert = function assert(assertion, ...args) {
        if (assertion) {
          return;
        }
        if (args.length === 0) {
          logger.error("Assertion failed");
        } else {
          const [message, ...rest] = args;
          logger.error(`Assertion failed: ${message} ${serialize(rest)}`);
        }
      };
      console.count = function count(label = "default") {
        const message = String(label);
        let counter = counters.get(message) ?? 0;
        counter += 1;
        counters.set(message, counter);
        logger.log(`${message}: ${message}`);
      };
      console.countReset = function countReset(label) {
        if (label === void 0) {
          counters.clear();
        } else {
          counters.delete(String(label));
        }
      };
      console.debug = function debug(...args) {
        logger.log(serialize(args));
      };
      console.dir = function dir(arg, options) {
        logger.log((0, node_util_1.inspect)(arg, options));
      };
      console.log = function log(...args) {
        logger.log(serialize(args));
      };
      console.error = function error(...args) {
        logger.error(serialize(args));
      };
      console.trace = function trace(...args) {
        const stack = new Error().stack.replace(/(.+\n){2}/, "");
        let message = "Trace";
        if (args.length !== 0) {
          message += `: ${serialize(args)}`;
        }
        logger.log(`${message}
${stack}`);
      };
      console.warn = function warn(...args) {
        logger.warn(serialize(args));
      };
    }
  }
});

// ../../node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/node.js
var require_node3 = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/node.js"(exports2, module2) {
    "use strict";
    init_importMeta();
    module2.exports = require_main4();
  }
});

// ../../node_modules/.pnpm/balanced-match@1.0.2/node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "../../node_modules/.pnpm/balanced-match@1.0.2/node_modules/balanced-match/index.js"(exports2, module2) {
    "use strict";
    init_importMeta();
    module2.exports = balanced;
    function balanced(a, b, str) {
      if (a instanceof RegExp) a = maybeMatch(a, str);
      if (b instanceof RegExp) b = maybeMatch(b, str);
      var r = range(a, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range;
    function range(a, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i = ai;
      if (ai >= 0 && bi > 0) {
        if (a === b) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i >= 0 && !result) {
          if (i == ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// ../../node_modules/.pnpm/brace-expansion@2.0.1/node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "../../node_modules/.pnpm/brace-expansion@2.0.1/node_modules/brace-expansion/index.js"(exports2, module2) {
    init_importMeta();
    var balanced = require_balanced_match();
    module2.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand2(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand2(str, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str);
      if (!m) return [str];
      var pre = m.pre;
      var post = m.post.length ? expand2(m.post, false) : [""];
      if (/\$$/.test(m.pre)) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + "{" + m.body + "}" + post[k];
          expansions.push(expansion);
        }
      } else {
        var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
        var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
        var isSequence = isNumericSequence || isAlphaSequence;
        var isOptions = m.body.indexOf(",") >= 0;
        if (!isSequence && !isOptions) {
          if (m.post.match(/,.*\}/)) {
            str = m.pre + "{" + m.body + escClose + m.post;
            return expand2(str);
          }
          return [str];
        }
        var n;
        if (isSequence) {
          n = m.body.split(/\.\./);
        } else {
          n = parseCommaParts(m.body);
          if (n.length === 1) {
            n = expand2(n[0], false).map(embrace);
            if (n.length === 1) {
              return post.map(function(p) {
                return m.pre + n[0] + p;
              });
            }
          }
        }
        var N;
        if (isSequence) {
          var x = numeric(n[0]);
          var y = numeric(n[1]);
          var width = Math.max(n[0].length, n[1].length);
          var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
          var test = lte;
          var reverse = y < x;
          if (reverse) {
            incr *= -1;
            test = gte;
          }
          var pad = n.some(isPadded);
          N = [];
          for (var i = x; test(i, y); i += incr) {
            var c;
            if (isAlphaSequence) {
              c = String.fromCharCode(i);
              if (c === "\\")
                c = "";
            } else {
              c = String(i);
              if (pad) {
                var need = width - c.length;
                if (need > 0) {
                  var z = new Array(need + 1).join("0");
                  if (i < 0)
                    c = "-" + z + c.slice(1);
                  else
                    c = z + c;
                }
              }
            }
            N.push(c);
          }
        } else {
          N = [];
          for (var j = 0; j < n.length; j++) {
            N.push.apply(N, expand2(n[j], false));
          }
        }
        for (var j = 0; j < N.length; j++) {
          for (var k = 0; k < post.length; k++) {
            var expansion = pre + N[j] + post[k];
            if (!isTop || isSequence || expansion)
              expansions.push(expansion);
          }
        }
      }
      return expansions;
    }
  }
});

// ../../../sonata-api/packages/compiler/dist/ast.js
var require_ast = __commonJS({
  "../../../sonata-api/packages/compiler/dist/ast.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PropertyModifiers = exports2.PropertyType = exports2.LOCATION_SYMBOL = void 0;
    exports2.LOCATION_SYMBOL = Symbol();
    exports2.PropertyType = {
      str: "string",
      int: "integer",
      num: "number",
      bool: "boolean",
      enum: "enum",
      date: "string",
      datetime: "string",
      const: "const"
    };
    exports2.PropertyModifiers = {
      Error: {
        packageName: "aeria",
        symbolName: "errorSchema"
      },
      Result: {
        packageName: "aeria",
        symbolName: "resultSchema"
      }
    };
  }
});

// ../../../sonata-api/packages/compiler/dist/diagnostic.js
var require_diagnostic2 = __commonJS({
  "../../../sonata-api/packages/compiler/dist/diagnostic.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Diagnostic = void 0;
    var emptyLocation = {
      file: "",
      index: 0,
      line: 0,
      start: 0,
      end: 0
    };
    var Diagnostic = class extends Error {
      message;
      location;
      constructor(message, location = emptyLocation) {
        super();
        this.message = message;
        this.location = location;
        if (process.env.NODE_ENV === "debug") {
          console.error(message, location);
        }
      }
    };
    exports2.Diagnostic = Diagnostic;
  }
});

// ../../../sonata-api/packages/compiler/dist/token.js
var require_token = __commonJS({
  "../../../sonata-api/packages/compiler/dist/token.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TokenType = void 0;
    exports2.TokenType = {
      LineBreak: "LINE_BREAK",
      Comment: "COMMENT",
      LeftBracket: "LEFT_BRACKET",
      RightBracket: "RIGHT_BRACKET",
      LeftParens: "LEFT_PARENS",
      RightParens: "RIGHT_PARENS",
      LeftSquareBracket: "LEFT_SQUARE_BRACKET",
      RightSquareBracket: "RIGHT_SQUARE_BRACKET",
      Pipe: "PIPE",
      Comma: "COMMA",
      Dot: "DOT",
      Number: "NUMBER",
      Boolean: "BOOLEAN",
      Null: "NULL",
      Keyword: "KEYWORD",
      Identifier: "IDENTIFIER",
      QuotedString: "QUOTED_STRING",
      AttributeName: "ATTRIBUTE_NAME",
      MacroName: "MACRO_NAME",
      Range: "RANGE",
      Operator: "OPERATOR"
    };
  }
});

// ../../../sonata-api/packages/compiler/dist/lexer.js
var require_lexer = __commonJS({
  "../../../sonata-api/packages/compiler/dist/lexer.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.tokenize = exports2.LOGICAL_OPERATORS = exports2.FINAL_OPERATORS = exports2.KEYWORDS = exports2.MISC_KEYWORDS = exports2.TOPLEVEL_KEYWORDS = exports2.CONTRACT_KEYWORDS = exports2.COLLECTION_FORM_LAYOUT_KEYWORDS = exports2.COLLECTION_LAYOUT_OPTIONS_KEYWORDS = exports2.COLLECTION_LAYOUT_KEYWORDS = exports2.COLLECTION_SEARCH_KEYWORDS = exports2.COLLECTION_ACTIONS_KEYWORDS = exports2.COLLECTION_KEYWORDS = void 0;
    var token_js_1 = require_token();
    var diagnostic_js_1 = require_diagnostic2();
    exports2.COLLECTION_KEYWORDS = [
      "actions",
      "additionalProperties",
      "filters",
      "form",
      "formLayout",
      "functions",
      "icon",
      "indexes",
      "individualActions",
      "layout",
      "middlewares",
      "owned",
      "presets",
      "properties",
      "required",
      "search",
      "table",
      "tableMeta"
    ];
    exports2.COLLECTION_ACTIONS_KEYWORDS = [
      "ask",
      "button",
      "clearItem",
      "effect",
      "event",
      "fetchItem",
      "function",
      "icon",
      "label",
      "params",
      "query",
      "requires",
      "roles",
      "route",
      "selection",
      "setItem",
      "translate"
    ];
    exports2.COLLECTION_SEARCH_KEYWORDS = [
      "indexes",
      "placeholder",
      "exactMatches"
    ];
    exports2.COLLECTION_LAYOUT_KEYWORDS = [
      "name",
      "options"
    ];
    exports2.COLLECTION_LAYOUT_OPTIONS_KEYWORDS = [
      "title",
      "picture",
      "badge",
      "information",
      "active",
      "translateBadge"
    ];
    exports2.COLLECTION_FORM_LAYOUT_KEYWORDS = [
      "fields",
      "if",
      "span",
      "verticalSpacing",
      "separator"
    ];
    exports2.CONTRACT_KEYWORDS = [
      "roles",
      "payload",
      "query",
      "response"
    ];
    exports2.TOPLEVEL_KEYWORDS = [
      "collection",
      "contract",
      "functionset"
    ];
    exports2.MISC_KEYWORDS = ["extends"];
    exports2.KEYWORDS = [].concat(exports2.COLLECTION_KEYWORDS, exports2.COLLECTION_ACTIONS_KEYWORDS, exports2.COLLECTION_SEARCH_KEYWORDS, exports2.COLLECTION_LAYOUT_KEYWORDS, exports2.COLLECTION_LAYOUT_OPTIONS_KEYWORDS, exports2.COLLECTION_FORM_LAYOUT_KEYWORDS, exports2.CONTRACT_KEYWORDS, exports2.TOPLEVEL_KEYWORDS, exports2.MISC_KEYWORDS);
    exports2.FINAL_OPERATORS = [
      "==",
      "in",
      ">=",
      "<=",
      ">",
      "<",
      "!"
    ];
    exports2.LOGICAL_OPERATORS = [
      "&&",
      "||"
    ];
    var keywordsSet = /* @__PURE__ */ new Set();
    for (const keyword of exports2.KEYWORDS) {
      keywordsSet.add(keyword);
    }
    var TOKENS = [
      {
        type: null,
        matcher: /\r?[ \t]+/
      },
      {
        type: token_js_1.TokenType.LineBreak,
        matcher: "\n"
      },
      {
        type: token_js_1.TokenType.Comment,
        matcher: "//"
      },
      {
        type: token_js_1.TokenType.LeftBracket,
        matcher: "{"
      },
      {
        type: token_js_1.TokenType.RightBracket,
        matcher: "}"
      },
      {
        type: token_js_1.TokenType.LeftParens,
        matcher: "("
      },
      {
        type: token_js_1.TokenType.RightParens,
        matcher: ")"
      },
      {
        type: token_js_1.TokenType.LeftSquareBracket,
        matcher: "["
      },
      {
        type: token_js_1.TokenType.RightSquareBracket,
        matcher: "]"
      },
      {
        type: token_js_1.TokenType.Operator,
        matcher: [].concat(exports2.FINAL_OPERATORS, exports2.LOGICAL_OPERATORS)
      },
      {
        type: token_js_1.TokenType.Pipe,
        matcher: "|"
      },
      {
        type: token_js_1.TokenType.Comma,
        matcher: ","
      },
      {
        type: token_js_1.TokenType.Range,
        matcher: /(\d+\.\.\d*|\d*\.\.\d+)/g,
        valueExtractor: (value) => {
          const [, left, right] = value.match(/(\d*)\.\.(\d*)/);
          return [
            parseInt(left),
            parseInt(right)
          ];
        }
      },
      {
        type: token_js_1.TokenType.Dot,
        matcher: "."
      },
      {
        type: token_js_1.TokenType.Number,
        matcher: /[0-9]+(\.[0-9]+)?/,
        construct: Number
      },
      {
        type: token_js_1.TokenType.Boolean,
        matcher: [
          "true",
          "false"
        ],
        construct: Boolean
      },
      {
        type: token_js_1.TokenType.Keyword,
        matcher: Array.from(keywordsSet),
        condition: (state, lastToken) => {
          if (state.variableScopeStack.at(-1) || state.variableExpressionStack.at(-1)) {
            return false;
          }
          if (lastToken && lastToken.type === token_js_1.TokenType.Keyword) {
            switch (lastToken.value) {
              case "if":
              case "badge":
              case "title": {
                return false;
              }
            }
          }
          return true;
        }
      },
      {
        type: token_js_1.TokenType.MacroName,
        matcher: /[a-zA-Z]([a-zA-Z0-9]|_)+\(/,
        valueExtractor: (value) => value.slice(0, -1)
      },
      {
        type: token_js_1.TokenType.Identifier,
        matcher: /([a-zA-Z0-9]|_)+/
      },
      {
        type: token_js_1.TokenType.QuotedString,
        matcher: /"([^"]+)"/,
        valueExtractor: (value) => value.slice(1, -1)
      },
      {
        type: token_js_1.TokenType.AttributeName,
        matcher: /@[a-zA-Z0-9]+/,
        valueExtractor: (value) => value.slice(1)
      }
    ];
    var tokenize = function(rawInput, fileLocation) {
      const input = rawInput.replace(/\r\n/g, "\n");
      let index = 0, line = 1, start = 0, end = 0;
      const tokens = [];
      const errors = [];
      const state = {
        variableScopeStack: [],
        variableExpressionStack: []
      };
      while (index < input.length) {
        let hasMatch = false;
        for (const { type, matcher, valueExtractor, construct, condition } of TOKENS) {
          let value;
          let token;
          const lastToken = tokens.at(-1);
          if (condition) {
            if (!condition(state, lastToken)) {
              continue;
            }
          }
          if (typeof matcher === "string") {
            if (input.slice(index).startsWith(matcher)) {
              value = matcher;
            }
          } else if (matcher instanceof RegExp) {
            const currentMatcher = new RegExp(matcher.source, "y");
            currentMatcher.lastIndex = index;
            const matched = currentMatcher.exec(input);
            if (matched) {
              [value] = matched;
            }
          } else {
            const segment = input.slice(index, index + input.slice(index).search(/[ \t\n\{\}\(\)\[\]]/));
            if (segment && matcher.includes(segment)) {
              value = segment;
            }
          }
          if (value) {
            let tokenValue;
            const location = {
              file: fileLocation,
              index: index += value.length,
              line,
              end: end += value.length,
              start: start = end - value.length
            };
            switch (type) {
              case null:
                break;
              case token_js_1.TokenType.LineBreak:
                line++;
                end = 0;
                start = 0;
                break;
              case token_js_1.TokenType.Comment: {
                while (input[index++] !== "\n") {
                }
                line++;
                break;
              }
              default: {
                if (valueExtractor) {
                  tokenValue = construct ? construct(valueExtractor(value)) : valueExtractor(value);
                } else {
                  tokenValue = construct ? construct(value) : value;
                }
                token = {
                  type,
                  location,
                  value: tokenValue
                };
                switch (type) {
                  case token_js_1.TokenType.LeftBracket: {
                    let variableScope = false;
                    if (lastToken && lastToken.type === token_js_1.TokenType.Keyword) {
                      switch (lastToken.value) {
                        case "fields":
                        case "information":
                        case "form":
                        case "table":
                        case "tableMeta":
                        case "indexes":
                        case "filters":
                        case "writable":
                        case "required":
                        case "properties": {
                          variableScope = true;
                          break;
                        }
                      }
                    }
                    state.variableScopeStack.push(variableScope);
                    break;
                  }
                  case token_js_1.TokenType.LeftParens: {
                    let variableExpression = false;
                    if (lastToken) {
                      switch (lastToken.type) {
                        case token_js_1.TokenType.Keyword: {
                          switch (lastToken.value) {
                            case "if": {
                              variableExpression = true;
                              break;
                            }
                          }
                          break;
                        }
                        case token_js_1.TokenType.Operator: {
                          variableExpression = true;
                          break;
                        }
                      }
                    }
                    state.variableExpressionStack.push(variableExpression);
                    break;
                  }
                  case token_js_1.TokenType.RightBracket: {
                    if (state.variableScopeStack.length > 0) {
                      state.variableScopeStack.pop();
                    }
                    break;
                  }
                  case token_js_1.TokenType.RightParens: {
                    if (state.variableExpressionStack.length > 0) {
                      state.variableExpressionStack.pop();
                    }
                    break;
                  }
                }
                tokens.push(token);
              }
            }
            hasMatch = true;
          }
        }
        if (!hasMatch) {
          index += input.slice(index).search(/[ \t\n\{\}\(\)\[\]]/);
          errors.push(new diagnostic_js_1.Diagnostic("unexpected token", {
            file: fileLocation,
            index,
            line,
            start,
            end
          }));
        }
      }
      return {
        tokens,
        errors
      };
    };
    exports2.tokenize = tokenize;
  }
});

// ../../../sonata-api/packages/types/dist/accessControl.js
var require_accessControl = __commonJS({
  "../../../sonata-api/packages/types/dist/accessControl.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ACError = void 0;
    exports2.ACError = {
      AuthenticationError: "AUTHENTICATION_ERROR",
      AuthorizationError: "AUTHORIZATION_ERROR",
      FunctionNotFound: "FUNCTION_NOT_FOUND",
      FunctionNotExposed: "FUNCTION_NOT_EXPOSED",
      TargetImmutable: "TARGET_IMMUTABLE",
      InvalidLimit: "INVALID_LIMIT",
      InvalidToken: "INVALID_TOKEN",
      OwnershipError: "OWNERSHIP_ERROR",
      ResourceNotFound: "RESOURCE_NOT_FOUND",
      InsecureOperator: "INSECURE_OPERATOR",
      MalformedInput: "MALFORMED_INPUT",
      UniquenessViolated: "UNIQUENESS_VIOLATED",
      UnknownError: "UNKNOWN_ERROR"
    };
  }
});

// ../../../sonata-api/packages/types/dist/http.js
var require_http = __commonJS({
  "../../../sonata-api/packages/types/dist/http.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.STREAMED_RESPONSE = exports2.HTTPStatus = exports2.METHOD_COLORS = exports2.REQUEST_METHODS = void 0;
    exports2.REQUEST_METHODS = [
      "GET",
      "HEAD",
      "POST",
      "PUT",
      "DELETE",
      "OPTIONS",
      "PATCH",
      "TRACE",
      "SEARCH"
    ];
    exports2.METHOD_COLORS = {
      GET: "green",
      PUT: "blue",
      POST: "white",
      DELETE: "red"
    };
    exports2.HTTPStatus = {
      Ok: 200,
      NoContent: 204,
      BadRequest: 400,
      Unauthorized: 401,
      Forbidden: 403,
      NotFound: 404,
      RangeNotSatisfiable: 416,
      UnprocessableContent: 422,
      TooManyRequests: 429,
      InternalServerError: 500
    };
    exports2.STREAMED_RESPONSE = Symbol("StreamedResponse");
  }
});

// ../../../sonata-api/packages/types/dist/resultSchemas.js
var require_resultSchemas = __commonJS({
  "../../../sonata-api/packages/types/dist/resultSchemas.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.genericEndpointErrorSchema = exports2.endpointErrorSchema = exports2.resultSchema = exports2.errorSchema = void 0;
    var errorSchema = (error) => {
      const schema = {
        type: "object",
        properties: {
          _tag: {
            const: "Error"
          },
          error,
          result: {
            const: void 0,
            isConstUndefined: true
          }
        }
      };
      return schema;
    };
    exports2.errorSchema = errorSchema;
    var resultSchema = (result) => {
      const schema = {
        type: "object",
        properties: {
          _tag: {
            const: "Result"
          },
          error: {
            const: void 0,
            isConstUndefined: true
          },
          result
        }
      };
      return schema;
    };
    exports2.resultSchema = resultSchema;
    var endpointErrorSchema = (error) => {
      return {
        type: "object",
        properties: {
          _tag: {
            const: "Error"
          },
          result: {
            const: void 0,
            isConstUndefined: true
          },
          error: {
            type: "object",
            required: [
              "httpStatus",
              "code"
            ],
            properties: {
              httpStatus: {
                enum: error.httpStatus
              },
              code: {
                enum: error.code
              },
              message: {
                type: "string"
              },
              details: {
                type: "object",
                additionalProperties: true
              }
            }
          }
        }
      };
    };
    exports2.endpointErrorSchema = endpointErrorSchema;
    var genericEndpointErrorSchema = () => {
      return {
        type: "object",
        properties: {
          _tag: {
            const: "Error"
          },
          result: {
            const: void 0,
            isConstUndefined: true
          },
          error: {
            type: "object",
            required: [
              "httpStatus",
              "code"
            ],
            properties: {
              httpStatus: {
                type: "number"
              },
              code: {
                type: "string"
              },
              message: {
                type: "string"
              },
              details: {
                type: "object",
                additionalProperties: true
              }
            }
          }
        }
      };
    };
    exports2.genericEndpointErrorSchema = genericEndpointErrorSchema;
  }
});

// ../../../sonata-api/packages/types/dist/validation.js
var require_validation = __commonJS({
  "../../../sonata-api/packages/types/dist/validation.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TraverseError = exports2.PropertyValidationErrorCode = exports2.ValidationErrorCode = void 0;
    exports2.ValidationErrorCode = {
      InvalidProperties: "INVALID_PROPERTIES",
      MissingProperties: "MISSING_PROPERTIES",
      EmptyTarget: "EMPTY_TARGET"
    };
    exports2.PropertyValidationErrorCode = {
      Missing: "MISSING_PROPERTY",
      Extraneous: "EXTRANEOUS_PROPERTY",
      Unmatching: "UNMATCHING_PROPERTIES",
      ExtraneousElement: "EXTRANEOUS_ELEMENT",
      MoreItemsExpected: "MORE_ITEMS_EXPECTED",
      LessItemsExpected: "LESS_ITEMS_EXPECTED",
      NumericConstraint: "NUMERIC_CONSTRAINT",
      StringConstraint: "STRING_CONSTRAINT",
      ReferenceConstraint: "REFERENCE_CONSTRAINT"
    };
    exports2.TraverseError = {
      InvalidDocumentId: "INVALID_DOCUMENT_ID",
      InvalidTempfile: "INVALID_TEMPFILE"
    };
  }
});

// ../../../sonata-api/packages/types/dist/functionSchemas.js
var require_functionSchemas = __commonJS({
  "../../../sonata-api/packages/types/dist/functionSchemas.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.countError = exports2.getAllError = exports2.getError = exports2.insertError = void 0;
    var accessControl_js_1 = require_accessControl();
    var http_js_1 = require_http();
    var resultSchemas_js_1 = require_resultSchemas();
    var validation_js_1 = require_validation();
    var insertError = () => (0, resultSchemas_js_1.endpointErrorSchema)({
      httpStatus: [
        http_js_1.HTTPStatus.Forbidden,
        http_js_1.HTTPStatus.NotFound,
        http_js_1.HTTPStatus.UnprocessableContent,
        http_js_1.HTTPStatus.BadRequest,
        http_js_1.HTTPStatus.InternalServerError
      ],
      code: [
        accessControl_js_1.ACError.InsecureOperator,
        accessControl_js_1.ACError.OwnershipError,
        accessControl_js_1.ACError.ResourceNotFound,
        accessControl_js_1.ACError.TargetImmutable,
        accessControl_js_1.ACError.MalformedInput,
        accessControl_js_1.ACError.UniquenessViolated,
        validation_js_1.ValidationErrorCode.EmptyTarget,
        validation_js_1.ValidationErrorCode.InvalidProperties,
        validation_js_1.ValidationErrorCode.MissingProperties,
        validation_js_1.TraverseError.InvalidDocumentId,
        validation_js_1.TraverseError.InvalidTempfile
      ]
    });
    exports2.insertError = insertError;
    var getError = () => (0, resultSchemas_js_1.endpointErrorSchema)({
      httpStatus: [
        http_js_1.HTTPStatus.Forbidden,
        http_js_1.HTTPStatus.NotFound,
        http_js_1.HTTPStatus.BadRequest
      ],
      code: [
        accessControl_js_1.ACError.ResourceNotFound,
        accessControl_js_1.ACError.OwnershipError,
        accessControl_js_1.ACError.InsecureOperator,
        accessControl_js_1.ACError.MalformedInput
      ]
    });
    exports2.getError = getError;
    var getAllError = () => (0, resultSchemas_js_1.endpointErrorSchema)({
      httpStatus: [http_js_1.HTTPStatus.Forbidden],
      code: [
        accessControl_js_1.ACError.OwnershipError,
        accessControl_js_1.ACError.InsecureOperator,
        accessControl_js_1.ACError.InvalidLimit
      ]
    });
    exports2.getAllError = getAllError;
    var countError = () => (0, resultSchemas_js_1.endpointErrorSchema)({
      httpStatus: [http_js_1.HTTPStatus.Forbidden],
      code: [
        accessControl_js_1.ACError.OwnershipError,
        accessControl_js_1.ACError.InvalidLimit
      ]
    });
    exports2.countError = countError;
  }
});

// ../../../sonata-api/packages/types/dist/collection.js
var require_collection = __commonJS({
  "../../../sonata-api/packages/types/dist/collection.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../sonata-api/packages/types/dist/condition.js
var require_condition = __commonJS({
  "../../../sonata-api/packages/types/dist/condition.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../sonata-api/packages/types/dist/config.js
var require_config = __commonJS({
  "../../../sonata-api/packages/types/dist/config.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../sonata-api/packages/types/dist/context.js
var require_context = __commonJS({
  "../../../sonata-api/packages/types/dist/context.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../sonata-api/packages/types/dist/contract.js
var require_contract = __commonJS({
  "../../../sonata-api/packages/types/dist/contract.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defineContract = void 0;
    var defineContract = (contract) => {
      return contract;
    };
    exports2.defineContract = defineContract;
  }
});

// ../../../sonata-api/packages/types/dist/description.js
var require_description = __commonJS({
  "../../../sonata-api/packages/types/dist/description.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LAYOUT_NAMES = exports2.DESCRIPTION_PRESETS = void 0;
    exports2.DESCRIPTION_PRESETS = [
      "add",
      "crud",
      "duplicate",
      "remove",
      "removeAll",
      "owned",
      "timestamped",
      "view"
    ];
    exports2.LAYOUT_NAMES = [
      "tabular",
      "grid",
      "list"
    ];
  }
});

// ../../../sonata-api/packages/types/dist/endpointError.js
var require_endpointError = __commonJS({
  "../../../sonata-api/packages/types/dist/endpointError.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ERROR_SYMBOL = exports2.ERROR_SYMBOL_DESCRIPTION = void 0;
    exports2.ERROR_SYMBOL_DESCRIPTION = "#__ERROR_SYMBOL__";
    exports2.ERROR_SYMBOL = Symbol(exports2.ERROR_SYMBOL_DESCRIPTION);
  }
});

// ../../../sonata-api/packages/types/dist/functions.js
var require_functions = __commonJS({
  "../../../sonata-api/packages/types/dist/functions.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../sonata-api/packages/types/dist/property.js
var require_property = __commonJS({
  "../../../sonata-api/packages/types/dist/property.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PROPERTY_FORMATS = exports2.PROPERTY_INPUT_ELEMENTS = exports2.PROPERTY_INPUT_TYPES = exports2.PROPERTY_ARRAY_ELEMENTS = void 0;
    exports2.PROPERTY_ARRAY_ELEMENTS = [
      "checkbox",
      "radio",
      "select"
    ];
    exports2.PROPERTY_INPUT_TYPES = [
      "text",
      "email",
      "password",
      "search",
      "time",
      "month"
    ];
    exports2.PROPERTY_INPUT_ELEMENTS = [
      "input",
      "textarea"
    ];
    exports2.PROPERTY_FORMATS = [
      "date",
      "date-time",
      "objectid"
    ];
  }
});

// ../../../sonata-api/packages/types/dist/result.js
var require_result = __commonJS({
  "../../../sonata-api/packages/types/dist/result.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Result = void 0;
    var Result;
    (function(Result2) {
      Result2.error = (value) => ({
        _tag: "Error",
        error: value,
        result: void 0
      });
      Result2.result = (value) => ({
        _tag: "Result",
        error: void 0,
        result: value
      });
    })(Result || (exports2.Result = Result = {}));
  }
});

// ../../../sonata-api/packages/types/dist/schema.js
var require_schema = __commonJS({
  "../../../sonata-api/packages/types/dist/schema.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../sonata-api/packages/types/dist/security.js
var require_security = __commonJS({
  "../../../sonata-api/packages/types/dist/security.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RateLimitingError = void 0;
    exports2.RateLimitingError = {
      Unauthenticated: "UNAUTHENTICATED",
      LimitReached: "LIMIT_REACHED"
    };
  }
});

// ../../../sonata-api/packages/types/dist/token.js
var require_token2 = __commonJS({
  "../../../sonata-api/packages/types/dist/token.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../sonata-api/packages/types/dist/index.js
var require_dist = __commonJS({
  "../../../sonata-api/packages/types/dist/index.js"(exports2) {
    "use strict";
    init_importMeta();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.functionSchemas = void 0;
    exports2.functionSchemas = require_functionSchemas();
    __exportStar(require_accessControl(), exports2);
    __exportStar(require_collection(), exports2);
    __exportStar(require_condition(), exports2);
    __exportStar(require_config(), exports2);
    __exportStar(require_context(), exports2);
    __exportStar(require_contract(), exports2);
    __exportStar(require_description(), exports2);
    __exportStar(require_endpointError(), exports2);
    __exportStar(require_functions(), exports2);
    __exportStar(require_http(), exports2);
    __exportStar(require_property(), exports2);
    __exportStar(require_result(), exports2);
    __exportStar(require_resultSchemas(), exports2);
    __exportStar(require_schema(), exports2);
    __exportStar(require_security(), exports2);
    __exportStar(require_token2(), exports2);
    __exportStar(require_validation(), exports2);
  }
});

// ../../../sonata-api/node_modules/.pnpm/@phosphor-icons+core@2.1.1/node_modules/@phosphor-icons/core/dist/index.umd.js
var require_index_umd = __commonJS({
  "../../../sonata-api/node_modules/.pnpm/@phosphor-icons+core@2.1.1/node_modules/@phosphor-icons/core/dist/index.umd.js"(exports2, module2) {
    init_importMeta();
    (function(t, n) {
      typeof exports2 == "object" && typeof module2 < "u" ? n(exports2) : typeof define == "function" && define.amd ? define(["exports"], n) : (t = typeof globalThis < "u" ? globalThis : t || self, n(t.Phosphor = {}));
    })(exports2, function(t) {
      "use strict";
      var n = ((i) => (i.REGULAR = "regular", i.THIN = "thin", i.LIGHT = "light", i.BOLD = "bold", i.FILL = "fill", i.DUOTONE = "duotone", i))(n || {}), e = ((i) => (i.ARROWS = "arrows", i.BRAND = "brands", i.COMMERCE = "commerce", i.COMMUNICATION = "communications", i.DESIGN = "design", i.DEVELOPMENT = "technology & development", i.EDITOR = "editor", i.FINANCE = "finances", i.GAMES = "games", i.HEALTH = "health & wellness", i.MAP = "maps & travel", i.MEDIA = "media", i.NATURE = "nature", i.OBJECTS = "objects", i.OFFICE = "office", i.PEOPLE = "people", i.SYSTEM = "system", i.WEATHER = "weather", i))(e || {}), a = ((i) => (i.ARROWS = "arrows", i.BRAND = "brands", i.COMMERCE = "commerce", i.COMMUNICATION = "communication", i.DESIGN = "design", i.DEVELOPMENT = "technology & development", i.EDUCATION = "education", i.FINANCE = "math & finance", i.GAMES = "games", i.HEALTH = "health & wellness", i.MAP = "maps & travel", i.MEDIA = "media", i.OFFICE = "office & editing", i.PEOPLE = "people", i.SECURITY = "security & warnings", i.SYSTEM = "system & devices", i.TIME = "time", i.WEATHER = "weather & nature", i))(a || {});
      const o = [{ name: "acorn", pascal_name: "Acorn", categories: [e.FINANCE, e.NATURE], figma_category: a.WEATHER, tags: ["*new*", "savings", "nut", "vegetable", "veggies", "food", "groceries", "market"], codepoint: 60314, published_in: 2.1, updated_in: 2.1 }, { name: "address-book", pascal_name: "AddressBook", categories: [e.COMMUNICATION], figma_category: a.COMMUNICATION, tags: ["contacts", "directory", "roledex"], codepoint: 59128, published_in: 1.3, updated_in: 1.3 }, { name: "address-book-tabs", pascal_name: "AddressBookTabs", categories: [e.COMMUNICATION], figma_category: a.COMMUNICATION, tags: ["*new*", "contacts", "directory", "roledex"], codepoint: 61006, published_in: 2.1, updated_in: 2.1 }, { name: "air-traffic-control", pascal_name: "AirTrafficControl", categories: [e.MAP], figma_category: a.MAP, tags: ["airport", "travel", "transportation", "buildings"], codepoint: 60632, published_in: 2, updated_in: 2 }, { name: "airplane", pascal_name: "Airplane", categories: [e.MAP, e.OBJECTS], figma_category: a.MAP, tags: ["vehicles", "airports", "flights", "flying", "planes", "transit", "transportation", "traveling"], codepoint: 57346, published_in: 1, updated_in: 1 }, { name: "airplane-in-flight", pascal_name: "AirplaneInFlight", categories: [e.MAP, e.OBJECTS], figma_category: a.MAP, tags: ["vehicles", "airports", "flights", "flying", "planes", "transit", "transportation", "traveling", "arrival"], codepoint: 58622, published_in: 1.1, updated_in: 1.1 }, { name: "airplane-landing", pascal_name: "AirplaneLanding", categories: [e.MAP, e.OBJECTS], figma_category: a.MAP, tags: ["vehicles", "airports", "flights", "flying", "planes", "transit", "transportation", "traveling", "arrival"], codepoint: 58626, published_in: 1.1, updated_in: 1.1 }, { name: "airplane-takeoff", pascal_name: "AirplaneTakeoff", categories: [e.MAP, e.OBJECTS], figma_category: a.MAP, tags: ["vehicles", "airports", "flights", "flying", "planes", "transit", "transportation", "traveling", "departure"], codepoint: 58628, published_in: 1.1, updated_in: 1.1 }, { name: "airplane-taxiing", pascal_name: "AirplaneTaxiing", categories: [e.MAP, e.OBJECTS], figma_category: a.MAP, tags: ["*new*", "vehicles", "airports", "flights", "flying", "planes", "transit", "transportation", "traveling", "arrival"], codepoint: 58624, published_in: 2.1, updated_in: 2.1 }, { name: "airplane-tilt", pascal_name: "AirplaneTilt", categories: [e.MAP, e.OBJECTS], figma_category: a.MAP, tags: ["vehicles", "airports", "flights", "flying", "planes", "transit", "transportation", "traveling", "departure"], codepoint: 58838, published_in: 1.2, updated_in: 1.2 }, { name: "airplay", pascal_name: "Airplay", categories: [e.MEDIA, e.SYSTEM], figma_category: a.MEDIA, tags: ["apple", "screencasting", "television", "tv"], codepoint: 57348, published_in: 1, updated_in: 1.4 }, { name: "alarm", pascal_name: "Alarm", categories: [e.SYSTEM], figma_category: a.TIME, tags: ["times", "timer", "clock", "schedule", "events", "watch"], codepoint: 57350, published_in: 1, updated_in: 1 }, { name: "alien", pascal_name: "Alien", categories: [e.GAMES], figma_category: a.GAMES, tags: ["ufo", "space", "flying saucer", "extra terrestrial", "sci-fi"], codepoint: 59558, published_in: 1.4, updated_in: 1.4 }, { name: "align-bottom", pascal_name: "AlignBottom", categories: [e.DESIGN, e.EDITOR], figma_category: a.DESIGN, tags: ["alignment", "arrangement", "layout", "flush bottom"], codepoint: 58630, published_in: 1.1, updated_in: 1.1 }, { name: "align-bottom-simple", pascal_name: "AlignBottomSimple", categories: [e.DESIGN, e.EDITOR], figma_category: a.DESIGN, tags: ["alignment", "arrangement", "layout", "flush bottom"], codepoint: 60172, published_in: 1.4, updated_in: 1.4 }, { name: "align-center-horizontal", pascal_name: "AlignCenterHorizontal", categories: [e.DESIGN, e.EDITOR], figma_category: a.DESIGN, tags: ["alignment", "arrangement", "layout", "centered", "middle"], codepoint: 58634, published_in: 1.1, updated_in: 1.1 }, { name: "align-center-horizontal-simple", pascal_name: "AlignCenterHorizontalSimple", categories: [e.DESIGN, e.EDITOR], figma_category: a.DESIGN, tags: ["alignment", "arrangement", "layout", "centered", "middle"], codepoint: 60174, published_in: 1.4, updated_in: 1.4 }, { name: "align-center-vertical", pascal_name: "AlignCenterVertical", categories: [e.DESIGN, e.EDITOR], figma_category: a.DESIGN, tags: ["alignment", "arrangement", "layout", "centered", "middle"], codepoint: 58636, published_in: 1.1, updated_in: 1.1 }, { name: "align-center-vertical-simple", pascal_name: "AlignCenterVerticalSimple", categories: [e.DESIGN, e.EDITOR], figma_category: a.DESIGN, tags: ["alignment", "arrangement", "layout", "centered", "middle"], codepoint: 60176, published_in: 1.4, updated_in: 1.4 }, { name: "align-left", pascal_name: "AlignLeft", categories: [e.DESIGN, e.EDITOR], figma_category: a.DESIGN, tags: ["alignment", "arrangement", "layout", "flush left"], codepoint: 58638, published_in: 1.1, updated_in: 1.1 }, { name: "align-left-simple", pascal_name: "AlignLeftSimple", categories: [e.DESIGN, e.EDITOR], figma_category: a.DESIGN, tags: ["alignment", "arrangement", "layout", "flush left"], codepoint: 60142, published_in: 1.4, updated_in: 1.4 }, { name: "align-right", pascal_name: "AlignRight", categories: [e.DESIGN, e.EDITOR], figma_category: a.DESIGN, tags: ["alignment", "arrangement", "layout", "flush right"], codepoint: 58640, published_in: 1.1, updated_in: 1.1 }, { name: "align-right-simple", pascal_name: "AlignRightSimple", categories: [e.DESIGN, e.EDITOR], figma_category: a.DESIGN, tags: ["alignment", "arrangement", "layout", "flush right"], codepoint: 60178, published_in: 1.4, updated_in: 1.4 }, { name: "align-top", pascal_name: "AlignTop", categories: [e.DESIGN, e.EDITOR], figma_category: a.DESIGN, tags: ["alignment", "arrangement", "layout", "flush top"], codepoint: 58642, published_in: 1.1, updated_in: 1.1 }, { name: "align-top-simple", pascal_name: "AlignTopSimple", categories: [e.DESIGN, e.EDITOR], figma_category: a.DESIGN, tags: ["alignment", "arrangement", "layout", "flush top"], codepoint: 60180, published_in: 1.4, updated_in: 1.4 }, { name: "amazon-logo", pascal_name: "AmazonLogo", categories: [e.BRAND], figma_category: a.BRAND, tags: ["ecommerce", "shopping", "logos"], codepoint: 59756, published_in: 2, updated_in: 2 }, { name: "ambulance", pascal_name: "Ambulance", categories: [e.HEALTH, e.MAP, e.OBJECTS], figma_category: a.HEALTH, tags: ["*new*", "first-aid", "emt", "medical", "medicine", "injury", "safety", "emergency", "doctor", "vehicles"], codepoint: 58738, published_in: 2.1, updated_in: 2.1 }, { name: "anchor", pascal_name: "Anchor", categories: [e.COMMUNICATION, e.MAP, e.OBJECTS], figma_category: a.MAP, tags: ["nautical", "boats", "ships", "hope", "safety", "insurance"], codepoint: 58644, published_in: 1.1, updated_in: 1.1 }, { name: "anchor-simple", pascal_name: "AnchorSimple", categories: [e.COMMUNICATION, e.MAP, e.OBJECTS], figma_category: a.MAP, tags: ["nautical", "boats", "ships", "hope", "safety", "insurance"], codepoint: 58840, published_in: 1.2, updated_in: 1.2 }, { name: "android-logo", pascal_name: "AndroidLogo", categories: [e.BRAND, e.DEVELOPMENT, e.SYSTEM], figma_category: a.BRAND, tags: ["logos", "google", "mobile", "phone", "cellular", "cellphone"], codepoint: 57352, published_in: 1, updated_in: 1 }, { name: "angle", pascal_name: "Angle", categories: [e.DESIGN, e.OBJECTS], figma_category: a.DESIGN, tags: ["*new*", "geometry", "trigonometry", "degrees", "radians", "measurement", "protractor", "compass", "arc"], codepoint: 59324, published_in: 2.1, updated_in: 2.1 }, { name: "angular-logo", pascal_name: "AngularLogo", categories: [e.BRAND, e.DEVELOPMENT], figma_category: a.BRAND, tags: ["framework", "javascript", "google", "web"], codepoint: 60288, published_in: 1.4, updated_in: 1.4 }, { name: "aperture", pascal_name: "Aperture", categories: [e.DESIGN, e.MEDIA], figma_category: a.MEDIA, tags: ["photography", "cameras", "pictures", "lens"], codepoint: 57354, published_in: 1, updated_in: 1 }, { name: "app-store-logo", pascal_name: "AppStoreLogo", categories: [e.BRAND], figma_category: a.BRAND, tags: ["macintosh", "imac", "iphone", "ipad", "macos", "ios"], codepoint: 59764, published_in: 1.4, updated_in: 1.4 }, { name: "app-window", pascal_name: "AppWindow", categories: [e.COMMUNICATION, e.SYSTEM], figma_category: a.SYSTEM, tags: ["windows", "software", "programs", "applications"], codepoint: 58842, published_in: 1.2, updated_in: 1.2 }, { name: "apple-logo", pascal_name: "AppleLogo", categories: [e.BRAND], figma_category: a.BRAND, tags: ["macintosh", "imac", "iphone", "ipad", "macos", "ios"], codepoint: 58646, published_in: 1.1, updated_in: 1.1 }, { name: "apple-podcasts-logo", pascal_name: "ApplePodcastsLogo", categories: [e.BRAND, e.MEDIA], figma_category: a.BRAND, tags: ["macintosh", "imac", "iphone", "ipad", "macos", "ios"], codepoint: 60310, published_in: 1.4, updated_in: 1.4 }, { name: "approximate-equals", pascal_name: "ApproximateEquals", categories: [e.FINANCE, e.DEVELOPMENT], figma_category: a.FINANCE, tags: ["*new*", "\u2248", "is approximately equal to", "congruent", "equality", "equivalent", "equivalence", "comparison", "mathematics", "arithmetic", "calculator"], codepoint: 60842, published_in: 2.1, updated_in: 2.1 }, { name: "archive", pascal_name: "Archive", categories: [e.OFFICE, e.SYSTEM], figma_category: a.OFFICE, tags: ["saved", "saving", "archived", "archiving", "archival", "downloaded", "downloading"], codepoint: 57356, published_in: 1, updated_in: 1 }, { name: "armchair", pascal_name: "Armchair", categories: [e.OBJECTS, e.COMMERCE], figma_category: a.COMMERCE, tags: ["seat", "furniture"], codepoint: 57362, published_in: 1.2, updated_in: 1.4 }, { name: "arrow-arc-left", pascal_name: "ArrowArcLeft", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead"], codepoint: 57364, published_in: 1, updated_in: 1 }, { name: "arrow-arc-right", pascal_name: "ArrowArcRight", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead"], codepoint: 57366, published_in: 1, updated_in: 1 }, { name: "arrow-bend-double-up-left", pascal_name: "ArrowBendDoubleUpLeft", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead", "reply-all"], codepoint: 57402, published_in: 1, updated_in: 1 }, { name: "arrow-bend-double-up-right", pascal_name: "ArrowBendDoubleUpRight", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead"], codepoint: 57404, published_in: 1, updated_in: 1 }, { name: "arrow-bend-down-left", pascal_name: "ArrowBendDownLeft", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead"], codepoint: 57368, published_in: 1, updated_in: 1 }, { name: "arrow-bend-down-right", pascal_name: "ArrowBendDownRight", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead"], codepoint: 57370, published_in: 1, updated_in: 1 }, { name: "arrow-bend-left-down", pascal_name: "ArrowBendLeftDown", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead"], codepoint: 57372, published_in: 1, updated_in: 1 }, { name: "arrow-bend-left-up", pascal_name: "ArrowBendLeftUp", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead"], codepoint: 57374, published_in: 1, updated_in: 1 }, { name: "arrow-bend-right-down", pascal_name: "ArrowBendRightDown", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead"], codepoint: 57376, published_in: 1, updated_in: 1 }, { name: "arrow-bend-right-up", pascal_name: "ArrowBendRightUp", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead"], codepoint: 57378, published_in: 1, updated_in: 1 }, { name: "arrow-bend-up-left", pascal_name: "ArrowBendUpLeft", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead", "reply", "re"], codepoint: 57380, published_in: 1, updated_in: 1 }, { name: "arrow-bend-up-right", pascal_name: "ArrowBendUpRight", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead", "forward", "fwd"], codepoint: 57382, published_in: 1, updated_in: 1 }, { name: "arrow-circle-down", pascal_name: "ArrowCircleDown", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead"], codepoint: 57384, published_in: 1, updated_in: 1 }, { name: "arrow-circle-down-left", pascal_name: "ArrowCircleDownLeft", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead"], codepoint: 57386, published_in: 1, updated_in: 1 }, { name: "arrow-circle-down-right", pascal_name: "ArrowCircleDownRight", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead"], codepoint: 57388, published_in: 1, updated_in: 1 }, { name: "arrow-circle-left", pascal_name: "ArrowCircleLeft", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead"], codepoint: 57434, published_in: 1, updated_in: 1 }, { name: "arrow-circle-right", pascal_name: "ArrowCircleRight", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead"], codepoint: 57390, published_in: 1, updated_in: 1 }, { name: "arrow-circle-up", pascal_name: "ArrowCircleUp", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead"], codepoint: 57392, published_in: 1, updated_in: 1 }, { name: "arrow-circle-up-left", pascal_name: "ArrowCircleUpLeft", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead"], codepoint: 57394, published_in: 1, updated_in: 1 }, { name: "arrow-circle-up-right", pascal_name: "ArrowCircleUpRight", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead"], codepoint: 57396, published_in: 1, updated_in: 1 }, { name: "arrow-clockwise", pascal_name: "ArrowClockwise", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["*updated*", "directional", "pointer", "pointing", "arrowhead", "redo", "refreshing", "rotate", "spin", "flip"], codepoint: 57398, published_in: 1, updated_in: 2.1 }, { name: "arrow-counter-clockwise", pascal_name: "ArrowCounterClockwise", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["*updated*", "directional", "pointer", "pointing", "arrowhead", "undo", "refreshing", "rotate", "spin", "flip"], codepoint: 57400, published_in: 1, updated_in: 2.1 }, { name: "arrow-down", pascal_name: "ArrowDown", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead"], codepoint: 57406, published_in: 1, updated_in: 1 }, { name: "arrow-down-left", pascal_name: "ArrowDownLeft", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead"], codepoint: 57408, published_in: 1, updated_in: 1 }, { name: "arrow-down-right", pascal_name: "ArrowDownRight", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead"], codepoint: 57410, published_in: 1, updated_in: 1 }, { name: "arrow-elbow-down-left", pascal_name: "ArrowElbowDownLeft", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead"], codepoint: 57412, published_in: 1, updated_in: 1 }, { name: "arrow-elbow-down-right", pascal_name: "ArrowElbowDownRight", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead"], codepoint: 57414, published_in: 1, updated_in: 1 }, { name: "arrow-elbow-left", pascal_name: "ArrowElbowLeft", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead"], codepoint: 57416, published_in: 1, updated_in: 1 }, { name: "arrow-elbow-left-down", pascal_name: "ArrowElbowLeftDown", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead"], codepoint: 57418, published_in: 1, updated_in: 1 }, { name: "arrow-elbow-left-up", pascal_name: "ArrowElbowLeftUp", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead"], codepoint: 57420, published_in: 1, updated_in: 1 }, { name: "arrow-elbow-right", pascal_name: "ArrowElbowRight", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead"], codepoint: 57422, published_in: 1, updated_in: 1 }, { name: "arrow-elbow-right-down", pascal_name: "ArrowElbowRightDown", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead"], codepoint: 57424, published_in: 1, updated_in: 1 }, { name: "arrow-elbow-right-up", pascal_name: "ArrowElbowRightUp", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead"], codepoint: 57426, published_in: 1, updated_in: 1 }, { name: "arrow-elbow-up-left", pascal_name: "ArrowElbowUpLeft", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead"], codepoint: 57428, published_in: 1, updated_in: 1 }, { name: "arrow-elbow-up-right", pascal_name: "ArrowElbowUpRight", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead"], codepoint: 57430, published_in: 1, updated_in: 1 }, { name: "arrow-fat-down", pascal_name: "ArrowFatDown", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead", "outlined"], codepoint: 58648, published_in: 1.1, updated_in: 1.1 }, { name: "arrow-fat-left", pascal_name: "ArrowFatLeft", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead", "outlined"], codepoint: 58650, published_in: 1.1, updated_in: 1.1 }, { name: "arrow-fat-line-down", pascal_name: "ArrowFatLineDown", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead", "outlined"], codepoint: 58652, published_in: 1.1, updated_in: 1.1 }, { name: "arrow-fat-line-left", pascal_name: "ArrowFatLineLeft", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead", "outlined"], codepoint: 58654, published_in: 1.1, updated_in: 1.1 }, { name: "arrow-fat-line-right", pascal_name: "ArrowFatLineRight", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead", "outlined"], codepoint: 58656, published_in: 1.1, updated_in: 1.1 }, { name: "arrow-fat-line-up", pascal_name: "ArrowFatLineUp", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead", "caps lock", "outlined"], codepoint: 58658, published_in: 1.1, updated_in: 1.1 }, { name: "arrow-fat-lines-down", pascal_name: "ArrowFatLinesDown", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead", "outlined"], codepoint: 58660, published_in: 1.1, updated_in: 1.1 }, { name: "arrow-fat-lines-left", pascal_name: "ArrowFatLinesLeft", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead", "outlined"], codepoint: 58662, published_in: 1.1, updated_in: 1.1 }, { name: "arrow-fat-lines-right", pascal_name: "ArrowFatLinesRight", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead", "outlined"], codepoint: 58664, published_in: 1.1, updated_in: 1.1 }, { name: "arrow-fat-lines-up", pascal_name: "ArrowFatLinesUp", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead", "outlined"], codepoint: 58666, published_in: 1.1, updated_in: 1.1 }, { name: "arrow-fat-right", pascal_name: "ArrowFatRight", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead", "outlined"], codepoint: 58668, published_in: 1.1, updated_in: 1.1 }, { name: "arrow-fat-up", pascal_name: "ArrowFatUp", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead", "shift", "outlined"], codepoint: 58670, published_in: 1.1, updated_in: 1.1 }, { name: "arrow-left", pascal_name: "ArrowLeft", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead"], codepoint: 57432, published_in: 1, updated_in: 1 }, { name: "arrow-line-down", pascal_name: "ArrowLineDown", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead", "bottom"], codepoint: 57436, published_in: 1, updated_in: 1 }, { name: "arrow-line-down-left", pascal_name: "ArrowLineDownLeft", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead"], codepoint: 57438, published_in: 1, updated_in: 1 }, { name: "arrow-line-down-right", pascal_name: "ArrowLineDownRight", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead"], codepoint: 57440, published_in: 1, updated_in: 1 }, { name: "arrow-line-left", pascal_name: "ArrowLineLeft", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead"], codepoint: 57442, published_in: 1, updated_in: 1 }, { name: "arrow-line-right", pascal_name: "ArrowLineRight", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead"], codepoint: 57444, published_in: 1, updated_in: 1 }, { name: "arrow-line-up", pascal_name: "ArrowLineUp", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead", "top"], codepoint: 57446, published_in: 1, updated_in: 1 }, { name: "arrow-line-up-left", pascal_name: "ArrowLineUpLeft", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead"], codepoint: 57448, published_in: 1, updated_in: 1 }, { name: "arrow-line-up-right", pascal_name: "ArrowLineUpRight", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead"], codepoint: 57450, published_in: 1, updated_in: 1 }, { name: "arrow-right", pascal_name: "ArrowRight", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead"], codepoint: 57452, published_in: 1, updated_in: 1 }, { name: "arrow-square-down", pascal_name: "ArrowSquareDown", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead"], codepoint: 57454, published_in: 1, updated_in: 1 }, { name: "arrow-square-down-left", pascal_name: "ArrowSquareDownLeft", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead"], codepoint: 57456, published_in: 1, updated_in: 1 }, { name: "arrow-square-down-right", pascal_name: "ArrowSquareDownRight", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead"], codepoint: 57458, published_in: 1, updated_in: 1 }, { name: "arrow-square-in", pascal_name: "ArrowSquareIn", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["import", "directional", "pointer", "pointing", "arrowhead"], codepoint: 58844, published_in: 1.2, updated_in: 1.2 }, { name: "arrow-square-left", pascal_name: "ArrowSquareLeft", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead"], codepoint: 57460, published_in: 1, updated_in: 1 }, { name: "arrow-square-out", pascal_name: "ArrowSquareOut", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["export", "external", "directional", "pointer", "pointing", "arrowhead"], codepoint: 58846, published_in: 1.2, updated_in: 1.2 }, { name: "arrow-square-right", pascal_name: "ArrowSquareRight", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead"], codepoint: 57462, published_in: 1, updated_in: 1 }, { name: "arrow-square-up", pascal_name: "ArrowSquareUp", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead"], codepoint: 57464, published_in: 1, updated_in: 1 }, { name: "arrow-square-up-left", pascal_name: "ArrowSquareUpLeft", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead"], codepoint: 57466, published_in: 1, updated_in: 1 }, { name: "arrow-square-up-right", pascal_name: "ArrowSquareUpRight", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead"], codepoint: 57468, published_in: 1, updated_in: 1 }, { name: "arrow-u-down-left", pascal_name: "ArrowUDownLeft", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead", "undo", "return", "u-turns"], codepoint: 57470, published_in: 1, updated_in: 1 }, { name: "arrow-u-down-right", pascal_name: "ArrowUDownRight", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead", "redo", "u-turns"], codepoint: 57472, published_in: 1, updated_in: 1 }, { name: "arrow-u-left-down", pascal_name: "ArrowULeftDown", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead", "undo", "return", "u-turns"], codepoint: 57474, published_in: 1, updated_in: 1 }, { name: "arrow-u-left-up", pascal_name: "ArrowULeftUp", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead", "redo", "u-turns"], codepoint: 57476, published_in: 1, updated_in: 1 }, { name: "arrow-u-right-down", pascal_name: "ArrowURightDown", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead", "undo", "return", "u-turns"], codepoint: 57478, published_in: 1, updated_in: 1 }, { name: "arrow-u-right-up", pascal_name: "ArrowURightUp", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead", "redo", "u-turns"], codepoint: 57480, published_in: 1, updated_in: 1 }, { name: "arrow-u-up-left", pascal_name: "ArrowUUpLeft", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead", "undo", "return", "u-turns"], codepoint: 57482, published_in: 1, updated_in: 1 }, { name: "arrow-u-up-right", pascal_name: "ArrowUUpRight", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead", "redo", "u-turns"], codepoint: 57484, published_in: 1, updated_in: 1 }, { name: "arrow-up", pascal_name: "ArrowUp", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead"], codepoint: 57486, published_in: 1, updated_in: 1 }, { name: "arrow-up-left", pascal_name: "ArrowUpLeft", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead"], codepoint: 57488, published_in: 1, updated_in: 1 }, { name: "arrow-up-right", pascal_name: "ArrowUpRight", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["directional", "pointer", "pointing", "arrowhead"], codepoint: 57490, published_in: 1, updated_in: 1 }, { name: "arrows-clockwise", pascal_name: "ArrowsClockwise", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["*updated*", "directional", "pointer", "pointing", "arrowhead", "redo", "refreshing", "sync", "synchronize", "rotate", "spin", "flip"], codepoint: 57492, published_in: 1, updated_in: 2.1 }, { name: "arrows-counter-clockwise", pascal_name: "ArrowsCounterClockwise", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["*updated*", "directional", "pointer", "pointing", "arrowhead", "undo", "refreshing", "rotate", "spin", "flip"], codepoint: 57494, published_in: 1, updated_in: 2.1 }, { name: "arrows-down-up", pascal_name: "ArrowsDownUp", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["*updated*", "directional", "pointer", "pointing", "arrowhead"], codepoint: 57496, published_in: 1, updated_in: 2.1 }, { name: "arrows-horizontal", pascal_name: "ArrowsHorizontal", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["*updated*", "directional", "pointer", "cursor", "resize", "expand", "left", "right"], codepoint: 60166, published_in: 1.4, updated_in: 2.1 }, { name: "arrows-in", pascal_name: "ArrowsIn", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["*updated*", "directional", "pointer", "pointing", "arrowhead", "collapse", "minimize", "resize", "shrink"], codepoint: 57498, published_in: 1, updated_in: 2.1 }, { name: "arrows-in-cardinal", pascal_name: "ArrowsInCardinal", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["*updated*", "directional", "pointer", "pointing", "arrowhead", "collapse", "minimize", "resize", "shrink"], codepoint: 57500, published_in: 1, updated_in: 2.1 }, { name: "arrows-in-line-horizontal", pascal_name: "ArrowsInLineHorizontal", categories: [e.ARROWS, e.DESIGN, e.EDITOR], figma_category: a.ARROWS, tags: ["*updated*", "directional", "pointer", "pointing", "arrowhead", "close", "center", "align"], codepoint: 58672, published_in: 1.1, updated_in: 2.1 }, { name: "arrows-in-line-vertical", pascal_name: "ArrowsInLineVertical", categories: [e.ARROWS, e.DESIGN, e.EDITOR], figma_category: a.ARROWS, tags: ["*updated*", "directional", "pointer", "pointing", "arrowhead", "close", "center", "align"], codepoint: 58674, published_in: 1.1, updated_in: 2.1 }, { name: "arrows-in-simple", pascal_name: "ArrowsInSimple", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["*updated*", "directional", "pointer", "pointing", "arrowhead", "collapse", "minimize", "resize"], codepoint: 57502, published_in: 1, updated_in: 2.1 }, { name: "arrows-left-right", pascal_name: "ArrowsLeftRight", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["*updated*", "directional", "pointer", "pointing", "arrowhead"], codepoint: 57504, published_in: 1, updated_in: 2.1 }, { name: "arrows-merge", pascal_name: "ArrowsMerge", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["*updated*", "arrowheads", "join", "combine"], codepoint: 60734, published_in: 2, updated_in: 2.1 }, { name: "arrows-out", pascal_name: "ArrowsOut", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["*updated*", "directional", "pointer", "pointing", "arrowhead", "expand", "fullscreen", "resize", "grow"], codepoint: 57506, published_in: 1, updated_in: 2.1 }, { name: "arrows-out-cardinal", pascal_name: "ArrowsOutCardinal", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["*updated*", "directional", "pointer", "pointing", "arrowhead", "expand", "fullscreen", "resize", "pan", "move", "grow"], codepoint: 57508, published_in: 1, updated_in: 2.1 }, { name: "arrows-out-line-horizontal", pascal_name: "ArrowsOutLineHorizontal", categories: [e.ARROWS, e.DESIGN, e.EDITOR], figma_category: a.ARROWS, tags: ["*updated*", "directional", "pointer", "pointing", "arrowhead", "open", "split"], codepoint: 58676, published_in: 1.1, updated_in: 2.1 }, { name: "arrows-out-line-vertical", pascal_name: "ArrowsOutLineVertical", categories: [e.ARROWS, e.DESIGN, e.EDITOR], figma_category: a.ARROWS, tags: ["*updated*", "directional", "pointer", "pointing", "arrowhead", "open", "split"], codepoint: 58678, published_in: 1.1, updated_in: 2.1 }, { name: "arrows-out-simple", pascal_name: "ArrowsOutSimple", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["*updated*", "directional", "pointer", "pointing", "arrowhead", "expand", "fullscreen", "resize"], codepoint: 57510, published_in: 1, updated_in: 2.1 }, { name: "arrows-split", pascal_name: "ArrowsSplit", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["*updated*", "arrowheads", "fork"], codepoint: 60732, published_in: 2, updated_in: 2.1 }, { name: "arrows-vertical", pascal_name: "ArrowsVertical", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["*updated*", "directional", "pointer", "cursor", "resize", "expand", "up", "down"], codepoint: 60164, published_in: 1.4, updated_in: 2.1 }, { name: "article", pascal_name: "Article", categories: [e.MEDIA, e.OBJECTS], figma_category: a.MEDIA, tags: ["reading", "writing", "journals", "periodicals", "text", "newspaper"], codepoint: 57512, published_in: 1, updated_in: 1 }, { name: "article-medium", pascal_name: "ArticleMedium", categories: [e.MEDIA, e.OBJECTS], figma_category: a.MEDIA, tags: ["*updated*", "reading", "writing", "journals", "periodicals", "text", "newspaper"], codepoint: 58848, published_in: 1.2, updated_in: 2.1 }, { name: "article-ny-times", pascal_name: "ArticleNyTimes", categories: [e.MEDIA, e.OBJECTS], figma_category: a.MEDIA, tags: ["*updated*", "reading", "writing", "journals", "periodicals", "text", "news", "newspaper", "nyt", "new york times"], codepoint: 58850, published_in: 1.2, updated_in: 2.1 }, { name: "asclepius", pascal_name: "Asclepius", alias: { name: "caduceus", pascal_name: "Caduceus" }, categories: [e.HEALTH], figma_category: a.HEALTH, tags: ["*new*", "caduceus", "staff", "mythology", "rx", "medicine", "drugs", "pharmacy", "pharmacist", "pharmaceuticals", "doctor", "hospital", "snake", "mercury", "hermes"], codepoint: 60980, published_in: 2.1, updated_in: 2.1 }, { name: "asterisk", pascal_name: "Asterisk", categories: [e.COMMUNICATION], figma_category: a.COMMUNICATION, tags: ["star", "wildcard", "bullet point", "6", "emergency"], codepoint: 57514, published_in: 1, updated_in: 1 }, { name: "asterisk-simple", pascal_name: "AsteriskSimple", categories: [e.COMMUNICATION], figma_category: a.COMMUNICATION, tags: ["*updated*", "star", "wildcard", "bullet point", "5", "emergency"], codepoint: 59442, published_in: 1.4, updated_in: 2.1 }, { name: "at", pascal_name: "At", categories: [e.COMMUNICATION], figma_category: a.COMMUNICATION, tags: ["@", "address", "email", "at symbol", "commercial at", "arobase"], codepoint: 57516, published_in: 1, updated_in: 1.4 }, { name: "atom", pascal_name: "Atom", categories: [e.DEVELOPMENT, e.NATURE], figma_category: a.WEATHER, tags: ["atomic", "nucleus", "nuclear", "reactor", "science", "physics", "electron", "automation", "react"], codepoint: 58852, published_in: 1.2, updated_in: 1.2 }, { name: "avocado", pascal_name: "Avocado", categories: [e.COMMERCE, e.NATURE], figma_category: a.COMMERCE, tags: ["*new*", "food", "vegetable", "veggie", "fruit", "groceries", "market"], codepoint: 60932, published_in: 2.1, updated_in: 2.1 }, { name: "axe", pascal_name: "Axe", categories: [e.COMMERCE, e.OBJECTS], figma_category: a.COMMERCE, tags: ["*new*", "tools", "carpentry", "forestry", "construction"], codepoint: 59900, published_in: 2.1, updated_in: 2.1 }, { name: "baby", pascal_name: "Baby", categories: [e.PEOPLE, e.HEALTH], figma_category: a.PEOPLE, tags: ["infant", "child", "children", "toddler"], codepoint: 59252, published_in: 1.3, updated_in: 1.4 }, { name: "baby-carriage", pascal_name: "BabyCarriage", categories: [e.COMMERCE, e.PEOPLE], figma_category: a.COMMERCE, tags: ["*new*", "pram", "stroller", "infant", "child", "children", "toddler"], codepoint: 59416, published_in: 2.1, updated_in: 2.1 }, { name: "backpack", pascal_name: "Backpack", categories: [e.COMMERCE, e.OBJECTS], figma_category: a.COMMERCE, tags: ["knapsack", "camping", "school", "bag"], codepoint: 59682, published_in: 1.4, updated_in: 1.4 }, { name: "backspace", pascal_name: "Backspace", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["keyboard", "remove", "delete"], codepoint: 57518, published_in: 1, updated_in: 1 }, { name: "bag", pascal_name: "Bag", categories: [e.COMMERCE, e.OBJECTS], figma_category: a.COMMERCE, tags: ["suitcase", "valise", "baggage", "folders", "portfolio"], codepoint: 57520, published_in: 1, updated_in: 1 }, { name: "bag-simple", pascal_name: "BagSimple", categories: [e.COMMERCE, e.OBJECTS], figma_category: a.COMMERCE, tags: ["suitcase", "valise", "baggage", "folders", "portfolio"], codepoint: 58854, published_in: 1.2, updated_in: 1.2 }, { name: "balloon", pascal_name: "Balloon", categories: [e.COMMERCE, e.OBJECTS], figma_category: a.COMMERCE, tags: ["helium", "birthday", "party"], codepoint: 59244, published_in: 1.4, updated_in: 1.4 }, { name: "bandaids", pascal_name: "Bandaids", categories: [e.HEALTH], figma_category: a.HEALTH, tags: ["bandages", "medical", "medicine", "first aid", "injury"], codepoint: 57522, published_in: 1, updated_in: 1 }, { name: "bank", pascal_name: "Bank", categories: [e.FINANCE, e.MAP], figma_category: a.FINANCE, tags: ["banking", "checking", "money", "savings", "deposit", "withdraw", "places", "locations"], codepoint: 57524, published_in: 1, updated_in: 1 }, { name: "barbell", pascal_name: "Barbell", categories: [e.HEALTH], figma_category: a.HEALTH, tags: ["gym", "weights", "dumbbells", "strength training", "workout", "exercises", "fitness"], codepoint: 57526, published_in: 1, updated_in: 2 }, { name: "barcode", pascal_name: "Barcode", categories: [e.COMMERCE, e.SYSTEM], figma_category: a.COMMERCE, tags: ["upc", "qr", "products", "shopping", "scanner"], codepoint: 57528, published_in: 1, updated_in: 1 }, { name: "barn", pascal_name: "Barn", categories: [e.COMMERCE, e.MAP], figma_category: a.COMMERCE, tags: ["*new*", "animals", "livestock", "buildings", "farming", "agriculture"], codepoint: 60530, published_in: 2.1, updated_in: 2.1 }, { name: "barricade", pascal_name: "Barricade", categories: [e.MAP, e.OBJECTS], figma_category: a.MAP, tags: ["construction", "safety", "gate"], codepoint: 59720, published_in: 1.4, updated_in: 1.4 }, { name: "baseball", pascal_name: "Baseball", categories: [e.GAMES, e.HEALTH, e.OBJECTS], figma_category: a.GAMES, tags: ["sports", "mlb"], codepoint: 59162, published_in: 1.3, updated_in: 1.4 }, { name: "baseball-cap", pascal_name: "BaseballCap", categories: [e.COMMERCE, e.OBJECTS], figma_category: a.COMMERCE, tags: ["clothes", "clothing", "sports", "hat"], codepoint: 59944, published_in: 2, updated_in: 2 }, { name: "baseball-helmet", pascal_name: "BaseballHelmet", categories: [e.GAMES, e.HEALTH, e.OBJECTS], figma_category: a.GAMES, tags: ["*new*", "sports", "mlb"], codepoint: 61002, published_in: 2.1, updated_in: 2.1 }, { name: "basket", pascal_name: "Basket", categories: [e.COMMERCE, e.OBJECTS], figma_category: a.COMMERCE, tags: ["ecommerce", "market", "cart", "buying", "shopping", "groceries", "checkout", "places", "locations"], codepoint: 59748, published_in: 2, updated_in: 2 }, { name: "basketball", pascal_name: "Basketball", categories: [e.GAMES, e.HEALTH, e.OBJECTS], figma_category: a.GAMES, tags: ["sports", "nba"], codepoint: 59172, published_in: 1.3, updated_in: 1.4 }, { name: "bathtub", pascal_name: "Bathtub", categories: [e.OBJECTS], figma_category: a.COMMERCE, tags: ["bath", "shower", "bathroom", "faucet"], codepoint: 59422, published_in: 1.4, updated_in: 1.4 }, { name: "battery-charging", pascal_name: "BatteryCharging", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["charged", "charger", "charging", "power"], codepoint: 57530, published_in: 1, updated_in: 2 }, { name: "battery-charging-vertical", pascal_name: "BatteryChargingVertical", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["charged", "charger", "charging", "power"], codepoint: 57532, published_in: 1, updated_in: 2 }, { name: "battery-empty", pascal_name: "BatteryEmpty", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["charged", "charger", "charging", "power", "dead"], codepoint: 57534, published_in: 1, updated_in: 2 }, { name: "battery-full", pascal_name: "BatteryFull", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["charged", "charger", "charging", "power", "filled"], codepoint: 57536, published_in: 1, updated_in: 2 }, { name: "battery-high", pascal_name: "BatteryHigh", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["charged", "charger", "charging", "power"], codepoint: 57538, published_in: 1, updated_in: 2 }, { name: "battery-low", pascal_name: "BatteryLow", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["charged", "charger", "charging", "power"], codepoint: 57540, published_in: 1, updated_in: 2 }, { name: "battery-medium", pascal_name: "BatteryMedium", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["charged", "charger", "charging", "power"], codepoint: 57542, published_in: 1, updated_in: 2 }, { name: "battery-plus", pascal_name: "BatteryPlus", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["charged", "charger", "charging", "power"], codepoint: 59400, published_in: 1.4, updated_in: 2 }, { name: "battery-plus-vertical", pascal_name: "BatteryPlusVertical", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["charged", "charger", "charging", "power"], codepoint: 60496, published_in: 2, updated_in: 2 }, { name: "battery-vertical-empty", pascal_name: "BatteryVerticalEmpty", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["charged", "charger", "charging", "power", "dead"], codepoint: 59334, published_in: 2, updated_in: 2 }, { name: "battery-vertical-full", pascal_name: "BatteryVerticalFull", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["charged", "charger", "charging", "power"], codepoint: 59332, published_in: 2, updated_in: 2 }, { name: "battery-vertical-high", pascal_name: "BatteryVerticalHigh", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["charged", "charger", "charging", "power"], codepoint: 59330, published_in: 2, updated_in: 2 }, { name: "battery-vertical-low", pascal_name: "BatteryVerticalLow", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["charged", "charger", "charging", "power"], codepoint: 59326, published_in: 2, updated_in: 2 }, { name: "battery-vertical-medium", pascal_name: "BatteryVerticalMedium", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["charged", "charger", "charging", "power"], codepoint: 59328, published_in: 2, updated_in: 2 }, { name: "battery-warning", pascal_name: "BatteryWarning", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["charged", "charger", "charging", "power", "empty", "critical"], codepoint: 57544, published_in: 1, updated_in: 1 }, { name: "battery-warning-vertical", pascal_name: "BatteryWarningVertical", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["charged", "charger", "charging", "power", "empty", "critical"], codepoint: 57546, published_in: 1, updated_in: 1 }, { name: "beach-ball", pascal_name: "BeachBall", categories: [e.GAMES, e.HEALTH, e.OBJECTS], figma_category: a.GAMES, tags: ["*new*", "sports", "ocean", "party"], codepoint: 60708, published_in: 2.1, updated_in: 2.1 }, { name: "beanie", pascal_name: "Beanie", categories: [e.COMMERCE, e.OBJECTS], figma_category: a.COMMERCE, tags: ["*new*", "clothes", "clothing", "sports", "hat", "winter"], codepoint: 59946, published_in: 2.1, updated_in: 2.1 }, { name: "bed", pascal_name: "Bed", categories: [e.HEALTH, e.MAP, e.OBJECTS], figma_category: a.HEALTH, tags: ["hotels", "accommodations", "sleeping", "places", "locations", "medical", "hospital"], codepoint: 57548, published_in: 1, updated_in: 1 }, { name: "beer-bottle", pascal_name: "BeerBottle", categories: [e.COMMERCE, e.MAP, e.OBJECTS], figma_category: a.COMMERCE, tags: ["drinks", "beverages", "places", "locations", "bars", "restaurants", "food", "dining"], codepoint: 59312, published_in: 1.4, updated_in: 1.4 }, { name: "beer-stein", pascal_name: "BeerStein", categories: [e.COMMERCE, e.MAP, e.OBJECTS], figma_category: a.COMMERCE, tags: ["drinks", "beverages", "places", "locations", "bars", "restaurants", "food", "dining"], codepoint: 60258, published_in: 2, updated_in: 2 }, { name: "behance-logo", pascal_name: "BehanceLogo", categories: [e.BRAND, e.DESIGN], figma_category: a.BRAND, tags: ["logos", "illustration", "ui", "interface"], codepoint: 59380, published_in: 1.4, updated_in: 1.4 }, { name: "bell", pascal_name: "Bell", categories: [e.SYSTEM, e.OBJECTS], figma_category: a.SYSTEM, tags: ["alarm", "notifications", "times", "timer", "clock", "schedule", "events", "ringer", "calls"], codepoint: 57550, published_in: 1, updated_in: 1 }, { name: "bell-ringing", pascal_name: "BellRinging", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["alarm", "notifications", "times", "timer", "clock", "schedule", "events", "ringer", "calls"], codepoint: 58856, published_in: 1.2, updated_in: 1.2 }, { name: "bell-simple", pascal_name: "BellSimple", categories: [e.SYSTEM, e.OBJECTS], figma_category: a.SYSTEM, tags: ["alarm", "notifications", "times", "timer", "clock", "schedule", "events", "ringer", "calls"], codepoint: 57552, published_in: 1, updated_in: 1 }, { name: "bell-simple-ringing", pascal_name: "BellSimpleRinging", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["alarm", "notifications", "times", "timer", "clock", "schedule", "events", "ringer", "calls"], codepoint: 58858, published_in: 1.2, updated_in: 1.2 }, { name: "bell-simple-slash", pascal_name: "BellSimpleSlash", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["alarm", "notifications", "times", "timer", "clock", "schedule", "events", "ringer", "silent", "silenced", "disabled"], codepoint: 57554, published_in: 1, updated_in: 1 }, { name: "bell-simple-z", pascal_name: "BellSimpleZ", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["alarm", "notifications", "times", "timer", "clock", "schedule", "events", "ringer", "snooze"], codepoint: 58860, published_in: 1.2, updated_in: 1.2 }, { name: "bell-slash", pascal_name: "BellSlash", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["alarm", "notifications", "times", "timer", "clock", "schedule", "events", "silent", "silenced", "ringer", "calls", "disabled"], codepoint: 57556, published_in: 1, updated_in: 1 }, { name: "bell-z", pascal_name: "BellZ", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["alarm", "notifications", "times", "timer", "clock", "schedule", "events", "ringer", "snooze"], codepoint: 58862, published_in: 1.2, updated_in: 1.2 }, { name: "belt", pascal_name: "Belt", categories: [e.COMMERCE, e.OBJECTS], figma_category: a.COMMERCE, tags: ["*new*", "clothes", "clothing"], codepoint: 59948, published_in: 2.1, updated_in: 2.1 }, { name: "bezier-curve", pascal_name: "BezierCurve", categories: [e.DESIGN], figma_category: a.DESIGN, tags: ["shapes", "drawing", "path", "pen", "vector"], codepoint: 60160, published_in: 1.4, updated_in: 1.4 }, { name: "bicycle", pascal_name: "Bicycle", categories: [e.HEALTH, e.MAP, e.OBJECTS], figma_category: a.MAP, tags: ["bikers", "bicycling", "cyclists", "transit", "transportation", "commuter", "exercises", "fitness"], codepoint: 57558, published_in: 1, updated_in: 1 }, { name: "binary", pascal_name: "Binary", categories: [e.DEVELOPMENT, e.SYSTEM], figma_category: a.DEVELOPMENT, tags: ["*new*", "digital", "0", "1", "programming", "coding", "executable"], codepoint: 61024, published_in: 2.1, updated_in: 2.1 }, { name: "binoculars", pascal_name: "Binoculars", categories: [e.NATURE, e.OBJECTS, e.MAP], figma_category: a.COMMERCE, tags: ["telescope", "glasses", "search", "find", "explore"], codepoint: 60004, published_in: 1.4, updated_in: 1.4 }, { name: "biohazard", pascal_name: "Biohazard", categories: [e.HEALTH], figma_category: a.SECURITY, tags: ["*new*", "contamination", "quarantine", "toxic", "poison", "danger", "caution"], codepoint: 59872, published_in: 2.1, updated_in: 2.1 }, { name: "bird", pascal_name: "Bird", categories: [e.NATURE], figma_category: a.WEATHER, tags: ["*updated*", "animals", "pets"], codepoint: 59180, published_in: 1.3, updated_in: 2.1 }, { name: "blueprint", pascal_name: "Blueprint", categories: [e.COMMERCE, e.DESIGN], figma_category: a.DESIGN, tags: ["*new*", "architecture", "layout", "floorplan", "building", "construction"], codepoint: 60832, published_in: 2.1, updated_in: 2.1 }, { name: "bluetooth", pascal_name: "Bluetooth", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["wireless", "connection", "connected", "connectivity"], codepoint: 57562, published_in: 1, updated_in: 1 }, { name: "bluetooth-connected", pascal_name: "BluetoothConnected", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["wireless", "connection", "connected", "connectivity"], codepoint: 57564, published_in: 1, updated_in: 1 }, { name: "bluetooth-slash", pascal_name: "BluetoothSlash", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["wireless", "connection", "connectivity", "disconnected", "disabled"], codepoint: 57566, published_in: 1, updated_in: 1 }, { name: "bluetooth-x", pascal_name: "BluetoothX", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["wireless", "connection", "connectivity", "disconnected", "errors"], codepoint: 57568, published_in: 1, updated_in: 1 }, { name: "boat", pascal_name: "Boat", categories: [e.MAP, e.OBJECTS], figma_category: a.MAP, tags: ["ferry", "ship", "cruise", "vehicles", "public transit", "transportation", "commuter", "traveling", "sailing", "places", "locations"], codepoint: 59270, published_in: 1.3, updated_in: 1.3 }, { name: "bomb", pascal_name: "Bomb", categories: [e.GAMES, e.OBJECTS], figma_category: a.GAMES, tags: ["*new*", "gaming", "grenade", "explosive", "war", "weapon", "fuse"], codepoint: 60938, published_in: 2.1, updated_in: 2.1 }, { name: "bone", pascal_name: "Bone", categories: [e.NATURE, e.HEALTH], figma_category: a.WEATHER, tags: ["dogbone"], codepoint: 59378, published_in: 2, updated_in: 2 }, { name: "book", pascal_name: "Book", categories: [e.OFFICE, e.MEDIA, e.OBJECTS], figma_category: a.EDUCATION, tags: ["reading", "reader", "novel", "story", "library"], codepoint: 57570, published_in: 1, updated_in: 1 }, { name: "book-bookmark", pascal_name: "BookBookmark", categories: [e.OFFICE, e.MEDIA, e.OBJECTS], figma_category: a.EDUCATION, tags: ["reading", "reader", "novel", "story", "library", "favorites", "favorited"], codepoint: 57572, published_in: 1, updated_in: 1 }, { name: "book-open", pascal_name: "BookOpen", categories: [e.OFFICE, e.MEDIA, e.OBJECTS], figma_category: a.EDUCATION, tags: ["*updated*", "reading", "reader", "novel", "story", "library"], codepoint: 57574, published_in: 1, updated_in: 2.1 }, { name: "book-open-text", pascal_name: "BookOpenText", categories: [e.OFFICE, e.MEDIA, e.OBJECTS, e.MAP], figma_category: a.EDUCATION, tags: ["*updated*", "reading", "reader", "novel", "story", "library"], codepoint: 59634, published_in: 2, updated_in: 2.1 }, { name: "book-open-user", pascal_name: "BookOpenUser", categories: [e.OFFICE, e.MEDIA, e.OBJECTS], figma_category: a.EDUCATION, tags: ["*new*", "reading", "reader", "easy read", "library", "places", "locations"], codepoint: 60896, published_in: 2.1, updated_in: 2.1 }, { name: "bookmark", pascal_name: "Bookmark", categories: [e.OFFICE, e.MEDIA, e.OBJECTS], figma_category: a.EDUCATION, tags: ["reading", "reader", "novel", "story", "placeholder", "favorites", "favorited", "library"], codepoint: 57576, published_in: 1, updated_in: 1 }, { name: "bookmark-simple", pascal_name: "BookmarkSimple", categories: [e.OFFICE, e.MEDIA, e.OBJECTS], figma_category: a.EDUCATION, tags: ["reading", "reader", "novel", "story", "placeholder", "favorites", "favorited", "library"], codepoint: 57578, published_in: 1, updated_in: 1 }, { name: "bookmarks", pascal_name: "Bookmarks", categories: [e.OFFICE, e.OBJECTS], figma_category: a.EDUCATION, tags: ["reading", "reader", "novel", "story", "placeholder", "favorites", "favorited", "library"], codepoint: 57580, published_in: 1, updated_in: 1 }, { name: "bookmarks-simple", pascal_name: "BookmarksSimple", categories: [e.OFFICE, e.OBJECTS], figma_category: a.EDUCATION, tags: ["reading", "reader", "novel", "story", "placeholder", "favorites", "favorited", "library"], codepoint: 58864, published_in: 1.2, updated_in: 1.2 }, { name: "books", pascal_name: "Books", categories: [e.OFFICE, e.MAP, e.MEDIA, e.OBJECTS], figma_category: a.EDUCATION, tags: ["reading", "reader", "bookshelf", "library", "places", "locations"], codepoint: 59224, published_in: 1.3, updated_in: 2 }, { name: "boot", pascal_name: "Boot", categories: [e.COMMERCE, e.OBJECTS, e.HEALTH], figma_category: a.COMMERCE, tags: ["hiking", "shoes", "sports", "exercise"], codepoint: 60618, published_in: 2, updated_in: 2 }, { name: "boules", pascal_name: "Boules", categories: [e.GAMES, e.HEALTH, e.OBJECTS], figma_category: a.GAMES, tags: ["*new*", "balls", "sports", "p\xE9tanque", "raffa", "bocce", "boule lyonnaise", "lawn bowls"], codepoint: 59170, published_in: 2.1, updated_in: 2.1 }, { name: "bounding-box", pascal_name: "BoundingBox", categories: [e.DESIGN], figma_category: a.DESIGN, tags: ["polygon", "shapes", "outline", "corners", "rectangle"], codepoint: 59086, published_in: 1.3, updated_in: 1.3 }, { name: "bowl-food", pascal_name: "BowlFood", categories: [e.COMMERCE, e.MAP, e.OBJECTS], figma_category: a.COMMERCE, tags: ["ramen", "food", "meal", "eating", "restaurants", "dining", "locations"], codepoint: 60068, published_in: 2, updated_in: 2 }, { name: "bowl-steam", pascal_name: "BowlSteam", categories: [e.COMMERCE, e.OBJECTS, e.MAP], figma_category: a.COMMERCE, tags: ["*new*", "food", "meal", "eating", "restaurants", "dining", "locations"], codepoint: 59620, published_in: 2.1, updated_in: 2.1 }, { name: "bowling-ball", pascal_name: "BowlingBall", categories: [e.GAMES, e.HEALTH, e.OBJECTS], figma_category: a.GAMES, tags: ["*new*", "sports", "alley"], codepoint: 59956, published_in: 2.1, updated_in: 2.1 }, { name: "box-arrow-down", pascal_name: "BoxArrowDown", alias: { name: "archive-box", pascal_name: "ArchiveBox" }, categories: [e.OFFICE, e.SYSTEM], figma_category: a.OFFICE, tags: ["saved", "saving", "archived", "archiving", "archival", "downloaded", "downloading"], codepoint: 57358, published_in: 1, updated_in: 1 }, { name: "box-arrow-up", pascal_name: "BoxArrowUp", categories: [e.OFFICE, e.SYSTEM], figma_category: a.OFFICE, tags: ["*new*", "unarchive", "archival", "upload"], codepoint: 61012, published_in: 2.1, updated_in: 2.1 }, { name: "boxing-glove", pascal_name: "BoxingGlove", categories: [e.GAMES, e.HEALTH, e.OBJECTS], figma_category: a.GAMES, tags: ["*new*", "sports", "combat", "martial arts", "fight", "gym"], codepoint: 59958, published_in: 2.1, updated_in: 2.1 }, { name: "brackets-angle", pascal_name: "BracketsAngle", categories: [e.DEVELOPMENT, e.EDITOR], figma_category: a.DEVELOPMENT, tags: ["code", "angle brackets", "angle braces"], codepoint: 59490, published_in: 1.3, updated_in: 1.3 }, { name: "brackets-curly", pascal_name: "BracketsCurly", categories: [e.DEVELOPMENT, e.EDITOR], figma_category: a.DEVELOPMENT, tags: ["code", "curly brackets", "curly braces"], codepoint: 59488, published_in: 1.3, updated_in: 1.3 }, { name: "brackets-round", pascal_name: "BracketsRound", categories: [e.DEVELOPMENT, e.EDITOR], figma_category: a.DEVELOPMENT, tags: ["code", "parentheses", "round brackets", "round braces"], codepoint: 59492, published_in: 1.3, updated_in: 1.3 }, { name: "brackets-square", pascal_name: "BracketsSquare", categories: [e.DEVELOPMENT, e.EDITOR], figma_category: a.DEVELOPMENT, tags: ["code", "square brackets", "square braces", "array"], codepoint: 59486, published_in: 1.3, updated_in: 1.3 }, { name: "brain", pascal_name: "Brain", categories: [e.HEALTH, e.NATURE], figma_category: a.HEALTH, tags: ["mind", "mental"], codepoint: 59214, published_in: 1.3, updated_in: 1.3 }, { name: "brandy", pascal_name: "Brandy", categories: [e.COMMERCE, e.MAP, e.OBJECTS], figma_category: a.COMMERCE, tags: ["drinks", "beverages", "whiskey", "cocktail", "places", "locations", "bars", "restaurants", "food", "dining"], codepoint: 59060, published_in: 1.3, updated_in: 1.3 }, { name: "bread", pascal_name: "Bread", categories: [e.COMMERCE, e.MAP], figma_category: a.COMMERCE, tags: ["*new*", "food", "meal", "bakery", "sandwich", "gluten", "loaf", "toast", "slice"], codepoint: 59420, published_in: 2.1, updated_in: 2.1 }, { name: "bridge", pascal_name: "Bridge", categories: [e.MAP, e.OBJECTS], figma_category: a.COMMERCE, tags: ["travel", "transportation", "infrastucture"], codepoint: 60008, published_in: 2, updated_in: 2 }, { name: "briefcase", pascal_name: "Briefcase", categories: [e.OFFICE, e.OBJECTS], figma_category: a.OFFICE, tags: ["suitcase", "valise", "baggage", "folders", "portfolio"], codepoint: 57582, published_in: 1, updated_in: 1 }, { name: "briefcase-metal", pascal_name: "BriefcaseMetal", categories: [e.OFFICE, e.OBJECTS], figma_category: a.OFFICE, tags: ["suitcase", "valise", "baggage", "folders", "portfolio"], codepoint: 58866, published_in: 1.2, updated_in: 1.4 }, { name: "broadcast", pascal_name: "Broadcast", categories: [e.COMMUNICATION, e.MEDIA, e.SYSTEM], figma_category: a.COMMUNICATION, tags: ["radio", "hotspot", "wifi", "emit"], codepoint: 57586, published_in: 1, updated_in: 1 }, { name: "broom", pascal_name: "Broom", categories: [e.OBJECTS], figma_category: a.COMMERCE, tags: ["sweeping", "cleaning"], codepoint: 60500, published_in: 2, updated_in: 2 }, { name: "browser", pascal_name: "Browser", categories: [e.COMMUNICATION, e.SYSTEM], figma_category: a.SYSTEM, tags: ["web browsers", "windows", "internet", "website", "webpage", "chrome", "edge", "firefox"], codepoint: 57588, published_in: 1, updated_in: 1 }, { name: "browsers", pascal_name: "Browsers", categories: [e.COMMUNICATION, e.SYSTEM], figma_category: a.SYSTEM, tags: ["web browsers", "windows", "internet", "website", "webpage", "chrome", "edge", "firefox"], codepoint: 57590, published_in: 1, updated_in: 1 }, { name: "bug", pascal_name: "Bug", categories: [e.DEVELOPMENT, e.NATURE], figma_category: a.DEVELOPMENT, tags: ["debug", "errors", "insect", "ladybug"], codepoint: 58868, published_in: 1.2, updated_in: 1.2 }, { name: "bug-beetle", pascal_name: "BugBeetle", categories: [e.DEVELOPMENT, e.NATURE], figma_category: a.DEVELOPMENT, tags: ["debug", "errors", "insect", "ladybug"], codepoint: 58870, published_in: 1.2, updated_in: 1.2 }, { name: "bug-droid", pascal_name: "BugDroid", categories: [e.DEVELOPMENT, e.NATURE], figma_category: a.DEVELOPMENT, tags: ["debug", "errors", "insect", "android", "google"], codepoint: 58872, published_in: 1.2, updated_in: 1.2 }, { name: "building", pascal_name: "Building", categories: [e.COMMERCE, e.MAP], figma_category: a.COMMERCE, tags: ["*new*", "places", "locations", "company", "business", "buildings"], codepoint: 57600, published_in: 2.1, updated_in: 2.1 }, { name: "building-apartment", pascal_name: "BuildingApartment", categories: [e.COMMERCE, e.MAP], figma_category: a.COMMERCE, tags: ["*new*", "places", "locations", "buildings"], codepoint: 57598, published_in: 2.1, updated_in: 2.1 }, { name: "building-office", pascal_name: "BuildingOffice", categories: [e.COMMERCE, e.MAP], figma_category: a.COMMERCE, tags: ["*new*", "places", "locations", "company", "business", "buildings"], codepoint: 57598, published_in: 2.1, updated_in: 2.1 }, { name: "buildings", pascal_name: "Buildings", categories: [e.COMMERCE, e.MAP], figma_category: a.COMMERCE, tags: ["places", "locations", "company", "business"], codepoint: 57602, published_in: 1, updated_in: 2 }, { name: "bulldozer", pascal_name: "Bulldozer", categories: [e.COMMERCE, e.OBJECTS], figma_category: a.COMMERCE, tags: ["*new*", "vehicles", "construction", "earth mover", "dig", "digger"], codepoint: 60524, published_in: 2.1, updated_in: 2.1 }, { name: "bus", pascal_name: "Bus", categories: [e.MAP, e.OBJECTS], figma_category: a.MAP, tags: ["vehicles", "automobile", "public transit", "transportation", "commuter", "traveling", "places", "locations"], codepoint: 57606, published_in: 1, updated_in: 2 }, { name: "butterfly", pascal_name: "Butterfly", categories: [e.NATURE], figma_category: a.WEATHER, tags: ["animals", "insects", "moth"], codepoint: 60014, published_in: 1.4, updated_in: 1.4 }, { name: "cable-car", pascal_name: "CableCar", categories: [e.MAP, e.OBJECTS], figma_category: a.MAP, tags: ["*new*", "vehicles", "gondola", "skiing", "mountains", "public transit", "transportation", "commuter", "traveling", "places", "locations"], codepoint: 58524, published_in: 2.1, updated_in: 2.1 }, { name: "cactus", pascal_name: "Cactus", categories: [e.NATURE], figma_category: a.WEATHER, tags: ["*updated*", "plants", "cacti", "desert", "western"], codepoint: 59672, published_in: 1.4, updated_in: 2.1 }, { name: "cake", pascal_name: "Cake", categories: [e.OBJECTS], figma_category: a.COMMERCE, tags: ["dessert", "birthday", "celebration", "event"], codepoint: 59264, published_in: 1.3, updated_in: 2 }, { name: "calculator", pascal_name: "Calculator", categories: [e.DEVELOPMENT, e.FINANCE, e.OFFICE, e.OBJECTS], figma_category: a.FINANCE, tags: ["addition", "sum", "subtraction", "difference", "multiply", "multiplication", "product", "divide", "division", "divisor", "dividend", "quotient", "equals", "equality", "mathematics", "arithmetic", "+", "-", "\xB1", "\xD7", "\xF7", "="], codepoint: 58680, published_in: 1.1, updated_in: 1.1 }, { name: "calendar", pascal_name: "Calendar", categories: [e.OFFICE, e.SYSTEM], figma_category: a.TIME, tags: ["dates", "times", "events", "schedule", "12"], codepoint: 57608, published_in: 1, updated_in: 2 }, { name: "calendar-blank", pascal_name: "CalendarBlank", categories: [e.OFFICE, e.SYSTEM], figma_category: a.TIME, tags: ["dates", "times", "events", "schedule", "none"], codepoint: 57610, published_in: 1, updated_in: 1 }, { name: "calendar-check", pascal_name: "CalendarCheck", categories: [e.OFFICE, e.SYSTEM], figma_category: a.TIME, tags: ["dates", "times", "events", "schedule", "todo", "checklist"], codepoint: 59154, published_in: 1.3, updated_in: 1.3 }, { name: "calendar-dot", pascal_name: "CalendarDot", categories: [e.OFFICE, e.SYSTEM], figma_category: a.TIME, tags: ["*new*", "dates", "times", "events", "schedule", "today"], codepoint: 59314, published_in: 2.1, updated_in: 2.1 }, { name: "calendar-dots", pascal_name: "CalendarDots", categories: [e.OFFICE, e.SYSTEM], figma_category: a.TIME, tags: ["*new*", "dates", "times", "events", "schedule"], codepoint: 59316, published_in: 2.1, updated_in: 2.1 }, { name: "calendar-heart", pascal_name: "CalendarHeart", categories: [e.OFFICE, e.SYSTEM], figma_category: a.TIME, tags: ["*new*", "dates", "times", "events", "schedule", "favorite", "star"], codepoint: 59568, published_in: 2.1, updated_in: 2.1 }, { name: "calendar-minus", pascal_name: "CalendarMinus", categories: [e.OFFICE, e.SYSTEM], figma_category: a.TIME, tags: ["*new*", "dates", "times", "events", "schedule", "remove", "delete"], codepoint: 59924, published_in: 2.1, updated_in: 2.1 }, { name: "calendar-plus", pascal_name: "CalendarPlus", categories: [e.OFFICE, e.SYSTEM], figma_category: a.TIME, tags: ["dates", "times", "events", "schedule", "add"], codepoint: 59156, published_in: 1.3, updated_in: 1.3 }, { name: "calendar-slash", pascal_name: "CalendarSlash", categories: [e.OFFICE, e.SYSTEM], figma_category: a.TIME, tags: ["*new*", "dates", "times", "events", "schedule", "remove", "delete", "cancel. unavailable"], codepoint: 59922, published_in: 2.1, updated_in: 2.1 }, { name: "calendar-star", pascal_name: "CalendarStar", categories: [e.OFFICE, e.SYSTEM], figma_category: a.TIME, tags: ["*new*", "dates", "times", "events", "schedule", "favorite", "star"], codepoint: 59570, published_in: 2.1, updated_in: 2.1 }, { name: "calendar-x", pascal_name: "CalendarX", categories: [e.OFFICE, e.SYSTEM], figma_category: a.TIME, tags: ["dates", "times", "events", "schedule", "closed", "cancelled"], codepoint: 57612, published_in: 1, updated_in: 1 }, { name: "call-bell", pascal_name: "CallBell", categories: [e.MAP, e.OBJECTS], figma_category: a.COMMERCE, tags: ["service bell", "reception", "attendant", "concierge bell"], codepoint: 59358, published_in: 2, updated_in: 2 }, { name: "camera", pascal_name: "Camera", categories: [e.MEDIA, e.SYSTEM, e.OBJECTS], figma_category: a.MEDIA, tags: ["photography", "pictures", "lens"], codepoint: 57614, published_in: 1, updated_in: 1 }, { name: "camera-plus", pascal_name: "CameraPlus", categories: [e.MEDIA, e.SYSTEM], figma_category: a.MEDIA, tags: ["photography", "pictures", "album", "add"], codepoint: 60504, published_in: 2, updated_in: 2 }, { name: "camera-rotate", pascal_name: "CameraRotate", categories: [e.MEDIA, e.SYSTEM], figma_category: a.MEDIA, tags: ["photography", "pictures", "orientation", "portrait", "landscape", "selfie", "flip"], codepoint: 59300, published_in: 1.4, updated_in: 1.4 }, { name: "camera-slash", pascal_name: "CameraSlash", categories: [e.MEDIA, e.SYSTEM], figma_category: a.MEDIA, tags: ["photography", "pictures", "lens", "disabled"], codepoint: 57616, published_in: 1, updated_in: 1 }, { name: "campfire", pascal_name: "Campfire", categories: [e.NATURE], figma_category: a.WEATHER, tags: ["camping", "flame", "bonfire", "outdoors"], codepoint: 59864, published_in: 1.4, updated_in: 1.4 }, { name: "car", pascal_name: "Car", categories: [e.MAP, e.OBJECTS], figma_category: a.MAP, tags: ["*updated*", "cars", "vehicles", "automobile", "transit", "transportation", "traveling"], codepoint: 57618, published_in: 1, updated_in: 2.1 }, { name: "car-battery", pascal_name: "CarBattery", categories: [e.COMMERCE, e.OBJECTS], figma_category: a.COMMERCE, tags: ["*new*", "charged", "charger", "charging", "power", "voltage", "electricity"], codepoint: 60976, published_in: 2.1, updated_in: 2.1 }, { name: "car-profile", pascal_name: "CarProfile", categories: [e.MAP, e.OBJECTS], figma_category: a.MAP, tags: ["cars", "vehicles", "automobile", "transit", "transportation", "traveling"], codepoint: 59596, published_in: 2, updated_in: 2 }, { name: "car-simple", pascal_name: "CarSimple", categories: [e.MAP, e.OBJECTS], figma_category: a.MAP, tags: ["cars", "vehicles", "automobile", "transit", "transportation", "traveling"], codepoint: 57620, published_in: 1, updated_in: 1 }, { name: "cardholder", pascal_name: "Cardholder", categories: [e.COMMERCE, e.FINANCE, e.OBJECTS], figma_category: a.COMMERCE, tags: ["wallet", "money", "payment", "paying", "purchase"], codepoint: 58874, published_in: 1.2, updated_in: 1.2 }, { name: "cards", pascal_name: "Cards", categories: [e.DESIGN, e.SYSTEM], figma_category: a.OFFICE, tags: ["card", "slides", "slideshow", "windows", "website", "webpage", "layers"], codepoint: 57592, published_in: 1, updated_in: 1 }, { name: "cards-three", pascal_name: "CardsThree", categories: [e.DESIGN, e.SYSTEM], figma_category: a.OFFICE, tags: ["*new*", "card", "slides", "slideshow", "windows", "website", "webpage", "layers", "stack"], codepoint: 61008, published_in: 2.1, updated_in: 2.1 }, { name: "caret-circle-double-down", pascal_name: "CaretCircleDoubleDown", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["chevron", "directional", "pointer", "pointing", "arrowhead", "triangle"], codepoint: 57622, published_in: 1, updated_in: 1 }, { name: "caret-circle-double-left", pascal_name: "CaretCircleDoubleLeft", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["chevron", "directional", "pointer", "pointing", "arrowhead", "triangle"], codepoint: 57624, published_in: 1, updated_in: 1 }, { name: "caret-circle-double-right", pascal_name: "CaretCircleDoubleRight", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["chevron", "directional", "pointer", "pointing", "arrowhead", "triangle"], codepoint: 57626, published_in: 1, updated_in: 1 }, { name: "caret-circle-double-up", pascal_name: "CaretCircleDoubleUp", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["chevron", "directional", "pointer", "pointing", "arrowhead", "triangle"], codepoint: 57628, published_in: 1, updated_in: 1 }, { name: "caret-circle-down", pascal_name: "CaretCircleDown", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["chevron", "directional", "pointer", "pointing", "arrowhead", "triangle"], codepoint: 57630, published_in: 1, updated_in: 1 }, { name: "caret-circle-left", pascal_name: "CaretCircleLeft", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["chevron", "directional", "pointer", "pointing", "arrowhead", "triangle"], codepoint: 57632, published_in: 1, updated_in: 1 }, { name: "caret-circle-right", pascal_name: "CaretCircleRight", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["chevron", "directional", "pointer", "pointing", "arrowhead", "triangle"], codepoint: 57634, published_in: 1, updated_in: 1 }, { name: "caret-circle-up", pascal_name: "CaretCircleUp", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["chevron", "directional", "pointer", "pointing", "arrowhead", "triangle"], codepoint: 57636, published_in: 1, updated_in: 1 }, { name: "caret-circle-up-down", pascal_name: "CaretCircleUpDown", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["chevron", "directional", "pointer", "pointing", "arrowhead", "triangle"], codepoint: 57662, published_in: 2, updated_in: 2 }, { name: "caret-double-down", pascal_name: "CaretDoubleDown", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["chevron", "directional", "pointer", "pointing", "arrowhead", "triangle"], codepoint: 57638, published_in: 1, updated_in: 1 }, { name: "caret-double-left", pascal_name: "CaretDoubleLeft", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["chevron", "directional", "pointer", "pointing", "arrowhead", "triangle"], codepoint: 57640, published_in: 1, updated_in: 1 }, { name: "caret-double-right", pascal_name: "CaretDoubleRight", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["chevron", "directional", "pointer", "pointing", "arrowhead", "triangle"], codepoint: 57642, published_in: 1, updated_in: 1 }, { name: "caret-double-up", pascal_name: "CaretDoubleUp", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["chevron", "directional", "pointer", "pointing", "arrowhead", "triangle"], codepoint: 57644, published_in: 1, updated_in: 1 }, { name: "caret-down", pascal_name: "CaretDown", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["chevron", "directional", "pointer", "pointing", "arrowhead", "triangle"], codepoint: 57654, published_in: 1, updated_in: 1 }, { name: "caret-left", pascal_name: "CaretLeft", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["chevron", "directional", "pointer", "pointing", "arrowhead", "triangle"], codepoint: 57656, published_in: 1, updated_in: 1 }, { name: "caret-line-down", pascal_name: "CaretLineDown", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["*new*", "chevron", "directional", "pointer", "pointing", "arrowhead", "triangle"], codepoint: 57652, published_in: 2.1, updated_in: 2.1 }, { name: "caret-line-left", pascal_name: "CaretLineLeft", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["*new*", "chevron", "directional", "pointer", "pointing", "arrowhead", "triangle"], codepoint: 57650, published_in: 2.1, updated_in: 2.1 }, { name: "caret-line-right", pascal_name: "CaretLineRight", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["*new*", "chevron", "directional", "pointer", "pointing", "arrowhead", "triangle"], codepoint: 57648, published_in: 2.1, updated_in: 2.1 }, { name: "caret-line-up", pascal_name: "CaretLineUp", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["*new*", "chevron", "directional", "pointer", "pointing", "arrowhead", "triangle"], codepoint: 57646, published_in: 2.1, updated_in: 2.1 }, { name: "caret-right", pascal_name: "CaretRight", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["chevron", "directional", "pointer", "pointing", "arrowhead", "triangle"], codepoint: 57658, published_in: 1, updated_in: 1 }, { name: "caret-up", pascal_name: "CaretUp", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["chevron", "directional", "pointer", "pointing", "arrowhead", "triangle"], codepoint: 57660, published_in: 1, updated_in: 1 }, { name: "caret-up-down", pascal_name: "CaretUpDown", categories: [e.ARROWS], figma_category: a.ARROWS, tags: ["chevron", "directional", "pointer", "pointing", "arrowhead", "triangle"], codepoint: 57664, published_in: 2, updated_in: 2 }, { name: "carrot", pascal_name: "Carrot", categories: [e.COMMERCE, e.NATURE], figma_category: a.COMMERCE, tags: ["food", "vegetable", "veggie", "groceries", "market"], codepoint: 60728, published_in: 2, updated_in: 2 }, { name: "cash-register", pascal_name: "CashRegister", categories: [e.COMMERCE, e.OBJECTS], figma_category: a.COMMERCE, tags: ["*new*", "retail", "point-of-sale", "pos", "transaction", "sales", "till"], codepoint: 60800, published_in: 2.1, updated_in: 2.1 }, { name: "cassette-tape", pascal_name: "CassetteTape", categories: [e.MEDIA, e.OBJECTS], figma_category: a.MEDIA, tags: ["recording", "audio", "album", "music"], codepoint: 60718, published_in: 2, updated_in: 2 }, { name: "castle-turret", pascal_name: "CastleTurret", categories: [e.MAP, e.OBJECTS, e.GAMES], figma_category: a.GAMES, tags: ["*updated*", "chess", "rook"], codepoint: 59856, published_in: 2, updated_in: 2.1 }, { name: "cat", pascal_name: "Cat", categories: [e.NATURE], figma_category: a.WEATHER, tags: ["pets", "animals", "kitty", "kitten"], codepoint: 59208, published_in: 1.3, updated_in: 1.4 }, { name: "cell-signal-full", pascal_name: "CellSignalFull", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["wireless", "cellular", "phone", "mobile", "network", "connection", "connectivity", "reception", "service"], codepoint: 57666, published_in: 1, updated_in: 2 }, { name: "cell-signal-high", pascal_name: "CellSignalHigh", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["wireless", "cellular", "phone", "mobile", "network", "connection", "connectivity", "reception", "service"], codepoint: 57668, published_in: 1, updated_in: 2 }, { name: "cell-signal-low", pascal_name: "CellSignalLow", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["wireless", "cellular", "phone", "mobile", "network", "connection", "connectivity", "reception", "service"], codepoint: 57670, published_in: 1, updated_in: 2 }, { name: "cell-signal-medium", pascal_name: "CellSignalMedium", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["wireless", "cellular", "phone", "mobile", "network", "connection", "connectivity", "reception", "service"], codepoint: 57672, published_in: 1, updated_in: 2 }, { name: "cell-signal-none", pascal_name: "CellSignalNone", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["wireless", "cellular", "phone", "mobile", "network", "connection", "connectivity", "reception", "service"], codepoint: 57674, published_in: 1, updated_in: 2 }, { name: "cell-signal-slash", pascal_name: "CellSignalSlash", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["wireless", "cellular", "phone", "mobile", "network", "connection", "connectivity", "disconnected", "disabled", "reception", "service"], codepoint: 57676, published_in: 1, updated_in: 2 }, { name: "cell-signal-x", pascal_name: "CellSignalX", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["wireless", "cellular", "phone", "mobile", "network", "connection", "connectivity", "reception", "disconnected", "errors", "service"], codepoint: 57678, published_in: 1, updated_in: 2 }, { name: "cell-tower", pascal_name: "CellTower", categories: [e.SYSTEM], figma_category: a.COMMUNICATION, tags: ["*new*", "wireless", "cellular", "broadcast", "phone", "mobile", "network", "connection", "connectivity"], codepoint: 60330, published_in: 2.1, updated_in: 2.1 }, { name: "certificate", pascal_name: "Certificate", categories: [e.OBJECTS], figma_category: a.EDUCATION, tags: ["*updated*", "awards", "certification", "degree", "diploma"], codepoint: 59238, published_in: 2, updated_in: 2.1 }, { name: "chair", pascal_name: "Chair", categories: [e.OBJECTS, e.COMMERCE], figma_category: a.COMMERCE, tags: ["seat", "furniture"], codepoint: 59728, published_in: 2, updated_in: 2 }, { name: "chalkboard", pascal_name: "Chalkboard", categories: [e.MAP, e.OBJECTS], figma_category: a.EDUCATION, tags: ["blackboard", "whiteboard", "classroom", "teacher", "education", "school", "college", "university"], codepoint: 58876, published_in: 1.2, updated_in: 1.2 }, { name: "chalkboard-simple", pascal_name: "ChalkboardSimple", categories: [e.MAP, e.OBJECTS], figma_category: a.EDUCATION, tags: ["*updated*", "blackboard", "whiteboard", "classroom", "teacher", "education", "school", "college", "university"], codepoint: 58878, published_in: 1.2, updated_in: 2.1 }, { name: "chalkboard-teacher", pascal_name: "ChalkboardTeacher", categories: [e.MAP, e.OBJECTS, e.PEOPLE], figma_category: a.EDUCATION, tags: ["blackboard", "whiteboard", "classroom", "education", "school", "college", "university"], codepoint: 58880, published_in: 1.2, updated_in: 1.2 }, { name: "champagne", pascal_name: "Champagne", categories: [e.MAP, e.COMMERCE, e.OBJECTS], figma_category: a.COMMERCE, tags: ["glass", "drinks", "beverages", "wine", "places", "locations", "bars", "restaurants", "food", "dining"], codepoint: 60106, published_in: 2, updated_in: 2 }, { name: "charging-station", pascal_name: "ChargingStation", categories: [e.MAP, e.OBJECTS], figma_category: a.MAP, tags: ["ev", "charge", "fuel", "pump"], codepoint: 59600, published_in: 2, updated_in: 2 }, { name: "chart-bar", pascal_name: "ChartBar", categories: [e.FINANCE, e.OFFICE], figma_category: a.FINANCE, tags: ["graphs", "graphing", "charts", "statistics", "histogram", "analyze", "analysis"], codepoint: 57680, published_in: 1, updated_in: 1 }, { name: "chart-bar-horizontal", pascal_name: "ChartBarHorizontal", categories: [e.FINANCE, e.OFFICE], figma_category: a.FINANCE, tags: ["graphs", "graphing", "charts", "statistics", "histogram", "analyze", "analysis"], codepoint: 57682, published_in: 1, updated_in: 1 }, { name: "chart-donut", pascal_name: "ChartDonut", categories: [e.FINANCE, e.OFFICE], figma_category: a.FINANCE, tags: ["graphs", "graphing", "charts", "statistics", "analyze", "analysis", "circle"], codepoint: 60070, published_in: 2, updated_in: 2 }, { name: "chart-line", pascal_name: "ChartLine", categories: [e.FINANCE, e.OFFICE], figma_category: a.FINANCE, tags: ["graphs", "graphing", "charts", "statistics", "analyze", "analysis", "stocks"], codepoint: 57684, published_in: 1, updated_in: 1 }, { name: "chart-line-down", pascal_name: "ChartLineDown", categories: [e.FINANCE, e.OFFICE], figma_category: a.FINANCE, tags: ["*updated*", "graphs", "graphing", "charts", "statistics", "analyze", "analysis", "stocks"], codepoint: 59574, published_in: 2, updated_in: 2.1 }, { name: "chart-line-up", pascal_name: "ChartLineUp", categories: [e.FINANCE, e.OFFICE], figma_category: a.FINANCE, tags: ["*updated*", "graphs", "graphing", "charts", "statistics", "analyze", "analysis", "stocks"], codepoint: 57686, published_in: 1, updated_in: 2.1 }, { name: "chart-pie", pascal_name: "ChartPie", categories: [e.FINANCE, e.OFFICE], figma_category: a.FINANCE, tags: ["graphs", "graphing", "charts", "statistics", "circle", "analyze", "analysis"], codepoint: 57688, published_in: 1, updated_in: 1 }, { name: "chart-pie-slice", pascal_name: "ChartPieSlice", categories: [e.FINANCE, e.OFFICE], figma_category: a.FINANCE, tags: ["*updated*", "graphs", "graphing", "charts", "statistics", "circle", "analyze", "analysis"], codepoint: 57690, published_in: 1, updated_in: 2.1 }, { name: "chart-polar", pascal_name: "ChartPolar", categories: [e.FINANCE, e.OFFICE], figma_category: a.FINANCE, tags: ["graphs", "graphing", "charts", "statistics", "analyze", "analysis", "circle"], codepoint: 60072, published_in: 2, updated_in: 2 }, { name: "chart-scatter", pascal_name: "ChartScatter", categories: [e.FINANCE, e.OFFICE], figma_category: a.FINANCE, tags: ["graphs", "graphing", "charts", "statistics", "analyze", "analysis"], codepoint: 60076, published_in: 2, updated_in: 2 }, { name: "chat", pascal_name: "Chat", categories: [e.COMMUNICATION], figma_category: a.COMMUNICATION, tags: ["send", "sent", "messages", "messaging", "sms", "texting", "comment", "square", "bubble"], codepoint: 57692, published_in: 1, updated_in: 1 }, { name: "chat-centered", pascal_name: "ChatCentered", categories: [e.COMMUNICATION], figma_category: a.COMMUNICATION, tags: ["send", "sent", "messages", "messaging", "sms", "texting", "comment", "square", "bubble"], codepoint: 57696, published_in: 1, updated_in: 1 }, { name: "chat-centered-dots", pascal_name: "ChatCenteredDots", categories: [e.COMMUNICATION], figma_category: a.COMMUNICATION, tags: ["send", "sent", "messages", "messaging", "sms", "texting", "comment", "square", "bubble"], codepoint: 57700, published_in: 1, updated_in: 1 }, { name: "chat-centered-slash", pascal_name: "ChatCenteredSlash", categories: [e.COMMUNICATION], figma_category: a.COMMUNICATION, tags: ["*new*", "messages", "messaging", "sms", "texting", "comment", "square", "bubble"], codepoint: 57698, published_in: 2.1, updated_in: 2.1 }, { name: "chat-centered-text", pascal_name: "ChatCenteredText", categories: [e.COMMUNICATION], figma_category: a.COMMUNICATION, tags: ["send", "sent", "messages", "messaging", "sms", "texting", "comment", "square", "bubble"], codepoint: 57702, published_in: 1, updated_in: 1 }, { name: "chat-circle", pascal_name: "ChatCircle", categories: [e.COMMUNICATION], figma_category: a.COMMUNICATION, tags: ["send", "sent", "messages", "messaging", "sms", "texting", "comment", "round", "bubble"], codepoint: 57704, published_in: 1, updated_in: 1 }, { name: "chat-circle-dots", pascal_name: "ChatCircleDots", categories: [e.COMMUNICATION], figma_category: a.COMMUNICATION, tags: ["send", "sent", "messages", "messaging", "sms", "texting", "comment", "round", "bubble"], codepoint: 57708, published_in: 1, updated_in: 1 }, { name: "chat-circle-slash", pascal_name: "ChatCircleSlash", categories: [e.COMMUNICATION], figma_category: a.COMMUNICATION, tags: ["*new*", "messages", "messaging", "sms", "texting", "comment", "round", "bubble"], codepoint: 57706, published_in: 2.1, updated_in: 2.1 }, { name: "chat-circle-text", pascal_name: "ChatCircleText", categories: [e.COMMUNICATION], figma_category: a.COMMUNICATION, tags: ["send", "sent", "messages", "messaging", "sms", "texting", "comment", "round", "bubble"], codepoint: 57710, published_in: 1, updated_in: 1 }, { name: "chat-dots", pascal_name: "ChatDots", categories: [e.COMMUNICATION], figma_category: a.COMMUNICATION, tags: ["send", "sent", "messages", "messaging", "sms", "texting", "comment", "square", "bubble"], codepoint: 57712, published_in: 1, updated_in: 1 }, { name: "chat-slash", pascal_name: "ChatSlash", categories: [e.COMMUNICATION], figma_category: a.COMMUNICATION, tags: ["*new*", "messages", "messaging", "sms", "texting", "comment", "square", "bubble"], codepoint: 57694, published_in: 2.1, updated_in: 2.1 }, { name: "chat-teardrop", pascal_name: "ChatTeardrop", categories: [e.COMMUNICATION], figma_category: a.COMMUNICATION, tags: ["send", "sent", "messages", "messaging", "sms", "texting", "comment", "bubble"], codepoint: 57714, published_in: 1, updated_in: 1 }, { name: "chat-teardrop-dots", pascal_name: "ChatTeardropDots", categories: [e.COMMUNICATION], figma_category: a.COMMUNICATION, tags: ["send", "sent", "messages", "messaging", "sms", "texting", "comment", "bubble"], codepoint: 57718, published_in: 1, updated_in: 1 }, { name: "chat-teardrop-slash", pascal_name: "ChatTeardropSlash", categories: [e.COMMUNICATION], figma_category: a.COMMUNICATION, tags: ["*new*", "messages", "messaging", "sms", "texting", "comment", "bubble"], codepoint: 57716, published_in: 2.1, updated_in: 2.1 }, { name: "chat-teardrop-text", pascal_name: "ChatTeardropText", categories: [e.COMMUNICATION], figma_category: a.COMMUNICATION, tags: ["send", "sent", "messages", "messaging", "sms", "texting", "comment", "bubble"], codepoint: 57720, published_in: 1, updated_in: 1 }, { name: "chat-text", pascal_name: "ChatText", categories: [e.COMMUNICATION], figma_category: a.COMMUNICATION, tags: ["send", "sent", "messages", "messaging", "sms", "texting", "comment", "square", "bubble"], codepoint: 57722, published_in: 1, updated_in: 1 }, { name: "chats", pascal_name: "Chats", categories: [e.COMMUNICATION], figma_category: a.COMMUNICATION, tags: ["send", "sent", "messages", "messaging", "sms", "texting", "comment", "square", "bubble"], codepoint: 57724, published_in: 1, updated_in: 1 }, { name: "chats-circle", pascal_name: "ChatsCircle", categories: [e.COMMUNICATION], figma_category: a.COMMUNICATION, tags: ["send", "sent", "messages", "messaging", "sms", "texting", "comment", "round", "bubble"], codepoint: 57726, published_in: 1, updated_in: 1 }, { name: "chats-teardrop", pascal_name: "ChatsTeardrop", categories: [e.COMMUNICATION], figma_category: a.COMMUNICATION, tags: ["send", "sent", "messages", "messaging", "sms", "texting", "comment", "bubble"], codepoint: 57728, published_in: 1, updated_in: 1 }, { name: "check", pascal_name: "Check", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["todo", "to-do", "task", "list", "checkbox", "ok", "done"], codepoint: 57730, published_in: 1, updated_in: 1 }, { name: "check-circle", pascal_name: "CheckCircle", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["todo", "to-do", "task", "list", "checkbox", "round", "ok", "done"], codepoint: 57732, published_in: 1, updated_in: 1 }, { name: "check-fat", pascal_name: "CheckFat", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["todo", "to-do", "task", "list", "checkbox", "ok", "done"], codepoint: 60326, published_in: 2, updated_in: 2 }, { name: "check-square", pascal_name: "CheckSquare", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["todo", "to-do", "task", "list", "checkbox", "rectangle", "ok", "done"], codepoint: 57734, published_in: 1, updated_in: 1 }, { name: "check-square-offset", pascal_name: "CheckSquareOffset", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["*updated*", "todo", "to-do", "task", "list", "checkbox", "rectangle", "ok", "done"], codepoint: 57736, published_in: 1, updated_in: 2.1 }, { name: "checkerboard", pascal_name: "Checkerboard", categories: [e.GAMES], figma_category: a.GAMES, tags: ["*new*", "crossword"], codepoint: 59588, published_in: 2.1, updated_in: 2.1 }, { name: "checks", pascal_name: "Checks", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["*updated*", "todo", "task", "to-do", "list", "checkbox", "ok", "done"], codepoint: 58682, published_in: 1.1, updated_in: 2.1 }, { name: "cheers", pascal_name: "Cheers", categories: [e.COMMERCE, e.MAP], figma_category: a.COMMERCE, tags: ["*new*", "glass", "drinks", "beverages", "champagne", "toast", "places", "locations", "bars", "restaurants", "food", "dining"], codepoint: 59978, published_in: 2.1, updated_in: 2.1 }, { name: "cheese", pascal_name: "Cheese", categories: [e.COMMERCE], figma_category: a.COMMERCE, tags: ["*new*", "dairy", "wedge", "food", "dining"], codepoint: 59902, published_in: 2.1, updated_in: 2.1 }, { name: "chef-hat", pascal_name: "ChefHat", categories: [e.COMMERCE, e.OBJECTS], figma_category: a.COMMERCE, tags: ["*new*", "cooking", "cuisine", "kitchen", "clothes", "clothing"], codepoint: 60814, published_in: 2.1, updated_in: 2.1 }, { name: "cherries", pascal_name: "Cherries", categories: [e.NATURE, e.COMMERCE], figma_category: a.COMMERCE, tags: ["*new*", "food", "fruit", "cherry", "groceries", "market"], codepoint: 59440, published_in: 2.1, updated_in: 2.1 }, { name: "church", pascal_name: "Church", categories: [e.MAP], figma_category: a.MAP, tags: ["christ", "christianity", "cathedral", "religion", "worship"], codepoint: 60650, published_in: 2, updated_in: 2 }, { name: "cigarette", pascal_name: "Cigarette", categories: [e.COMMERCE, e.HEALTH], figma_category: a.COMMERCE, tags: ["*new*", "smoking", "tobacco"], codepoint: 60816, published_in: 2.1, updated_in: 2.1 }, { name: "cigarette-slash", pascal_name: "CigaretteSlash", categories: [e.COMMERCE, e.HEALTH], figma_category: a.COMMERCE, tags: ["*new*", "non-smoking", "tobacco"], codepoint: 60818, published_in: 2.1, updated_in: 2.1 }, { name: "circle", pascal_name: "Circle", categories: [e.DESIGN], figma_category: a.DESIGN, tags: ["round", "shapes", "polygons"], codepoint: 57738, published_in: 1, updated_in: 1 }, { name: "circle-dashed", pascal_name: "CircleDashed", categories: [e.DESIGN], figma_category: a.DESIGN, tags: ["missing", "round", "shapes", "polygons"], codepoint: 58882, published_in: 1.2, updated_in: 1.2 }, { name: "circle-half", pascal_name: "CircleHalf", categories: [e.DESIGN, e.EDITOR], figma_category: a.DESIGN, tags: ["round", "shapes", "contrast", "brightness"], codepoint: 57740, published_in: 1, updated_in: 1.4 }, { name: "circle-half-tilt", pascal_name: "CircleHalfTilt", categories: [e.DESIGN, e.EDITOR], figma_category: a.DESIGN, tags: ["round", "shapes", "contrast", "brightness"], codepoint: 57742, published_in: 1, updated_in: 1.4 }, { name: "circle-notch", pascal_name: "CircleNotch", categories: [e.SYSTEM], figma_category: a.DESIGN, tags: ["round", "shapes", "loading", "loader", "spinner", "waiting", "progress"], codepoint: 60228, published_in: 1.4, updated_in: 1.4 }, { name: "circles-four", pascal_name: "CirclesFour", categories: [e.DESIGN], figma_category: a.DESIGN, tags: ["round", "shapes", "polygons", "4"], codepoint: 57744, published_in: 1, updated_in: 1 }, { name: "circles-three", pascal_name: "CirclesThree", categories: [e.DESIGN], figma_category: a.DESIGN, tags: ["round", "shapes", "polygons", "3", "asana"], codepoint: 57746, published_in: 1, updated_in: 1 }, { name: "circles-three-plus", pascal_name: "CirclesThreePlus", categories: [e.DESIGN], figma_category: a.DESIGN, tags: ["round", "shapes", "polygons", "3", "+"], codepoint: 57748, published_in: 1, updated_in: 1 }, { name: "circuitry", pascal_name: "Circuitry", categories: [e.DEVELOPMENT], figma_category: a.SYSTEM, tags: ["processor", "microchip", "computer", "circuit", "electronics", "motherboard"], codepoint: 59842, published_in: 2, updated_in: 2 }, { name: "city", pascal_name: "City", categories: [e.MAP, e.COMMERCE], figma_category: a.COMMERCE, tags: ["*new*", "skyline", "skyscrapers", "places", "locations", "buildings"], codepoint: 60010, published_in: 2.1, updated_in: 2.1 }, { name: "clipboard", pascal_name: "Clipboard", categories: [e.OFFICE, e.EDITOR, e.SYSTEM], figma_category: a.OFFICE, tags: ["copy", "copied", "checklist"], codepoint: 57750, published_in: 1, updated_in: 1 }, { name: "clipboard-text", pascal_name: "ClipboardText", categories: [e.OFFICE, e.EDITOR, e.SYSTEM], figma_category: a.OFFICE, tags: ["copy", "copied", "checklist"], codepoint: 57752, published_in: 1, updated_in: 1 }, { name: "clock", pascal_name: "Clock", categories: [e.SYSTEM, e.OBJECTS], figma_category: a.TIME, tags: ["times", "timer", "alarm", "schedule", "events", "watch"], codepoint: 57754, published_in: 1, updated_in: 1 }, { name: "clock-afternoon", pascal_name: "ClockAfternoon", categories: [e.SYSTEM], figma_category: a.TIME, tags: ["times", "timer", "alarm", "schedule", "events", "watch"], codepoint: 57756, published_in: 1, updated_in: 1 }, { name: "clock-clockwise", pascal_name: "ClockClockwise", categories: [e.SYSTEM], figma_category: a.TIME, tags: ["times", "timer", "alarm", "schedule", "events", "restore", "fast forward", "update"], codepoint: 57758, published_in: 1, updated_in: 1 }, { name: "clock-countdown", pascal_name: "ClockCountdown", categories: [e.SYSTEM], figma_category: a.TIME, tags: ["times", "timer", "alarm", "schedule", "events", "watch"], codepoint: 60716, published_in: 2, updated_in: 2 }, { name: "clock-counter-clockwise", pascal_name: "ClockCounterClockwise", categories: [e.SYSTEM], figma_category: a.TIME, tags: ["times", "timer", "alarm", "schedule", "events", "backup", "rewind", "history"], codepoint: 57760, published_in: 1, updated_in: 1 }, { name: "clock-user", pascal_name: "ClockUser", categories: [e.SYSTEM], figma_category: a.TIME, tags: ["*new*", "times", "timer", "shift", "schedule", "events", "watch"], codepoint: 60908, published_in: 2.1, updated_in: 2.1 }, { name: "closed-captioning", pascal_name: "ClosedCaptioning", categories: [e.MEDIA], figma_category: a.MEDIA, tags: ["subtitles", "television", "tv", "transcribed", "transcription", "accessibility", "a11y"], codepoint: 57764, published_in: 1, updated_in: 1 }, { name: "cloud", pascal_name: "Cloud", categories: [e.SYSTEM, e.WEATHER], figma_category: a.WEATHER, tags: ["serverless", "backup", "storage", "meteorology", "cloudy", "overcast"], codepoint: 57770, published_in: 1, updated_in: 1.4 }, { name: "cloud-arrow-down", pascal_name: "CloudArrowDown", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["serverless", "backup", "storage", "download"], codepoint: 57772, published_in: 1, updated_in: 1.4 }, { name: "cloud-arrow-up", pascal_name: "CloudArrowUp", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["serverless", "backup", "storage", "upload"], codepoint: 57774, published_in: 1, updated_in: 1.4 }, { name: "cloud-check", pascal_name: "CloudCheck", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["serverless", "backup", "storage", "sync", "synchronized"], codepoint: 57776, published_in: 1, updated_in: 1.4 }, { name: "cloud-fog", pascal_name: "CloudFog", categories: [e.WEATHER], figma_category: a.WEATHER, tags: ["meteorology", "cloudy", "overcast", "foggy", "mist", "haze"], codepoint: 58684, published_in: 1.1, updated_in: 1.4 }, { name: "cloud-lightning", pascal_name: "CloudLightning", categories: [e.WEATHER], figma_category: a.WEATHER, tags: ["meteorology", "cloudy", "overcast", "stormy", "thunderstorm"], codepoint: 57778, published_in: 1, updated_in: 1.4 }, { name: "cloud-moon", pascal_name: "CloudMoon", categories: [e.WEATHER], figma_category: a.WEATHER, tags: ["meteorology", "cloudy", "partly cloudy", "night", "evening"], codepoint: 58686, published_in: 1.1, updated_in: 1.1 }, { name: "cloud-rain", pascal_name: "CloudRain", categories: [e.WEATHER], figma_category: a.WEATHER, tags: ["meteorology", "cloudy", "rainy", "raining", "stormy", "rainstorm"], codepoint: 57780, published_in: 1, updated_in: 1.4 }, { name: "cloud-slash", pascal_name: "CloudSlash", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["serverless", "backup", "storage", "sync", "disabled"], codepoint: 57782, published_in: 1, updated_in: 1 }, { name: "cloud-snow", pascal_name: "CloudSnow", categories: [e.WEATHER], figma_category: a.WEATHER, tags: ["meteorology", "cloudy", "snowy", "snowing", "stormy", "snowstorm"], codepoint: 57784, published_in: 1, updated_in: 1.4 }, { name: "cloud-sun", pascal_name: "CloudSun", categories: [e.WEATHER], figma_category: a.WEATHER, tags: ["meteorology", "cloudy", "partly cloudy", "partly sunny"], codepoint: 58688, published_in: 1.1, updated_in: 1.1 }, { name: "cloud-warning", pascal_name: "CloudWarning", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["serverless", "backup", "storage", "errors"], codepoint: 60056, published_in: 2, updated_in: 2 }, { name: "cloud-x", pascal_name: "CloudX", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["serverless", "backup", "storage", "errors"], codepoint: 60054, published_in: 2, updated_in: 2 }, { name: "clover", pascal_name: "Clover", categories: [e.NATURE], figma_category: a.WEATHER, tags: ["*new*", "four leaf clover", "plants", "luck", "lucky", "irish"], codepoint: 60872, published_in: 2.1, updated_in: 2.1 }, { name: "club", pascal_name: "Club", categories: [e.GAMES], figma_category: a.GAMES, tags: ["clubs", "suits", "cards", "gambling", "casino", "gaming"], codepoint: 57786, published_in: 1, updated_in: 1 }, { name: "coat-hanger", pascal_name: "CoatHanger", categories: [e.COMMERCE, e.OBJECTS], figma_category: a.COMMERCE, tags: ["clothing", "clothes", "closet"], codepoint: 59390, published_in: 1.4, updated_in: 1.4 }, { name: "coda-logo", pascal_name: "CodaLogo", categories: [e.BRAND], figma_category: a.BRAND, tags: ["project management", "productivity", "documentation", "wiki", "logos"], codepoint: 59342, published_in: 2, updated_in: 2 }, { name: "code", pascal_name: "Code", categories: [e.DEVELOPMENT, e.EDITOR], figma_category: a.DEVELOPMENT, tags: ["angle brackets", "angle braces", "snippets"], codepoint: 57788, published_in: 1, updated_in: 1 }, { name: "code-block", pascal_name: "CodeBlock", categories: [e.DEVELOPMENT, e.EDITOR], figma_category: a.DEVELOPMENT, tags: ["angle brackets", "angle braces", "snippets"], codepoint: 60158, published_in: 2, updated_in: 2 }, { name: "code-simple", pascal_name: "CodeSimple", categories: [e.DEVELOPMENT, e.EDITOR], figma_category: a.DEVELOPMENT, tags: ["angle brackets", "angle braces", "snippets"], codepoint: 57790, published_in: 1, updated_in: 1 }, { name: "codepen-logo", pascal_name: "CodepenLogo", categories: [e.BRAND, e.DEVELOPMENT], figma_category: a.BRAND, tags: ["ide", "logos"], codepoint: 59768, published_in: 1.4, updated_in: 1.4 }, { name: "codesandbox-logo", pascal_name: "CodesandboxLogo", categories: [e.BRAND, e.DEVELOPMENT], figma_category: a.BRAND, tags: ["ide", "logos"], codepoint: 59910, published_in: 1.4, updated_in: 1.4 }, { name: "coffee", pascal_name: "Coffee", categories: [e.COMMERCE, e.OBJECTS, e.MAP], figma_category: a.COMMERCE, tags: ["tea", "java", "beverages", "drinks", "cafe", "cup", "mug", "espresso", "cappuccino", "latte", "places", "locations", "bars", "restaurants", "food", "dining"], codepoint: 57794, published_in: 1, updated_in: 1 }, { name: "coffee-bean", pascal_name: "CoffeeBean", categories: [e.COMMERCE, e.MAP, e.NATURE], figma_category: a.COMMERCE, tags: ["*new*", "tea", "java", "beverages", "drinks", "cafe", "cup", "mug", "espresso", "cappuccino", "latte", "places", "locations", "bars", "restaurants", "food", "dining"], codepoint: 57792, published_in: 2.1, updated_in: 2.1 }, { name: "coin", pascal_name: "Coin", categories: [e.COMMERCE, e.FINANCE], figma_category: a.COMMERCE, tags: ["coins", "cents", "change", "money", "currency", "payment", "paying", "purchase", "price", "sell"], codepoint: 58894, published_in: 1.2, updated_in: 1.2 }, { name: "coin-vertical", pascal_name: "CoinVertical", categories: [e.COMMERCE, e.FINANCE], figma_category: a.COMMERCE, tags: ["cents", "change", "money", "currency", "payment", "paying", "purchase", "price", "sell"], codepoint: 60232, published_in: 1.4, updated_in: 1.4 }, { name: "coins", pascal_name: "Coins", categories: [e.COMMERCE, e.FINANCE], figma_category: a.COMMERCE, tags: ["cents", "change", "money", "currency", "payment", "paying", "purchase", "price", "sell"], codepoint: 59278, published_in: 1.4, updated_in: 1.4 }, { name: "columns", pascal_name: "Columns", categories: [e.DESIGN], figma_category: a.DESIGN, tags: ["2", "shapes", "polygons", "box", "stack", "list", "table", "cards"], codepoint: 58694, published_in: 1.1, updated_in: 1.1 }, { name: "columns-plus-left", pascal_name: "ColumnsPlusLeft", categories: [e.DESIGN], figma_category: a.DESIGN, tags: ["*new*", "2", "shapes", "polygons", "box", "stack", "list", "table", "cards", "prepend", "insert"], codepoint: 58692, published_in: 2.1, updated_in: 2.1 }, { name: "columns-plus-right", pascal_name: "ColumnsPlusRight", categories: [e.DESIGN], figma_category: a.DESIGN, tags: ["*new*", "2", "shapes", "polygons", "box", "stack", "list", "table", "cards", "append", "insert"], codepoint: 58690, published_in: 2.1, updated_in: 2.1 }, { name: "command", pascal_name: "Command", categories: [e.EDITOR, e.SYSTEM], figma_category: a.SYSTEM, tags: ["apple", "keyboard", "shortcut", "modifier", "looped square", "bowen knot", "saint john's arms"], codepoint: 57796, published_in: 1, updated_in: 1 }, { name: "compass", pascal_name: "Compass", categories: [e.MAP, e.OBJECTS], figma_category: a.MAP, tags: ["navigation", "directions", "maps", "safari", "apple"], codepoint: 57800, published_in: 1, updated_in: 1 }, { name: "compass-rose", pascal_name: "CompassRose", categories: [e.MAP, e.OBJECTS], figma_category: a.MAP, tags: ["*new*", "navigation", "directions", "maps", "cardinal", "cartography"], codepoint: 57798, published_in: 2.1, updated_in: 2.1 }, { name: "compass-tool", pascal_name: "CompassTool", categories: [e.DESIGN, e.OBJECTS], figma_category: a.DESIGN, tags: ["drawing", "geometry", "trigonometry", "degrees", "radians", "measurement", "protractor", "compass", "arc"], codepoint: 59918, published_in: 2, updated_in: 2 }, { name: "computer-tower", pascal_name: "ComputerTower", categories: [e.DEVELOPMENT, e.OBJECTS], figma_category: a.SYSTEM, tags: ["desktop", "pc", "imac"], codepoint: 58696, published_in: 1.1, updated_in: 1.1 }, { name: "confetti", pascal_name: "Confetti", categories: [e.COMMUNICATION], figma_category: a.GAMES, tags: ["tada", "party", "emoji"], codepoint: 59418, published_in: 1.4, updated_in: 1.4 }, { name: "contactless-payment", pascal_name: "ContactlessPayment", categories: [e.COMMERCE], figma_category: a.COMMERCE, tags: ["purchase", "credit card", "nfc"], codepoint: 60738, published_in: 2, updated_in: 2 }, { name: "control", pascal_name: "Control", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["ctrl", "key", "keyboard", "shortcut", "caret"], codepoint: 60582, published_in: 2, updated_in: 2 }, { name: "cookie", pascal_name: "Cookie", categories: [e.MAP, e.OBJECTS, e.DEVELOPMENT], figma_category: a.COMMERCE, tags: ["privacy", "dessert", "food", "dining"], codepoint: 59082, published_in: 1.3, updated_in: 1.3 }, { name: "cooking-pot", pascal_name: "CookingPot", categories: [e.OBJECTS, e.COMMERCE], figma_category: a.COMMERCE, tags: ["stew", "kitchen", "steaming", "restaurants", "food", "dining"], codepoint: 59236, published_in: 1.3, updated_in: 1.3 }, { name: "copy", pascal_name: "Copy", categories: [e.EDITOR, e.SYSTEM], figma_category: a.OFFICE, tags: ["duplicated", "copied", "clipboard"], codepoint: 57802, published_in: 1, updated_in: 1 }, { name: "copy-simple", pascal_name: "CopySimple", categories: [e.EDITOR, e.SYSTEM], figma_category: a.OFFICE, tags: ["duplicated", "copied", "clipboard"], codepoint: 57804, published_in: 1, updated_in: 1 }, { name: "copyleft", pascal_name: "Copyleft", categories: [e.COMMERCE, e.MEDIA], figma_category: a.MEDIA, tags: ["\u{1F12F}", "intellectual property", "copr.", "symbol"], codepoint: 59498, published_in: 1.4, updated_in: 1.4 }, { name: "copyright", pascal_name: "Copyright", categories: [e.COMMERCE, e.MEDIA], figma_category: a.MEDIA, tags: ["\xA9", "intellectual property", "copr.", "symbol"], codepoint: 58698, published_in: 1.1, updated_in: 1.1 }, { name: "corners-in", pascal_name: "CornersIn", categories: [e.SYSTEM], figma_category: a.MEDIA, tags: ["*updated*", "collapse", "windowed", "minimized"], codepoint: 57806, published_in: 1, updated_in: 2.1 }, { name: "corners-out", pascal_name: "CornersOut", categories: [e.SYSTEM], figma_category: a.MEDIA, tags: ["*updated*", "expand", "fullscreen", "maximized"], codepoint: 57808, published_in: 1, updated_in: 2.1 }, { name: "couch", pascal_name: "Couch", categories: [e.OBJECTS, e.COMMERCE], figma_category: a.COMMERCE, tags: ["furniture", "seat"], codepoint: 59382, published_in: 2, updated_in: 2 }, { name: "court-basketball", pascal_name: "CourtBasketball", categories: [e.GAMES, e.HEALTH, e.MAP], figma_category: a.GAMES, tags: ["*new*", "sports", "nba"], codepoint: 60982, published_in: 2.1, updated_in: 2.1 }, { name: "cow", pascal_name: "Cow", categories: [e.COMMERCE, e.NATURE], figma_category: a.WEATHER, tags: ["*new*", "animals", "livestock", "beef", "bull", "milk", "dairy"], codepoint: 60094, published_in: 2.1, updated_in: 2.1 }, { name: "cowboy-hat", pascal_name: "CowboyHat", categories: [e.COMMERCE, e.OBJECTS], figma_category: a.COMMERCE, tags: ["*new*", "clothes", "clothing", "stetson"], codepoint: 60690, published_in: 2.1, updated_in: 2.1 }, { name: "cpu", pascal_name: "Cpu", categories: [e.DEVELOPMENT], figma_category: a.DEVELOPMENT, tags: ["processor", "microchip", "computer", "circuit"], codepoint: 58896, published_in: 1.2, updated_in: 1.2 }, { name: "crane", pascal_name: "Crane", categories: [e.COMMERCE, e.DEVELOPMENT], figma_category: a.COMMERCE, tags: ["*new*", "construction", "industry"], codepoint: 60744, published_in: 2.1, updated_in: 2.1 }, { name: "crane-tower", pascal_name: "CraneTower", categories: [e.COMMERCE, e.DEVELOPMENT], figma_category: a.COMMERCE, tags: ["*new*", "construction", "industry"], codepoint: 60744, published_in: 2.1, updated_in: 2.1 }, { name: "credit-card", pascal_name: "CreditCard", categories: [e.COMMERCE, e.FINANCE], figma_category: a.COMMERCE, tags: ["debit", "visa", "mastercard", "money", "payment", "paying", "purchase", "swipe"], codepoint: 57810, published_in: 1, updated_in: 1 }, { name: "cricket", pascal_name: "Cricket", categories: [e.GAMES, e.HEALTH], figma_category: a.GAMES, tags: ["*new*", "sports", "ball", "bat"], codepoint: 60946, published_in: 2.1, updated_in: 2.1 }, { name: "crop", pascal_name: "Crop", categories: [e.DESIGN, e.EDITOR], figma_category: a.DESIGN, tags: ["photography", "clip", "screenshots"], codepoint: 57812, published_in: 1, updated_in: 1 }, { name: "cross", pascal_name: "Cross", categories: [e.DESIGN, e.COMMUNICATION], figma_category: a.COMMUNICATION, tags: ["dagger", "crucifix", "christ", "christianity", "religion", "worship", "symbol"], codepoint: 59552, published_in: 2, updated_in: 2 }, { name: "crosshair", pascal_name: "Crosshair", categories: [e.MAP, e.SYSTEM], figma_category: a.MAP, tags: ["geolocation", "gps", "aiming", "targeting"], codepoint: 57814, published_in: 1, updated_in: 1 }, { name: "crosshair-simple", pascal_name: "CrosshairSimple", categories: [e.MAP, e.SYSTEM], figma_category: a.MAP, tags: ["geolocation", "gps", "aiming", "targeting"], codepoint: 57816, published_in: 1, updated_in: 1 }, { name: "crown", pascal_name: "Crown", categories: [e.GAMES, e.OBJECTS], figma_category: a.GAMES, tags: ["*updated*", "king", "queen", "royalty", "monarch", "ruler", "leader", "chess"], codepoint: 58900, published_in: 1.2, updated_in: 2.1 }, { name: "crown-cross", pascal_name: "CrownCross", categories: [e.GAMES, e.OBJECTS], figma_category: a.GAMES, tags: ["*new*", "king", "queen", "royalty", "monarch", "ruler", "leader", "chess"], codepoint: 61022, published_in: 2.1, updated_in: 2.1 }, { name: "crown-simple", pascal_name: "CrownSimple", categories: [e.GAMES, e.OBJECTS], figma_category: a.GAMES, tags: ["*updated*", "king", "queen", "royalty", "monarch", "ruler", "leader", "chess"], codepoint: 58902, published_in: 1.2, updated_in: 2.1 }, { name: "cube", pascal_name: "Cube", categories: [e.DESIGN, e.GAMES, e.OBJECTS], figma_category: a.DESIGN, tags: ["square", "box", "3d", "volume", "blocks"], codepoint: 57818, published_in: 1, updated_in: 1 }, { name: "cube-focus", pascal_name: "CubeFocus", categories: [e.GAMES, e.OBJECTS], figma_category: a.GAMES, tags: ["augmented reality", "ar", "virual reality", "vr", "3d", "scan"], codepoint: 60682, published_in: 2, updated_in: 2 }, { name: "cube-transparent", pascal_name: "CubeTransparent", categories: [e.DESIGN, e.GAMES, e.OBJECTS], figma_category: a.DESIGN, tags: ["square", "box", "3d", "volume", "blocks", "necker"], codepoint: 60540, published_in: 2, updated_in: 2 }, { name: "currency-btc", pascal_name: "CurrencyBtc", categories: [e.COMMERCE, e.FINANCE], figma_category: a.COMMERCE, tags: ["money", "btc", "bitcoin", "crypto", "cryptocurrency", "payment", "paying", "purchase"], codepoint: 58904, published_in: 1.2, updated_in: 1.2 }, { name: "currency-circle-dollar", pascal_name: "CurrencyCircleDollar", categories: [e.COMMERCE, e.FINANCE], figma_category: a.COMMERCE, tags: ["money", "usd", "payment", "paying", "purchase"], codepoint: 58700, published_in: 1.1, updated_in: 1.1 }, { name: "currency-cny", pascal_name: "CurrencyCny", categories: [e.COMMERCE, e.FINANCE], figma_category: a.COMMERCE, tags: ["money", "yuan", "payment", "paying", "purchase"], codepoint: 58702, published_in: 1.1, updated_in: 1.1 }, { name: "currency-dollar", pascal_name: "CurrencyDollar", categories: [e.COMMERCE, e.FINANCE], figma_category: a.COMMERCE, tags: ["money", "usd", "payment", "paying", "purchase"], codepoint: 58704, published_in: 1.1, updated_in: 1.1 }, { name: "currency-dollar-simple", pascal_name: "CurrencyDollarSimple", categories: [e.COMMERCE, e.FINANCE], figma_category: a.COMMERCE, tags: ["money", "usd", "payment", "paying", "purchase"], codepoint: 58706, published_in: 1.1, updated_in: 1.1 }, { name: "currency-eth", pascal_name: "CurrencyEth", categories: [e.COMMERCE, e.FINANCE], figma_category: a.COMMERCE, tags: ["money", "ethereum", "crypto", "cryptocurrency", "payment", "paying", "purchase"], codepoint: 60122, published_in: 1.4, updated_in: 1.4 }, { name: "currency-eur", pascal_name: "CurrencyEur", categories: [e.COMMERCE, e.FINANCE], figma_category: a.COMMERCE, tags: ["money", "euros", "payment", "paying", "purchase"], codepoint: 58708, published_in: 1.1, updated_in: 1.1 }, { name: "currency-gbp", pascal_name: "CurrencyGbp", categories: [e.COMMERCE, e.FINANCE], figma_category: a.COMMERCE, tags: ["money", "pounds sterling", "payment", "paying", "purchase"], codepoint: 58710, published_in: 1.1, updated_in: 1.1 }, { name: "currency-inr", pascal_name: "CurrencyInr", categories: [e.COMMERCE, e.FINANCE], figma_category: a.COMMERCE, tags: ["money", "rupees", "payment", "paying", "purchase"], codepoint: 58712, published_in: 1.1, updated_in: 1.1 }, { name: "currency-jpy", pascal_name: "CurrencyJpy", categories: [e.COMMERCE, e.FINANCE], figma_category: a.COMMERCE, tags: ["money", "yen", "payment", "paying", "purchase"], codepoint: 58714, published_in: 1.1, updated_in: 1.1 }, { name: "currency-krw", pascal_name: "CurrencyKrw", categories: [e.COMMERCE, e.FINANCE], figma_category: a.COMMERCE, tags: ["money", "won", "payment", "paying", "purchase"], codepoint: 58716, published_in: 1.1, updated_in: 1.1 }, { name: "currency-kzt", pascal_name: "CurrencyKzt", categories: [e.COMMERCE, e.FINANCE], figma_category: a.COMMERCE, tags: ["money", "kazakhstan", "tenge", "payment", "paying", "purchase"], codepoint: 60492, published_in: 1.4, updated_in: 1.4 }, { name: "currency-ngn", pascal_name: "CurrencyNgn", categories: [e.COMMERCE, e.FINANCE], figma_category: a.COMMERCE, tags: ["money", "nigeria", "naira", "payment", "paying", "purchase"], codepoint: 60242, published_in: 1.4, updated_in: 1.4 }, { name: "currency-rub", pascal_name: "CurrencyRub", categories: [e.COMMERCE, e.FINANCE], figma_category: a.COMMERCE, tags: ["money", "rubles", "payment", "paying", "purchase"], codepoint: 58718, published_in: 1.1, updated_in: 1.1 }, { name: "cursor", pascal_name: "Cursor", categories: [e.DESIGN, e.SYSTEM], figma_category: a.SYSTEM, tags: ["pointer", "arrowhead", "mouse", "click"], codepoint: 57820, published_in: 1, updated_in: 2 }, { name: "cursor-click", pascal_name: "CursorClick", categories: [e.DESIGN, e.SYSTEM], figma_category: a.SYSTEM, tags: ["pointer", "arrowhead", "mouse"], codepoint: 59336, published_in: 2, updated_in: 2 }, { name: "cursor-text", pascal_name: "CursorText", categories: [e.EDITOR, e.SYSTEM], figma_category: a.OFFICE, tags: ["i-beam", "input", "select"], codepoint: 59352, published_in: 1.4, updated_in: 1.4 }, { name: "cylinder", pascal_name: "Cylinder", categories: [e.DESIGN], figma_category: a.DESIGN, tags: ["shapes", "tube"], codepoint: 59644, published_in: 1.4, updated_in: 1.4 }, { name: "database", pascal_name: "Database", categories: [e.DEVELOPMENT, e.SYSTEM], figma_category: a.DEVELOPMENT, tags: ["saved", "saving", "archived", "archiving", "archival", "hard disk", "storage", "hdd", "servers", "databases"], codepoint: 57822, published_in: 1, updated_in: 1 }, { name: "desk", pascal_name: "Desk", categories: [e.COMMERCE, e.OBJECTS, e.OFFICE], figma_category: a.COMMERCE, tags: ["*new*", "furniture", "workspace", "table"], codepoint: 60694, published_in: 2.1, updated_in: 2.1 }, { name: "desktop", pascal_name: "Desktop", categories: [e.DEVELOPMENT, e.OBJECTS], figma_category: a.SYSTEM, tags: ["computer", "pc", "imac", "tower"], codepoint: 58720, published_in: 1.1, updated_in: 1.1 }, { name: "desktop-tower", pascal_name: "DesktopTower", categories: [e.DEVELOPMENT, e.OBJECTS], figma_category: a.SYSTEM, tags: ["*updated*", "computer", "pc", "imac"], codepoint: 58722, published_in: 1.1, updated_in: 2.1 }, { name: "detective", pascal_name: "Detective", categories: [e.PEOPLE, e.SYSTEM], figma_category: a.SECURITY, tags: ["incognito", "police", "law enforcement", "spy", "secret"], codepoint: 59454, published_in: 1.4, updated_in: 1.4 }, { name: "dev-to-logo", pascal_name: "DevToLogo", categories: [e.BRAND, e.DEVELOPMENT], figma_category: a.BRAND, tags: ["reading", "writing", "social media", "logos"], codepoint: 60686, published_in: 2, updated_in: 2 }, { name: "device-mobile", pascal_name: "DeviceMobile", categories: [e.OBJECTS], figma_category: a.SYSTEM, tags: ["cellphone", "cellular"], codepoint: 57824, published_in: 1, updated_in: 1 }, { name: "device-mobile-camera", pascal_name: "DeviceMobileCamera", categories: [e.OBJECTS], figma_category: a.SYSTEM, tags: ["cellphone", "cellular"], codepoint: 57826, published_in: 1, updated_in: 1 }, { name: "device-mobile-slash", pascal_name: "DeviceMobileSlash", categories: [e.OBJECTS, e.SYSTEM], figma_category: a.SYSTEM, tags: ["*new*", "cellphone", "cellular"], codepoint: 60998, published_in: 2.1, updated_in: 2.1 }, { name: "device-mobile-speaker", pascal_name: "DeviceMobileSpeaker", categories: [e.OBJECTS], figma_category: a.SYSTEM, tags: ["cellphone", "cellular"], codepoint: 57828, published_in: 1, updated_in: 1 }, { name: "device-rotate", pascal_name: "DeviceRotate", categories: [e.OBJECTS, e.SYSTEM], figma_category: a.SYSTEM, tags: ["*new*", "orientation", "landscape", "portrait", "spin", "flip"], codepoint: 60914, published_in: 2.1, updated_in: 2.1 }, { name: "device-tablet", pascal_name: "DeviceTablet", categories: [e.OBJECTS], figma_category: a.SYSTEM, tags: ["cellphone", "cellular", "ipad", "phablet"], codepoint: 57830, published_in: 1, updated_in: 1 }, { name: "device-tablet-camera", pascal_name: "DeviceTabletCamera", categories: [e.OBJECTS], figma_category: a.SYSTEM, tags: ["cellphone", "cellular", "ipad", "phablet"], codepoint: 57832, published_in: 1, updated_in: 1 }, { name: "device-tablet-speaker", pascal_name: "DeviceTabletSpeaker", categories: [e.OBJECTS], figma_category: a.SYSTEM, tags: ["cellphone", "cellular", "ipad", "phablet"], codepoint: 57834, published_in: 1, updated_in: 1 }, { name: "devices", pascal_name: "Devices", categories: [e.OBJECTS], figma_category: a.SYSTEM, tags: ["responsive", "cellphone", "cellular", "tablet", "destop"], codepoint: 60324, published_in: 2, updated_in: 2 }, { name: "diamond", pascal_name: "Diamond", categories: [e.DESIGN, e.GAMES], figma_category: a.GAMES, tags: ["rectangle", "shapes", "polygons", "diamonds", "suits", "cards", "gambling", "casino", "gaming"], codepoint: 57836, published_in: 1, updated_in: 1 }, { name: "diamonds-four", pascal_name: "DiamondsFour", categories: [e.DESIGN], figma_category: a.DESIGN, tags: ["shapes", "grid", "component"], codepoint: 59636, published_in: 1.4, updated_in: 1.4 }, { name: "dice-five", pascal_name: "DiceFive", categories: [e.GAMES, e.OBJECTS], figma_category: a.GAMES, tags: ["die", "rolling", "gamble", "gambling", "casino", "gaming", "5"], codepoint: 57838, published_in: 1, updated_in: 1 }, { name: "dice-four", pascal_name: "DiceFour", categories: [e.GAMES, e.OBJECTS], figma_category: a.GAMES, tags: ["die", "rolling", "gamble", "gambling", "casino", "gaming", "4"], codepoint: 57840, published_in: 1, updated_in: 1 }, { name: "dice-one", pascal_name: "DiceOne", categories: [e.GAMES, e.OBJECTS], figma_category: a.GAMES, tags: ["die", "rolling", "gamble", "gambling", "casino", "gaming", "1"], codepoint: 57842, published_in: 1, updated_in: 1 }, { name: "dice-six", pascal_name: "DiceSix", categories: [e.GAMES, e.OBJECTS], figma_category: a.GAMES, tags: ["die", "rolling", "gamble", "gambling", "casino", "gaming", "6"], codepoint: 57844, published_in: 1, updated_in: 1 }, { name: "dice-three", pascal_name: "DiceThree", categories: [e.GAMES, e.OBJECTS], figma_category: a.GAMES, tags: ["die", "rolling", "gamble", "gambling", "casino", "gaming", "3"], codepoint: 57846, published_in: 1, updated_in: 1 }, { name: "dice-two", pascal_name: "DiceTwo", categories: [e.GAMES, e.OBJECTS], figma_category: a.GAMES, tags: ["die", "rolling", "gamble", "gambling", "casino", "gaming", "2"], codepoint: 57848, published_in: 1, updated_in: 1 }, { name: "disc", pascal_name: "Disc", categories: [e.DEVELOPMENT, e.MEDIA, e.OBJECTS], figma_category: a.MEDIA, tags: ["cd-rom", "compact disk", "album", "record"], codepoint: 58724, published_in: 1.1, updated_in: 1.1 }, { name: "disco-ball", pascal_name: "DiscoBall", categories: [e.GAMES, e.MAP, e.OBJECTS], figma_category: a.GAMES, tags: ["*new*", "danging", "club", "70s"], codepoint: 60824, published_in: 2.1, updated_in: 2.1 }, { name: "discord-logo", pascal_name: "DiscordLogo", categories: [e.BRAND, e.COMMUNICATION], figma_category: a.BRAND, tags: ["logos", "messages", "messaging", "chat"], codepoint: 58906, published_in: 1.2, updated_in: 1.2 }, { name: "divide", pascal_name: "Divide", categories: [e.DEVELOPMENT, e.FINANCE], figma_category: a.FINANCE, tags: ["division", "divisor", "dividend", "quotient", "mathematics", "arithmetic", "calculator"], codepoint: 57850, published_in: 1, updated_in: 1 }, { name: "dna", pascal_name: "Dna", categories: [e.HEALTH, e.NATURE], figma_category: a.HEALTH, tags: ["double helix", "gene", "genetics"], codepoint: 59684, published_in: 2, updated_in: 2 }, { name: "dog", pascal_name: "Dog", categories: [e.NATURE], figma_category: a.WEATHER, tags: ["pets", "animals", "puppy"], codepoint: 59210, published_in: 1.3, updated_in: 1.3 }, { name: "door", pascal_name: "Door", categories: [e.OBJECTS], figma_category: a.COMMERCE, tags: ["entrance", "exit"], codepoint: 58908, published_in: 1.2, updated_in: 1.2 }, { name: "door-open", pascal_name: "DoorOpen", categories: [e.OBJECTS], figma_category: a.COMMERCE, tags: ["entrance", "exit"], codepoint: 59366, published_in: 2, updated_in: 2 }, { name: "dot", pascal_name: "Dot", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["dots", "circles", "shapes", "polygons"], codepoint: 60638, published_in: 2, updated_in: 2 }, { name: "dot-outline", pascal_name: "DotOutline", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["dots", "circles", "shapes", "polygons"], codepoint: 60640, published_in: 2, updated_in: 2 }, { name: "dots-nine", pascal_name: "DotsNine", categories: [e.DESIGN], figma_category: a.SYSTEM, tags: ["grid", "circles", "shapes", "polygons", "9"], codepoint: 57852, published_in: 1, updated_in: 1 }, { name: "dots-six", pascal_name: "DotsSix", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["*updated*", "drag handle", "knurling", "circles", "shapes", "polygons", "6"], codepoint: 59284, published_in: 1.3, updated_in: 2.1 }, { name: "dots-six-vertical", pascal_name: "DotsSixVertical", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["*updated*", "drag handle", "knurling", "circles", "shapes", "polygons", "6"], codepoint: 60130, published_in: 1.3, updated_in: 2.1 }, { name: "dots-three", pascal_name: "DotsThree", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["menu", "overflow", "circles", "shapes", "polygons", "3", "ellipsis", "ellipses", "more"], codepoint: 57854, published_in: 1, updated_in: 1 }, { name: "dots-three-circle", pascal_name: "DotsThreeCircle", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["menu", "overflow", "circles", "shapes", "polygons", "3", "ellipsis", "ellipses", "more"], codepoint: 57856, published_in: 1, updated_in: 1 }, { name: "dots-three-circle-vertical", pascal_name: "DotsThreeCircleVertical", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["menu", "overflow", "circles", "shapes", "polygons", "3", "ellipsis", "ellipses", "more"], codepoint: 57858, published_in: 1, updated_in: 1 }, { name: "dots-three-outline", pascal_name: "DotsThreeOutline", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["menu", "overflow", "circles", "shapes", "polygons", "3", "ellipsis", "ellipses", "more"], codepoint: 57860, published_in: 1, updated_in: 1 }, { name: "dots-three-outline-vertical", pascal_name: "DotsThreeOutlineVertical", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["menu", "overflow", "circles", "shapes", "polygons", "3", "ellipsis", "ellipses", "more"], codepoint: 57862, published_in: 1, updated_in: 1 }, { name: "dots-three-vertical", pascal_name: "DotsThreeVertical", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["menu", "overflow", "circles", "shapes", "polygons", "3", "ellipsis", "ellipses", "more"], codepoint: 57864, published_in: 1, updated_in: 1 }, { name: "download", pascal_name: "Download", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["saved", "saving", "archived", "archiving", "archival", "downloaded", "downloading", "hard drive", "disk"], codepoint: 57866, published_in: 1, updated_in: 1.4 }, { name: "download-simple", pascal_name: "DownloadSimple", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["*updated*", "saved", "saving", "archived", "archiving", "archival", "downloaded", "downloading", "hard drive", "disk", "import"], codepoint: 57868, published_in: 1, updated_in: 2.1 }, { name: "dress", pascal_name: "Dress", categories: [e.COMMERCE, e.OBJECTS], figma_category: a.COMMERCE, tags: ["clothes", "clothing"], codepoint: 60030, published_in: 2, updated_in: 2 }, { name: "dresser", pascal_name: "Dresser", categories: [e.COMMERCE, e.OBJECTS], figma_category: a.COMMERCE, tags: ["*new*", "furniture", "bedroom", "storage", "drawers", "wardrobe"], codepoint: 59726, published_in: 2.1, updated_in: 2.1 }, { name: "dribbble-logo", pascal_name: "DribbbleLogo", categories: [e.BRAND, e.DESIGN], figma_category: a.BRAND, tags: ["logos", "round", "basketball", "sports", "design"], codepoint: 57870, published_in: 1, updated_in: 1.4 }, { name: "drone", pascal_name: "Drone", categories: [e.GAMES, e.OBJECTS, e.DEVELOPMENT], figma_category: a.GAMES, tags: ["*new*", "aerial", "uav", "photography", "remote"], codepoint: 60788, published_in: 2.1, updated_in: 2.1 }, { name: "drop", pascal_name: "Drop", categories: [e.NATURE, e.WEATHER], figma_category: a.WEATHER, tags: ["droplet", "teardrop", "raindrop", "raining", "meteorology", "water", "blur"], codepoint: 57872, published_in: 1, updated_in: 1 }, { name: "drop-half", pascal_name: "DropHalf", categories: [e.DESIGN, e.EDITOR, e.NATURE, e.WEATHER], figma_category: a.DESIGN, tags: ["droplet", "teardrop", "raindrop", "humidity", "water", "contrast", "brightness"], codepoint: 58726, published_in: 1.1, updated_in: 1.4 }, { name: "drop-half-bottom", pascal_name: "DropHalfBottom", categories: [e.DESIGN, e.EDITOR, e.NATURE, e.WEATHER], figma_category: a.DESIGN, tags: ["droplet", "teardrop", "raindrop", "humidity", "water", "contrast", "brightness"], codepoint: 60224, published_in: 1.4, updated_in: 1.4 }, { name: "drop-simple", pascal_name: "DropSimple", categories: [e.DESIGN, e.EDITOR, e.NATURE, e.WEATHER], figma_category: a.WEATHER, tags: ["*new*", "droplet", "teardrop", "raindrop", "raining", "humidity", "meteorology", "water", "blur"], codepoint: 60978, published_in: 2.1, updated_in: 2.1 }, { name: "drop-slash", pascal_name: "DropSlash", categories: [e.DESIGN, e.EDITOR, e.NATURE, e.WEATHER], figma_category: a.DESIGN, tags: ["*new*", "droplet", "teardrop", "raindrop", "raining", "humidity", "meteorology", "water", "blur", "disabled"], codepoint: 59732, published_in: 2.1, updated_in: 2.1 }, { name: "dropbox-logo", pascal_name: "DropboxLogo", categories: [e.BRAND], figma_category: a.BRAND, tags: ["cloud", "storage", "backup", "logos"], codepoint: 59344, published_in: 2, updated_in: 2 }, { name: "ear", pascal_name: "Ear", categories: [e.MEDIA, e.SYSTEM], figma_category: a.MEDIA, tags: ["hearing", "audio", "sound"], codepoint: 59148, published_in: 1.3, updated_in: 1.3 }, { name: "ear-slash", pascal_name: "EarSlash", categories: [e.MEDIA, e.SYSTEM], figma_category: a.MEDIA, tags: ["hearing", "audio", "sound", "mute", "accessible"], codepoint: 59150, published_in: 1.3, updated_in: 1.3 }, { name: "egg", pascal_name: "Egg", categories: [e.COMMERCE, e.NATURE], figma_category: a.COMMERCE, tags: ["chicken", "food", "meal", "baby", "hatch"], codepoint: 59410, published_in: 1.4, updated_in: 1.4 }, { name: "egg-crack", pascal_name: "EggCrack", categories: [e.COMMERCE, e.NATURE], figma_category: a.COMMERCE, tags: ["chicken", "food", "meal", "baby", "hatch", "break"], codepoint: 60260, published_in: 1.4, updated_in: 1.4 }, { name: "eject", pascal_name: "Eject", categories: [e.MEDIA], figma_category: a.MEDIA, tags: ["disconnect"], codepoint: 57874, published_in: 1, updated_in: 1 }, { name: "eject-simple", pascal_name: "EjectSimple", categories: [e.MEDIA], figma_category: a.MEDIA, tags: ["disconnect"], codepoint: 59054, published_in: 1.3, updated_in: 1.3 }, { name: "elevator", pascal_name: "Elevator", categories: [e.OBJECTS, e.MAP], figma_category: a.MAP, tags: ["lift"], codepoint: 60608, published_in: 2, updated_in: 2 }, { name: "empty", pascal_name: "Empty", categories: [e.FINANCE, e.DEVELOPMENT], figma_category: a.FINANCE, tags: ["*new*", "\u2205", "empty set", "member", "mathematics", "arithmetic", "calculator", "null"], codepoint: 60860, published_in: 2.1, updated_in: 2.1 }, { name: "engine", pascal_name: "Engine", categories: [e.MAP, e.OBJECTS], figma_category: a.MAP, tags: ["*updated*", "motor", "repair", "vehicles", "automobile"], codepoint: 60032, published_in: 2, updated_in: 2.1 }, { name: "envelope", pascal_name: "Envelope", categories: [e.COMMUNICATION], figma_category: a.COMMUNICATION, tags: ["mail", "email", "send", "sent", "message", "post", "letter"], codepoint: 57876, published_in: 1, updated_in: 1 }, { name: "envelope-open", pascal_name: "EnvelopeOpen", categories: [e.COMMUNICATION], figma_category: a.COMMUNICATION, tags: ["mail", "email", "send", "sent", "message", "read", "post", "letter"], codepoint: 57878, published_in: 1, updated_in: 1 }, { name: "envelope-simple", pascal_name: "EnvelopeSimple", categories: [e.COMMUNICATION], figma_category: a.COMMUNICATION, tags: ["mail", "email", "send", "sent", "message", "post", "letter"], codepoint: 57880, published_in: 1, updated_in: 1 }, { name: "envelope-simple-open", pascal_name: "EnvelopeSimpleOpen", categories: [e.COMMUNICATION], figma_category: a.COMMUNICATION, tags: ["mail", "email", "send", "sent", "message", "read", "post", "letter"], codepoint: 57882, published_in: 1, updated_in: 1 }, { name: "equalizer", pascal_name: "Equalizer", categories: [e.MEDIA, e.SYSTEM], figma_category: a.MEDIA, tags: ["music", "audio", "meter", "volume", "spectrum", "eq", "deezer"], codepoint: 60348, published_in: 1.4, updated_in: 1.4 }, { name: "equals", pascal_name: "Equals", categories: [e.DEVELOPMENT, e.FINANCE], figma_category: a.FINANCE, tags: ["=", "equality", "equivalent", "equivalence", "mathematics", "arithmetic", "calculator"], codepoint: 57884, published_in: 1, updated_in: 1 }, { name: "eraser", pascal_name: "Eraser", categories: [e.DESIGN, e.EDITOR], figma_category: a.DESIGN, tags: ["write", "writing", "editing", "undo", "deleted"], codepoint: 57886, published_in: 1, updated_in: 1 }, { name: "escalator-down", pascal_name: "EscalatorDown", categories: [e.MAP, e.OBJECTS], figma_category: a.MAP, tags: ["stairs"], codepoint: 60602, published_in: 2, updated_in: 2 }, { name: "escalator-up", pascal_name: "EscalatorUp", categories: [e.MAP, e.OBJECTS], figma_category: a.MAP, tags: ["stairs"], codepoint: 60604, published_in: 2, updated_in: 2 }, { name: "exam", pascal_name: "Exam", categories: [e.OBJECTS], figma_category: a.EDUCATION, tags: ["text", "examination", "paper", "school", "grade"], codepoint: 59202, published_in: 1.4, updated_in: 1.4 }, { name: "exclamation-mark", pascal_name: "ExclamationMark", categories: [e.SYSTEM], figma_category: a.SECURITY, tags: ["*new*", "!", "alert", "warning", "caution", "interjection", "punctuation", "symbol"], codepoint: 60996, published_in: 2.1, updated_in: 2.1 }, { name: "exclude", pascal_name: "Exclude", categories: [e.DESIGN, e.EDITOR], figma_category: a.DESIGN, tags: ["venn-diagram", "difference", "intersection"], codepoint: 59522, published_in: 2, updated_in: 2 }, { name: "exclude-square", pascal_name: "ExcludeSquare", categories: [e.DESIGN, e.EDITOR], figma_category: a.DESIGN, tags: ["venn-diagram", "difference", "intersection"], codepoint: 59520, published_in: 2, updated_in: 2 }, { name: "export", pascal_name: "Export", categories: [e.COMMUNICATION, e.SYSTEM], figma_category: a.COMMUNICATION, tags: ["share", "send to", "arrows"], codepoint: 60144, published_in: 1.3, updated_in: 1.3 }, { name: "eye", pascal_name: "Eye", categories: [e.DESIGN, e.EDITOR], figma_category: a.DESIGN, tags: ["visible", "hidden", "show", "hide", "visibility", "view"], codepoint: 57888, published_in: 1, updated_in: 1 }, { name: "eye-closed", pascal_name: "EyeClosed", categories: [e.DESIGN, e.EDITOR], figma_category: a.DESIGN, tags: ["visible", "hidden", "show", "hide", "visibility", "view", "invisible", "private"], codepoint: 57890, published_in: 1, updated_in: 1 }, { name: "eye-slash", pascal_name: "EyeSlash", categories: [e.DESIGN, e.EDITOR], figma_category: a.DESIGN, tags: ["visible", "hidden", "show", "hide", "visibility", "view", "invisible", "eyelashes", "disabled", "private"], codepoint: 57892, published_in: 1, updated_in: 1 }, { name: "eyedropper", pascal_name: "Eyedropper", categories: [e.DESIGN, e.EDITOR, e.OBJECTS], figma_category: a.DESIGN, tags: ["colors", "color picker", "sample", "arts"], codepoint: 58728, published_in: 1.1, updated_in: 1.1 }, { name: "eyedropper-sample", pascal_name: "EyedropperSample", categories: [e.DESIGN, e.EDITOR, e.OBJECTS], figma_category: a.DESIGN, tags: ["colors", "color picker", "arts"], codepoint: 60100, published_in: 1.4, updated_in: 1.4 }, { name: "eyeglasses", pascal_name: "Eyeglasses", categories: [e.HEALTH, e.OBJECTS], figma_category: a.COMMERCE, tags: ["vision", "spectacles"], codepoint: 59322, published_in: 1.4, updated_in: 1.4 }, { name: "eyes", pascal_name: "Eyes", categories: [e.PEOPLE], figma_category: a.PEOPLE, tags: ["*new*", "look", "glance"], codepoint: 61020, published_in: 2.1, updated_in: 2.1 }, { name: "face-mask", pascal_name: "FaceMask", categories: [e.HEALTH], figma_category: a.HEALTH, tags: ["ppe", "facemask", "covid-19", "coronavirus", "flu", "cold"], codepoint: 58730, published_in: 1.1, updated_in: 1.1 }, { name: "facebook-logo", pascal_name: "FacebookLogo", categories: [e.BRAND, e.COMMUNICATION], figma_category: a.BRAND, tags: ["logos", "social media"], codepoint: 57894, published_in: 1, updated_in: 1.4 }, { name: "factory", pascal_name: "Factory", categories: [e.COMMERCE, e.MAP], figma_category: a.COMMERCE, tags: ["industry", "manufacture", "buildings", "places", "locations"], codepoint: 59232, published_in: 1.3, updated_in: 1.3 }, { name: "faders", pascal_name: "Faders", categories: [e.MEDIA, e.SYSTEM], figma_category: a.MEDIA, tags: ["music", "audio", "sliders", "filters", "equalizer", "volume", "settings", "preferences"], codepoint: 57896, published_in: 1, updated_in: 1 }, { name: "faders-horizontal", pascal_name: "FadersHorizontal", categories: [e.MEDIA, e.SYSTEM], figma_category: a.MEDIA, tags: ["music", "audio", "sliders", "filters", "equalizer", "volume", "settings", "preferences"], codepoint: 57898, published_in: 1, updated_in: 1 }, { name: "fallout-shelter", pascal_name: "FalloutShelter", categories: [e.HEALTH], figma_category: a.SECURITY, tags: ["*new*", "radiation", "radioactive", "nuclear", "bunker", "contamination", "quarantine", "toxic", "danger", "caution"], codepoint: 59870, published_in: 2.1, updated_in: 2.1 }, { name: "fan", pascal_name: "Fan", categories: [e.COMMERCE, e.OBJECTS], figma_category: a.COMMERCE, tags: ["desk fan", "air conditioning"], codepoint: 59890, published_in: 2, updated_in: 2 }, { name: "farm", pascal_name: "Farm", categories: [e.COMMERCE, e.NATURE, e.MAP], figma_category: a.COMMERCE, tags: ["*new*", "farmer", "field", "farming", "agriculture"], codepoint: 60528, published_in: 2.1, updated_in: 2.1 }, { name: "fast-forward", pascal_name: "FastForward", categories: [e.MEDIA, e.SYSTEM], figma_category: a.MEDIA, tags: ["audio", "music", "seek", "scrub", "scan", "ahead", "skip"], codepoint: 59046, published_in: 1.3, updated_in: 1.3 }, { name: "fast-forward-circle", pascal_name: "FastForwardCircle", categories: [e.MEDIA, e.SYSTEM], figma_category: a.MEDIA, tags: ["audio", "music", "seek", "scrub", "scan", "ahead", "skip"], codepoint: 57900, published_in: 1, updated_in: 1 }, { name: "feather", pascal_name: "Feather", categories: [e.NATURE, e.OBJECTS], figma_category: a.WEATHER, tags: ["bird"], codepoint: 59840, published_in: 2, updated_in: 2 }, { name: "fediverse-logo", pascal_name: "FediverseLogo", categories: [e.BRAND, e.COMMUNICATION], figma_category: a.BRAND, tags: ["*new*", "social media", "decentralized"], codepoint: 60774, published_in: 2.1, updated_in: 2.1 }, { name: "figma-logo", pascal_name: "FigmaLogo", categories: [e.BRAND, e.DESIGN], figma_category: a.BRAND, tags: ["*updated*", "logos", "drawing", "art", "illustration", "ui", "interface", "prototype", "prototyping"], codepoint: 57902, published_in: 1, updated_in: 2.1 }, { name: "file", pascal_name: "File", categories: [e.OFFICE, e.EDITOR], figma_category: a.OFFICE, tags: ["documents", "files", "save", "write", "page"], codepoint: 57904, published_in: 1, updated_in: 1 }, { name: "file-archive", pascal_name: "FileArchive", categories: [e.SYSTEM, e.OFFICE, e.EDITOR], figma_category: a.OFFICE, tags: ["documents", "zip", "compression"], codepoint: 60202, published_in: 2, updated_in: 2 }, { name: "file-arrow-down", pascal_name: "FileArrowDown", categories: [e.OFFICE, e.EDITOR], figma_category: a.OFFICE, tags: ["documents", "files", "save", "write", "download", "directional", "pointer", "pointing", "arrowhead"], codepoint: 57906, published_in: 1, updated_in: 1 }, { name: "file-arrow-up", pascal_name: "FileArrowUp", categories: [e.OFFICE, e.EDITOR], figma_category: a.OFFICE, tags: ["documents", "files", "save", "write", "upload", "directional", "pointer", "pointing", "arrowhead"], codepoint: 58910, published_in: 1.2, updated_in: 1.2 }, { name: "file-audio", pascal_name: "FileAudio", categories: [e.OFFICE, e.EDITOR, e.MEDIA], figma_category: a.OFFICE, tags: ["documents", "music", "sound"], codepoint: 59936, published_in: 1.4, updated_in: 1.4 }, { name: "file-c", pascal_name: "FileC", categories: [e.OFFICE, e.EDITOR, e.DEVELOPMENT], figma_category: a.OFFICE, tags: ["*new*", "documents", "code"], codepoint: 60210, published_in: 2.1, updated_in: 2.1 }, { name: "file-c-sharp", pascal_name: "FileCSharp", categories: [e.OFFICE, e.EDITOR, e.DEVELOPMENT], figma_category: a.OFFICE, tags: ["*new*", "documents", "code", "c#"], codepoint: 60208, published_in: 2.1, updated_in: 2.1 }, { name: "file-cloud", pascal_name: "FileCloud", categories: [e.OFFICE, e.EDITOR, e.SYSTEM], figma_category: a.OFFICE, tags: ["documents", "sync"], codepoint: 59742, published_in: 1.4, updated_in: 1.4 }, { name: "file-code", pascal_name: "FileCode", categories: [e.OFFICE, e.EDITOR, e.DEVELOPMENT], figma_category: a.OFFICE, tags: ["documents"], codepoint: 59668, published_in: 1.4, updated_in: 1.4 }, { name: "file-cpp", pascal_name: "FileCpp", categories: [e.OFFICE, e.EDITOR, e.DEVELOPMENT], figma_category: a.OFFICE, tags: ["*new*", "documents", "code", "c++"], codepoint: 60206, published_in: 2.1, updated_in: 2.1 }, { name: "file-css", pascal_name: "FileCss", categories: [e.OFFICE, e.EDITOR, e.DEVELOPMENT], figma_category: a.OFFICE, tags: ["documents", "code"], codepoint: 60212, published_in: 1.4, updated_in: 1.4 }, { name: "file-csv", pascal_name: "FileCsv", categories: [e.OFFICE, e.EDITOR], figma_category: a.OFFICE, tags: ["documents", "data"], codepoint: 60188, published_in: 1.4, updated_in: 1.4 }, { name: "file-dashed", pascal_name: "FileDashed", alias: { name: "file-dotted", pascal_name: "FileDotted" }, categories: [e.OFFICE, e.EDITOR], figma_category: a.OFFICE, tags: ["documents", "files", "browse", "draft", "open", "dotted"], codepoint: 59140, published_in: 1.3, updated_in: 1.3 }, { name: "file-doc", pascal_name: "FileDoc", categories: [e.OFFICE, e.EDITOR], figma_category: a.OFFICE, tags: ["documents", "word", "microsoft"], codepoint: 60190, published_in: 1.4, updated_in: 1.4 }, { name: "file-html", pascal_name: "FileHtml", categories: [e.OFFICE, e.EDITOR, e.DEVELOPMENT], figma_category: a.OFFICE, tags: ["*updated*", "documents", "code"], codepoint: 60216, published_in: 1.4, updated_in: 2.1 }, { name: "file-image", pascal_name: "FileImage", categories: [e.OFFICE, e.EDITOR, e.MEDIA], figma_category: a.OFFICE, tags: ["documents", "pictures", "photograph"], codepoint: 59940, published_in: 1.4, updated_in: 1.4 }, { name: "file-ini", pascal_name: "FileIni", categories: [e.OFFICE, e.EDITOR, e.DEVELOPMENT], figma_category: a.OFFICE, tags: ["*new*", "documents"], codepoint: 60210, published_in: 2.1, updated_in: 2.1 }, { name: "file-jpg", pascal_name: "FileJpg", categories: [e.OFFICE, e.EDITOR, e.MEDIA], figma_category: a.OFFICE, tags: ["documents", "pictures", "photograph", "jpeg"], codepoint: 60186, published_in: 1.4, updated_in: 1.4 }, { name: "file-js", pascal_name: "FileJs", categories: [e.OFFICE, e.EDITOR, e.DEVELOPMENT], figma_category: a.OFFICE, tags: ["documents", "code", "javascript"], codepoint: 60196, published_in: 1.4, updated_in: 1.4 }, { name: "file-jsx", pascal_name: "FileJsx", categories: [e.OFFICE, e.EDITOR, e.DEVELOPMENT], figma_category: a.OFFICE, tags: ["documents", "code", "javascript"], codepoint: 60218, published_in: 1.4, updated_in: 1.4 }, { name: "file-lock", pascal_name: "FileLock", categories: [e.OFFICE, e.EDITOR, e.SYSTEM], figma_category: a.OFFICE, tags: ["documents", "secure", "locked", "private"], codepoint: 59740, published_in: 1.4, updated_in: 1.4 }, { name: "file-magnifying-glass", pascal_name: "FileMagnifyingGlass", alias: { name: "file-search", pascal_name: "FileSearch" }, categories: [e.OFFICE, e.EDITOR], figma_category: a.OFFICE, tags: ["documents", "files", "search", "find", "locate", "browse", "missing"], codepoint: 57912, published_in: 1, updated_in: 1 }, { name: "file-md", pascal_name: "FileMd", categories: [e.OFFICE, e.EDITOR, e.DEVELOPMENT], figma_category: a.OFFICE, tags: ["*new*", "documents", "notes", "markdown"], codepoint: 60752, published_in: 2.1, updated_in: 2.1 }, { name: "file-minus", pascal_name: "FileMinus", categories: [e.OFFICE, e.EDITOR], figma_category: a.OFFICE, tags: ["documents", "files", "delete", "write", "remove", "-"], codepoint: 57908, published_in: 1, updated_in: 1 }, { name: "file-pdf", pascal_name: "FilePdf", categories: [e.OFFICE, e.EDITOR], figma_category: a.OFFICE, tags: ["documents", "files", "acrobat"], codepoint: 59138, published_in: 1.3, updated_in: 1.4 }, { name: "file-plus", pascal_name: "FilePlus", categories: [e.OFFICE, e.EDITOR], figma_category: a.OFFICE, tags: ["documents", "files", "save", "write", "add", "new", "create", "+"], codepoint: 57910, published_in: 1, updated_in: 1 }, { name: "file-png", pascal_name: "FilePng", categories: [e.OFFICE, e.EDITOR, e.MEDIA], figma_category: a.OFFICE, tags: ["documents", "pictures", "photograph"], codepoint: 60184, published_in: 1.4, updated_in: 1.4 }, { name: "file-ppt", pascal_name: "FilePpt", categories: [e.OFFICE, e.EDITOR], figma_category: a.OFFICE, tags: ["documents", "powerpoint", "microsoft"], codepoint: 60192, published_in: 1.4, updated_in: 1.4 }, { name: "file-py", pascal_name: "FilePy", categories: [e.OFFICE, e.EDITOR, e.DEVELOPMENT], figma_category: a.OFFICE, tags: ["*new*", "documents", "code", "python"], codepoint: 60204, published_in: 2.1, updated_in: 2.1 }, { name: "file-rs", pascal_name: "FileRs", categories: [e.OFFICE, e.EDITOR, e.DEVELOPMENT], figma_category: a.OFFICE, tags: ["documents", "code", "rust"], codepoint: 60200, published_in: 1.4, updated_in: 1.4 }, { name: "file-sql", pascal_name: "FileSql", categories: [e.SYSTEM, e.DEVELOPMENT], figma_category: a.OFFICE, tags: ["documents", "database"], codepoint: 60750, published_in: 2, updated_in: 2 }, { name: "file-svg", pascal_name: "FileSvg", categories: [e.SYSTEM, e.MEDIA], figma_category: a.OFFICE, tags: ["documents", "images", "vector"], codepoint: 60680, published_in: 2, updated_in: 2 }, { name: "file-text", pascal_name: "FileText", categories: [e.OFFICE, e.EDITOR], figma_category: a.OFFICE, tags: ["documents", "files", "save", "write"], codepoint: 57914, published_in: 1, updated_in: 1 }, { name: "file-ts", pascal_name: "FileTs", categories: [e.OFFICE, e.EDITOR, e.DEVELOPMENT], figma_category: a.OFFICE, tags: ["documents", "code", "typescript"], codepoint: 60198, published_in: 1.4, updated_in: 1.4 }, { name: "file-tsx", pascal_name: "FileTsx", categories: [e.OFFICE, e.EDITOR, e.DEVELOPMENT], figma_category: a.OFFICE, tags: ["documents", "code", "typescript"], codepoint: 60220, published_in: 1.4, updated_in: 1.4 }, { name: "file-txt", pascal_name: "FileTxt", categories: [e.OFFICE, e.EDITOR, e.DEVELOPMENT], figma_category: a.OFFICE, tags: ["*new*", "documents"], codepoint: 60210, published_in: 2.1, updated_in: 2.1 }, { name: "file-video", pascal_name: "FileVideo", categories: [e.OFFICE, e.EDITOR, e.MEDIA], figma_category: a.OFFICE, tags: ["documents", "movie"], codepoint: 59938, published_in: 1.4, updated_in: 1.4 }, { name: "file-vue", pascal_name: "FileVue", categories: [e.OFFICE, e.EDITOR, e.DEVELOPMENT], figma_category: a.OFFICE, tags: ["documents", "code"], codepoint: 60222, published_in: 1.4, updated_in: 1.4 }, { name: "file-x", pascal_name: "FileX", categories: [e.OFFICE, e.EDITOR], figma_category: a.OFFICE, tags: ["documents", "files", "cancelled", "deleted", "removed", "errors"], codepoint: 57916, published_in: 1, updated_in: 1 }, { name: "file-xls", pascal_name: "FileXls", categories: [e.OFFICE, e.EDITOR], figma_category: a.OFFICE, tags: ["documents", "excel", "microsoft"], codepoint: 60194, published_in: 1.4, updated_in: 1.4 }, { name: "file-zip", pascal_name: "FileZip", categories: [e.OFFICE, e.EDITOR, e.SYSTEM], figma_category: a.OFFICE, tags: ["documents", "archive", "compression"], codepoint: 59736, published_in: 1.4, updated_in: 1.4 }, { name: "files", pascal_name: "Files", categories: [e.OFFICE, e.EDITOR], figma_category: a.OFFICE, tags: ["documents", "open", "library"], codepoint: 59152, published_in: 1.3, updated_in: 1.3 }, { name: "film-reel", pascal_name: "FilmReel", categories: [e.MEDIA, e.OBJECTS], figma_category: a.MEDIA, tags: ["videography", "films", "movies", "recording"], codepoint: 59584, published_in: 2, updated_in: 2 }, { name: "film-script", pascal_name: "FilmScript", categories: [e.OFFICE, e.MEDIA], figma_category: a.MEDIA, tags: ["screenplay", "movie"], codepoint: 60240, published_in: 1.4, updated_in: 1.4 }, { name: "film-slate", pascal_name: "FilmSlate", categories: [e.MEDIA, e.OBJECTS], figma_category: a.MEDIA, tags: ["*updated*", "clapper", "movie"], codepoint: 59586, published_in: 1.4, updated_in: 2.1 }, { name: "film-strip", pascal_name: "FilmStrip", categories: [e.MEDIA], figma_category: a.MEDIA, tags: ["camera", "photography", "darkroom", "movie", "analog"], codepoint: 59282, published_in: 1.3, updated_in: 1.4 }, { name: "fingerprint", pascal_name: "Fingerprint", categories: [e.SYSTEM], figma_category: a.SECURITY, tags: ["security", "secured", "authentication", "authenticated", "login", "locked", "biometrics", "encrypted", "encryption"], codepoint: 57918, published_in: 1, updated_in: 1 }, { name: "fingerprint-simple", pascal_name: "FingerprintSimple", categories: [e.SYSTEM], figma_category: a.SECURITY, tags: ["security", "secured", "authentication", "authenticated", "login", "locked", "biometrics", "encrypted", "encryption"], codepoint: 57920, published_in: 1, updated_in: 1 }, { name: "finn-the-human", pascal_name: "FinnTheHuman", categories: [e.GAMES], figma_category: a.GAMES, tags: ["adventure time", "cartoons", "television", "tv", "character"], codepoint: 58732, published_in: 1.1, updated_in: 1.1 }, { name: "fire", pascal_name: "Fire", categories: [e.NATURE, e.WEATHER], figma_category: a.WEATHER, tags: ["flame", "burning", "match", "lighter"], codepoint: 57922, published_in: 1, updated_in: 1 }, { name: "fire-extinguisher", pascal_name: "FireExtinguisher", categories: [e.OBJECTS], figma_category: a.SECURITY, tags: ["safety", "prevention", "emergency", "hazard", "danger", "caution"], codepoint: 59880, published_in: 2, updated_in: 2 }, { name: "fire-simple", pascal_name: "FireSimple", categories: [e.NATURE, e.WEATHER], figma_category: a.WEATHER, tags: ["flame", "burning", "match", "lighter"], codepoint: 58912, published_in: 1.2, updated_in: 1.2 }, { name: "fire-truck", pascal_name: "FireTruck", categories: [e.HEALTH], figma_category: a.HEALTH, tags: ["*new*", "first-aid", "emt", "medical", "medicine", "injury", "safety", "emergency", "firefighter"], codepoint: 58740, published_in: 2.1, updated_in: 2.1 }, { name: "first-aid", pascal_name: "FirstAid", categories: [e.HEALTH], figma_category: a.HEALTH, tags: ["hospital", "cross", "medical", "medicine", "injury", "safety", "emergency", "doctor"], codepoint: 58734, published_in: 1.1, updated_in: 1.1 }, { name: "first-aid-kit", pascal_name: "FirstAidKit", categories: [e.HEALTH], figma_category: a.HEALTH, tags: ["bandages", "medical", "medicine", "injury", "safety", "emergency", "doctor"], codepoint: 58736, published_in: 1.1, updated_in: 1.1 }, { name: "fish", pascal_name: "Fish", categories: [e.NATURE, e.COMMERCE], figma_category: a.WEATHER, tags: ["animals", "pets", "food", "seafood", "restaurants", "dining"], codepoint: 59176, published_in: 1.3, updated_in: 1.3 }, { name: "fish-simple", pascal_name: "FishSimple", categories: [e.NATURE, e.COMMERCE], figma_category: a.WEATHER, tags: ["animals", "pets", "food", "seafood", "restaurants", "dining"], codepoint: 59178, published_in: 1.3, updated_in: 1.3 }, { name: "flag", pascal_name: "Flag", categories: [e.OBJECTS, e.MAP, e.SYSTEM], figma_category: a.MAP, tags: ["country", "countries", "finished", "completed", "flags"], codepoint: 57924, published_in: 1, updated_in: 1 }, { name: "flag-banner", pascal_name: "FlagBanner", categories: [e.OBJECTS, e.MAP, e.SYSTEM], figma_category: a.MAP, tags: ["ribbon", "country", "countries", "finished", "completed", "flags", "swallowtail"], codepoint: 58914, published_in: 1.2, updated_in: 2 }, { name: "flag-banner-fold", pascal_name: "FlagBannerFold", categories: [e.OBJECTS, e.MAP, e.SYSTEM], figma_category: a.MAP, tags: ["*new*", "ribbon", "country", "countries", "finished", "completed", "flags", "swallowtail"], codepoint: 60658, published_in: 2.1, updated_in: 2.1 }, { name: "flag-checkered", pascal_name: "FlagCheckered", categories: [e.MAP, e.OBJECTS, e.GAMES], figma_category: a.MAP, tags: ["flags", "race", "racing", "finish line"], codepoint: 59960, published_in: 1.4, updated_in: 1.4 }, { name: "flag-pennant", pascal_name: "FlagPennant", categories: [e.OBJECTS, e.MAP, e.SYSTEM, e.GAMES], figma_category: a.MAP, tags: ["flags", "race", "sports", "team"], codepoint: 60656, published_in: 2, updated_in: 2 }, { name: "flame", pascal_name: "Flame", categories: [e.NATURE, e.WEATHER], figma_category: a.WEATHER, tags: ["fire", "burning", "match", "lighter"], codepoint: 58916, published_in: 1.2, updated_in: 1.2 }, { name: "flashlight", pascal_name: "Flashlight", categories: [e.SYSTEM, e.OBJECTS], figma_category: a.SYSTEM, tags: ["torch", "find", "search", "locate"], codepoint: 57926, published_in: 1, updated_in: 1 }, { name: "flask", pascal_name: "Flask", categories: [e.DEVELOPMENT, e.NATURE, e.OBJECTS], figma_category: a.HEALTH, tags: ["beaker", "science", "chemistry", "experiment", "erlenmeyer"], codepoint: 59294, published_in: 1.3, updated_in: 1.3 }, { name: "flip-horizontal", pascal_name: "FlipHorizontal", categories: [e.DESIGN, e.EDITOR], figma_category: a.DESIGN, tags: ["*new*", "mirror", "rotate", "invert"], codepoint: 60778, published_in: 2.1, updated_in: 2.1 }, { name: "flip-vertical", pascal_name: "FlipVertical", categories: [e.DESIGN, e.EDITOR], figma_category: a.DESIGN, tags: ["*new*", "mirror", "rotate", "invert"], codepoint: 60780, published_in: 2.1, updated_in: 2.1 }, { name: "floppy-disk", pascal_name: "FloppyDisk", categories: [e.OFFICE, e.EDITOR, e.SYSTEM], figma_category: a.OFFICE, tags: ["diskette", "directory", "directories", "folders", "documents", "files", "save", "write"], codepoint: 57928, published_in: 1, updated_in: 1 }, { name: "floppy-disk-back", pascal_name: "FloppyDiskBack", categories: [e.OFFICE, e.EDITOR, e.SYSTEM], figma_category: a.OFFICE, tags: ["*updated*", "diskette", "directory", "directories", "folders", "documents", "files", "save", "write"], codepoint: 60148, published_in: 1.3, updated_in: 2.1 }, { name: "flow-arrow", pascal_name: "FlowArrow", categories: [e.ARROWS, e.DESIGN, e.OFFICE], figma_category: a.DESIGN, tags: ["*updated*", "flowchart", "arrowhead"], codepoint: 59116, published_in: 1.3, updated_in: 2.1 }, { name: "flower", pascal_name: "Flower", categories: [e.NATURE], figma_category: a.WEATHER, tags: ["plants", "green", "environmental"], codepoint: 59230, published_in: 1.3, updated_in: 1.3 }, { name: "flower-lotus", pascal_name: "FlowerLotus", categories: [e.NATURE], figma_category: a.WEATHER, tags: ["plants", "green", "environmental", "spirituality"], codepoint: 59084, published_in: 1.3, updated_in: 1.3 }, { name: "flower-tulip", pascal_name: "FlowerTulip", categories: [e.NATURE], figma_category: a.WEATHER, tags: ["plants", "green", "environmental"], codepoint: 60108, published_in: 2, updated_in: 2 }, { name: "flying-saucer", pascal_name: "FlyingSaucer", categories: [e.GAMES, e.OBJECTS], figma_category: a.GAMES, tags: ["ufo", "space", "aliens", "extra terrestrial", "sci-fi"], codepoint: 60234, published_in: 1.4, updated_in: 1.4 }, { name: "folder", pascal_name: "Folder", alias: { name: "folder-notch", pascal_name: "FolderNotch" }, categories: [e.OFFICE, e.EDITOR, e.SYSTEM], figma_category: a.OFFICE, tags: ["directory", "directories", "files", "folders"], codepoint: 57930, published_in: 1, updated_in: 1 }, { name: "folder-dashed", pascal_name: "FolderDashed", alias: { name: "folder-dotted", pascal_name: "FolderDotted" }, categories: [e.OFFICE, e.EDITOR, e.SYSTEM], figma_category: a.OFFICE, tags: ["directory", "directories", "files", "folders", "missing", "temporary", "dotted"], codepoint: 59640, published_in: 1.4, updated_in: 1.4 }, { name: "folder-lock", pascal_name: "FolderLock", categories: [e.OFFICE, e.EDITOR, e.SYSTEM], figma_category: a.OFFICE, tags: ["directory", "directories", "files", "folders", "private", "secure"], codepoint: 59964, published_in: 1.4, updated_in: 1.4 }, { name: "folder-minus", pascal_name: "FolderMinus", alias: { name: "folder-notch-minus", pascal_name: "FolderNotchMinus" }, categories: [e.OFFICE, e.EDITOR, e.SYSTEM], figma_category: a.OFFICE, tags: ["directory", "directories", "files", "delete", "write", "remove", "-"], codepoint: 57940, published_in: 1, updated_in: 1 }, { name: "folder-open", pascal_name: "FolderOpen", alias: { name: "folder-notch-open", pascal_name: "FolderNotchOpen" }, categories: [e.OFFICE, e.EDITOR, e.SYSTEM], figma_category: a.OFFICE, tags: ["directory", "directories", "files", "folders", "load"], codepoint: 57942, published_in: 1, updated_in: 1 }, { name: "folder-plus", pascal_name: "FolderPlus", alias: { name: "folder-notch-plus", pascal_name: "FolderNotchPlus" }, categories: [e.OFFICE, e.EDITOR, e.SYSTEM], figma_category: a.OFFICE, tags: ["directory", "directories", "files", "save", "write", "add", "new", "create", "+"], codepoint: 57944, published_in: 1, updated_in: 1 }, { name: "folder-simple", pascal_name: "FolderSimple", categories: [e.OFFICE, e.EDITOR, e.SYSTEM], figma_category: a.OFFICE, tags: ["directory", "directories", "files", "folders"], codepoint: 57946, published_in: 1, updated_in: 1 }, { name: "folder-simple-dashed", pascal_name: "FolderSimpleDashed", alias: { name: "folder-simple-dotted", pascal_name: "FolderSimpleDotted" }, categories: [e.OFFICE, e.EDITOR, e.SYSTEM], figma_category: a.OFFICE, tags: ["directory", "directories", "files", "folders", "missing", "temporary", "dotted"], codepoint: 60458, published_in: 1.4, updated_in: 1.4 }, { name: "folder-simple-lock", pascal_name: "FolderSimpleLock", categories: [e.OFFICE, e.EDITOR, e.SYSTEM], figma_category: a.OFFICE, tags: ["directory", "directories", "files", "folders", "private", "secure"], codepoint: 60254, published_in: 1.4, updated_in: 1.4 }, { name: "folder-simple-minus", pascal_name: "FolderSimpleMinus", categories: [e.OFFICE, e.EDITOR, e.SYSTEM], figma_category: a.OFFICE, tags: ["directory", "directories", "files", "delete", "write", "remove", "-"], codepoint: 57948, published_in: 1, updated_in: 1 }, { name: "folder-simple-plus", pascal_name: "FolderSimplePlus", categories: [e.OFFICE, e.EDITOR, e.SYSTEM], figma_category: a.OFFICE, tags: ["directory", "directories", "files", "save", "write", "add", "new", "create", "+"], codepoint: 57950, published_in: 1, updated_in: 1 }, { name: "folder-simple-star", pascal_name: "FolderSimpleStar", categories: [e.OFFICE, e.EDITOR, e.SYSTEM], figma_category: a.OFFICE, tags: ["directory", "directories", "files", "folders", "favorite", "starred"], codepoint: 60462, published_in: 1.4, updated_in: 1.4 }, { name: "folder-simple-user", pascal_name: "FolderSimpleUser", categories: [e.OFFICE, e.EDITOR, e.SYSTEM], figma_category: a.OFFICE, tags: ["directory", "directories", "files", "folders", "personal"], codepoint: 60256, published_in: 1.4, updated_in: 1.4 }, { name: "folder-star", pascal_name: "FolderStar", categories: [e.OFFICE, e.EDITOR, e.SYSTEM], figma_category: a.OFFICE, tags: ["directory", "directories", "files", "folders", "favorite", "starred"], codepoint: 60038, published_in: 1.4, updated_in: 1.4 }, { name: "folder-user", pascal_name: "FolderUser", categories: [e.OFFICE, e.EDITOR, e.SYSTEM], figma_category: a.OFFICE, tags: ["directory", "directories", "files", "folders", "personal"], codepoint: 60230, published_in: 1.4, updated_in: 1.4 }, { name: "folders", pascal_name: "Folders", categories: [e.OFFICE, e.EDITOR, e.SYSTEM], figma_category: a.OFFICE, tags: ["directory", "directories", "files", "folders", "copy", "copied", "duplicated"], codepoint: 57952, published_in: 1, updated_in: 1 }, { name: "football", pascal_name: "Football", categories: [e.GAMES, e.HEALTH, e.OBJECTS], figma_category: a.GAMES, tags: ["sports", "american football", "nfl"], codepoint: 59160, published_in: 1.3, updated_in: 1.3 }, { name: "football-helmet", pascal_name: "FootballHelmet", categories: [e.GAMES, e.HEALTH, e.OBJECTS], figma_category: a.GAMES, tags: ["*new*", "sports", "american football", "nfl"], codepoint: 61004, published_in: 2.1, updated_in: 2.1 }, { name: "footprints", pascal_name: "Footprints", categories: [e.HEALTH, e.MAP], figma_category: a.PEOPLE, tags: ["path", "trail", "walk", "route", "hike", "hiking"], codepoint: 60040, published_in: 2, updated_in: 2 }, { name: "fork-knife", pascal_name: "ForkKnife", categories: [e.COMMERCE, e.MAP, e.OBJECTS], figma_category: a.COMMERCE, tags: ["food", "meal", "eating", "restaurants", "dining", "utensils"], codepoint: 57954, published_in: 1, updated_in: 1 }, { name: "four-k", pascal_name: "FourK", categories: [e.MEDIA], figma_category: a.MEDIA, tags: ["*new*", "uhd", "resolution", "video"], codepoint: 59996, published_in: 2.1, updated_in: 2.1 }, { name: "frame-corners", pascal_name: "FrameCorners", categories: [e.SYSTEM], figma_category: a.MEDIA, tags: ["expand", "fullscreen", "maximized", "resize", "windowed", "capture"], codepoint: 58918, published_in: 1.2, updated_in: 1.2 }, { name: "framer-logo", pascal_name: "FramerLogo", categories: [e.BRAND, e.DESIGN], figma_category: a.BRAND, tags: ["logos", "interface", "ui", "motion", "prototype", "prototyping"], codepoint: 57956, published_in: 1, updated_in: 1 }, { name: "function", pascal_name: "Function", categories: [e.DEVELOPMENT], figma_category: a.FINANCE, tags: ["mathematics", "arithmetic", "f-stop"], codepoint: 60388, published_in: 1.4, updated_in: 1.4 }, { name: "funnel", pascal_name: "Funnel", categories: [e.EDITOR, e.OBJECTS], figma_category: a.OFFICE, tags: ["filters", "refine", "sorting"], codepoint: 57958, published_in: 1, updated_in: 1 }, { name: "funnel-simple", pascal_name: "FunnelSimple", categories: [e.EDITOR, e.OBJECTS], figma_category: a.OFFICE, tags: ["filters", "refine", "sorting"], codepoint: 57960, published_in: 1, updated_in: 1 }, { name: "funnel-simple-x", pascal_name: "FunnelSimpleX", categories: [e.EDITOR, e.OBJECTS], figma_category: a.OFFICE, tags: ["*new*", "filters", "refine", "sorting"], codepoint: 57962, published_in: 2.1, updated_in: 2.1 }, { name: "funnel-x", pascal_name: "FunnelX", categories: [e.EDITOR, e.OBJECTS], figma_category: a.OFFICE, tags: ["*new*", "filters", "refine", "sorting"], codepoint: 57964, published_in: 2.1, updated_in: 2.1 }, { name: "game-controller", pascal_name: "GameController", categories: [e.GAMES, e.MEDIA, e.OBJECTS], figma_category: a.GAMES, tags: ["gaming", "video games", "nintendo switch", "sony playstation", "microsoft xbox"], codepoint: 57966, published_in: 1, updated_in: 1 }, { name: "garage", pascal_name: "Garage", categories: [e.COMMERCE, e.MAP], figma_category: a.COMMERCE, tags: ["vehicles", "automobile", "buildings", "transportation"], codepoint: 60630, published_in: 2, updated_in: 2 }, { name: "gas-can", pascal_name: "GasCan", categories: [e.MAP, e.OBJECTS], figma_category: a.MAP, tags: ["jerrycan", "petrol", "fuel", "gasoline"], codepoint: 59598, published_in: 2, updated_in: 2 }, { name: "gas-pump", pascal_name: "GasPump", categories: [e.MAP, e.OBJECTS], figma_category: a.MAP, tags: ["gas station", "petrol", "fuel", "gasoline"], codepoint: 59240, published_in: 1.3, updated_in: 1.3 }, { name: "gauge", pascal_name: "Gauge", categories: [e.DEVELOPMENT, e.OBJECTS, e.SYSTEM], figma_category: a.SYSTEM, tags: ["dashboard", "meter", "speed", "speedometer", "odometer", "performance"], codepoint: 58920, published_in: 1.2, updated_in: 1.4 }, { name: "gavel", pascal_name: "Gavel", categories: [e.COMMERCE, e.OBJECTS], figma_category: a.COMMERCE, tags: ["judge", "justice", "legal", "law", "court", "hammer", "government"], codepoint: 59954, published_in: 2, updated_in: 2 }, { name: "gear", pascal_name: "Gear", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["8", "settings", "setup", "preferences", "cogs", "gears", "machinery", "mechanical"], codepoint: 57968, published_in: 1, updated_in: 1 }, { name: "gear-fine", pascal_name: "GearFine", categories: [e.SYSTEM], figma_category: a.DESIGN, tags: ["setup", "preferences", "cogs", "gears", "machinery", "mechanical"], codepoint: 59516, published_in: 2, updated_in: 2 }, { name: "gear-six", pascal_name: "GearSix", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["6", "settings", "setup", "preferences", "cogs", "gears", "machinery", "mechanical"], codepoint: 57970, published_in: 1, updated_in: 1 }, { name: "gender-female", pascal_name: "GenderFemale", categories: [e.PEOPLE], figma_category: a.PEOPLE, tags: ["woman", "feminine", "venus"], codepoint: 59104, published_in: 1.3, updated_in: 1.3 }, { name: "gender-intersex", pascal_name: "GenderIntersex", categories: [e.PEOPLE], figma_category: a.PEOPLE, tags: ["transgender", "non-binary"], codepoint: 59110, published_in: 1.3, updated_in: 1.3 }, { name: "gender-male", pascal_name: "GenderMale", categories: [e.PEOPLE], figma_category: a.PEOPLE, tags: ["man", "masculine", "mars"], codepoint: 59106, published_in: 1.3, updated_in: 1.3 }, { name: "gender-neuter", pascal_name: "GenderNeuter", categories: [e.PEOPLE], figma_category: a.PEOPLE, tags: ["agender", "non-binary", "asexual"], codepoint: 59114, published_in: 1.3, updated_in: 1.3 }, { name: "gender-nonbinary", pascal_name: "GenderNonbinary", categories: [e.PEOPLE], figma_category: a.PEOPLE, tags: ["intersex", "non-binary"], codepoint: 59108, published_in: 1.3, updated_in: 1.3 }, { name: "gender-transgender", pascal_name: "GenderTransgender", categories: [e.PEOPLE], figma_category: a.PEOPLE, tags: ["intersex", "non-binary"], codepoint: 59112, published_in: 1.3, updated_in: 1.3 }, { name: "ghost", pascal_name: "Ghost", categories: [e.GAMES, e.OBJECTS], figma_category: a.GAMES, tags: ["pac-man", "spirit", "scary", "halloween"], codepoint: 58922, published_in: 1.2, updated_in: 1.2 }, { name: "gif", pascal_name: "Gif", categories: [e.MEDIA], figma_category: a.MEDIA, tags: ["gifs", ".gif", "giphy"], codepoint: 57972, published_in: 1, updated_in: 1 }, { name: "gift", pascal_name: "Gift", categories: [e.COMMERCE, e.OBJECTS], figma_category: a.COMMERCE, tags: ["presents", "holiday", "birthday"], codepoint: 57974, published_in: 1, updated_in: 1 }, { name: "git-branch", pascal_name: "GitBranch", categories: [e.DEVELOPMENT], figma_category: a.DEVELOPMENT, tags: ["*updated*", "github", "vcs", "source control", "version control", "versioning", "branches"], codepoint: 57976, published_in: 1, updated_in: 2.1 }, { name: "git-commit", pascal_name: "GitCommit", categories: [e.DEVELOPMENT], figma_category: a.DEVELOPMENT, tags: ["github", "vcs", "source control", "version control", "versioning", "commits"], codepoint: 57978, published_in: 1, updated_in: 1 }, { name: "git-diff", pascal_name: "GitDiff", categories: [e.DEVELOPMENT], figma_category: a.DEVELOPMENT, tags: ["*updated*", "github", "vcs", "source control", "version control", "versioning", "difference", "compare"], codepoint: 57980, published_in: 1, updated_in: 2.1 }, { name: "git-fork", pascal_name: "GitFork", categories: [e.DEVELOPMENT], figma_category: a.DEVELOPMENT, tags: ["*updated*", "github", "vcs", "source control", "version control", "versioning", "split"], codepoint: 57982, published_in: 1, updated_in: 2.1 }, { name: "git-merge", pascal_name: "GitMerge", categories: [e.DEVELOPMENT], figma_category: a.DEVELOPMENT, tags: ["*updated*", "github", "vcs", "source control", "version control", "versioning", "split"], codepoint: 57984, published_in: 1, updated_in: 2.1 }, { name: "git-pull-request", pascal_name: "GitPullRequest", categories: [e.DEVELOPMENT], figma_category: a.DEVELOPMENT, tags: ["*updated*", "github", "vcs", "source control", "version control", "versioning", "merge request"], codepoint: 57986, published_in: 1, updated_in: 2.1 }, { name: "github-logo", pascal_name: "GithubLogo", categories: [e.DEVELOPMENT, e.BRAND], figma_category: a.BRAND, tags: ["octocat", "vcs", "source control", "version control", "versioning", "branches"], codepoint: 58742, published_in: 1.1, updated_in: 2 }, { name: "gitlab-logo", pascal_name: "GitlabLogo", categories: [e.BRAND, e.DEVELOPMENT], figma_category: a.BRAND, tags: ["vcs", "source control", "version control", "versioning", "branches"], codepoint: 59028, published_in: 1.3, updated_in: 2 }, { name: "gitlab-logo-simple", pascal_name: "GitlabLogoSimple", categories: [e.BRAND, e.DEVELOPMENT], figma_category: a.BRAND, tags: ["vcs", "source control", "version control", "versioning", "branches"], codepoint: 59030, published_in: 1.3, updated_in: 2 }, { name: "globe", pascal_name: "Globe", categories: [e.MAP], figma_category: a.MAP, tags: ["world", "earth", "global", "planet", "circle", "round", "internationalization", "i18n", "languages", "country", "countries", "geography", "internet"], codepoint: 57992, published_in: 1, updated_in: 1 }, { name: "globe-hemisphere-east", pascal_name: "GlobeHemisphereEast", categories: [e.MAP], figma_category: a.MAP, tags: ["world", "earth", "global", "planet", "circle", "round", "internationalization", "i18n", "languages", "country", "countries", "geography", "europe", "africa", "asia", "australia"], codepoint: 57994, published_in: 1, updated_in: 1 }, { name: "globe-hemisphere-west", pascal_name: "GlobeHemisphereWest", categories: [e.MAP], figma_category: a.MAP, tags: ["world", "earth", "global", "planet", "circle", "round", "internationalization", "i18n", "languages", "country", "countries", "geography", "north america", "south america"], codepoint: 57996, published_in: 1, updated_in: 1 }, { name: "globe-simple", pascal_name: "GlobeSimple", categories: [e.MAP], figma_category: a.MAP, tags: ["world", "earth", "global", "planet", "circle", "round", "internationalization", "i18n", "languages", "country", "countries", "geography"], codepoint: 57998, published_in: 1, updated_in: 1 }, { name: "globe-simple-x", pascal_name: "GlobeSimpleX", categories: [e.MAP], figma_category: a.MAP, tags: ["*new*", "world", "earth", "global", "planet", "circle", "round", "internationalization", "i18n", "languages", "country", "countries", "geography", "internet"], codepoint: 57988, published_in: 2.1, updated_in: 2.1 }, { name: "globe-stand", pascal_name: "GlobeStand", categories: [e.MAP], figma_category: a.MAP, tags: ["world", "global", "planet", "circle", "round", "internationalization", "i18n", "languages", "country", "countries", "geography"], codepoint: 58e3, published_in: 1, updated_in: 1 }, { name: "globe-x", pascal_name: "GlobeX", categories: [e.MAP], figma_category: a.MAP, tags: ["*new*", "world", "earth", "global", "planet", "circle", "round", "internationalization", "i18n", "languages", "country", "countries", "geography", "internet"], codepoint: 57990, published_in: 2.1, updated_in: 2.1 }, { name: "goggles", pascal_name: "Goggles", categories: [e.HEALTH, e.OBJECTS], figma_category: a.MAP, tags: ["swim", "swimming", "sports", "exercise", "olympics", "aquatics"], codepoint: 60596, published_in: 2, updated_in: 2 }, { name: "golf", pascal_name: "Golf", categories: [e.GAMES, e.HEALTH, e.OBJECTS], figma_category: a.GAMES, tags: ["*new*", "sports", "pga", "tee", "ball"], codepoint: 59966, published_in: 2.1, updated_in: 2.1 }, { name: "goodreads-logo", pascal_name: "GoodreadsLogo", categories: [e.BRAND], figma_category: a.BRAND, tags: ["*updated*", "reading", "books", "social media", "logos"], codepoint: 60688, published_in: 2, updated_in: 2.1 }, { name: "google-cardboard-logo", pascal_name: "GoogleCardboardLogo", categories: [e.BRAND], figma_category: a.GAMES, tags: ["virtual reality", "vr", "logos"], codepoint: 59318, published_in: 2, updated_in: 2 }, { name: "google-chrome-logo", pascal_name: "GoogleChromeLogo", categories: [e.BRAND], figma_category: a.BRAND, tags: ["web browsers", "internet"], codepoint: 59766, published_in: 1.4, updated_in: 1.4 }, { name: "google-drive-logo", pascal_name: "GoogleDriveLogo", categories: [e.BRAND], figma_category: a.BRAND, tags: ["cloud", "storage", "backup", "logos"], codepoint: 59638, published_in: 2, updated_in: 2 }, { name: "google-logo", pascal_name: "GoogleLogo", categories: [e.BRAND], figma_category: a.BRAND, tags: ["logos", "search engine", "phone", "mobile", "android"], codepoint: 58002, published_in: 1, updated_in: 1 }, { name: "google-photos-logo", pascal_name: "GooglePhotosLogo", categories: [e.BRAND, e.MEDIA], figma_category: a.BRAND, tags: ["album", "pictures", "photography"], codepoint: 60306, published_in: 1.4, updated_in: 1.4 }, { name: "google-play-logo", pascal_name: "GooglePlayLogo", categories: [e.BRAND, e.SYSTEM, e.MEDIA], figma_category: a.BRAND, tags: ["logos", "games", "apps", "applications", "play store", "app store", "phone", "mobile", "android"], codepoint: 58004, published_in: 1, updated_in: 1 }, { name: "google-podcasts-logo", pascal_name: "GooglePodcastsLogo", categories: [e.BRAND, e.MEDIA], figma_category: a.BRAND, tags: ["audio"], codepoint: 60308, published_in: 1.4, updated_in: 1.4 }, { name: "gps", pascal_name: "Gps", categories: [e.MAP, e.SYSTEM], figma_category: a.MAP, tags: ["*new*", "geolocation", "location", "navigation"], codepoint: 60888, published_in: 2.1, updated_in: 2.1 }, { name: "gps-fix", pascal_name: "GpsFix", categories: [e.MAP, e.SYSTEM], figma_category: a.MAP, tags: ["*new*", "geolocation", "location", "navigation"], codepoint: 60886, published_in: 2.1, updated_in: 2.1 }, { name: "gps-slash", pascal_name: "GpsSlash", categories: [e.MAP, e.SYSTEM], figma_category: a.MAP, tags: ["*new*", "geolocation", "location", "navigation", "disabled"], codepoint: 60884, published_in: 2.1, updated_in: 2.1 }, { name: "gradient", pascal_name: "Gradient", categories: [e.DESIGN], figma_category: a.DESIGN, tags: ["fade", "ombre", "opacity"], codepoint: 60226, published_in: 1.4, updated_in: 1.4 }, { name: "graduation-cap", pascal_name: "GraduationCap", categories: [e.MAP, e.OBJECTS], figma_category: a.EDUCATION, tags: ["classroom", "teacher", "education", "school", "college", "university", "degree", "graduate", "hat"], codepoint: 58924, published_in: 1.2, updated_in: 1.2 }, { name: "grains", pascal_name: "Grains", categories: [e.COMMERCE, e.NATURE], figma_category: a.COMMERCE, tags: ["wheat", "gluten", "farm", "farming", "agriculture"], codepoint: 60520, published_in: 2, updated_in: 2 }, { name: "grains-slash", pascal_name: "GrainsSlash", categories: [e.COMMERCE], figma_category: a.COMMERCE, tags: ["gluten-free", "wheat", "gluten", "farm", "farming", "agriculture"], codepoint: 60522, published_in: 2, updated_in: 2 }, { name: "graph", pascal_name: "Graph", categories: [e.OFFICE, e.DEVELOPMENT], figma_category: a.FINANCE, tags: ["nodes", "tree"], codepoint: 60248, published_in: 1.4, updated_in: 1.4 }, { name: "graphics-card", pascal_name: "GraphicsCard", categories: [e.DEVELOPMENT], figma_category: a.DEVELOPMENT, tags: ["*new*", "graphics card", "microchip", "computer", "circuit"], codepoint: 58898, published_in: 2.1, updated_in: 2.1 }, { name: "greater-than", pascal_name: "GreaterThan", categories: [e.FINANCE, e.DEVELOPMENT], figma_category: a.FINANCE, tags: ["*new*", ">", "greater than", "gt", "comparison", "mathematics", "arithmetic", "calculator"], codepoint: 60868, published_in: 2.1, updated_in: 2.1 }, { name: "greater-than-or-equal", pascal_name: "GreaterThanOrEqual", categories: [e.FINANCE, e.DEVELOPMENT], figma_category: a.FINANCE, tags: ["*new*", "\u2265", "greater than or equal", "gte", "comparison", "mathematics", "arithmetic", "calculator"], codepoint: 60834, published_in: 2.1, updated_in: 2.1 }, { name: "grid-four", pascal_name: "GridFour", categories: [e.DESIGN, e.SYSTEM], figma_category: a.DESIGN, tags: ["4", "apps", "applications", "squares", "tiles", "cells", "tables", "tabular", "spreadsheets", "excel"], codepoint: 58006, published_in: 1, updated_in: 2 }, { name: "grid-nine", pascal_name: "GridNine", categories: [e.DESIGN, e.SYSTEM], figma_category: a.DESIGN, tags: ["9", "apps", "applications", "squares", "tiles", "cells", "tables", "tabular", "spreadsheets", "excel"], codepoint: 60556, published_in: 2, updated_in: 2 }, { name: "guitar", pascal_name: "Guitar", categories: [e.MEDIA, e.OBJECTS], figma_category: a.MEDIA, tags: ["music", "instrument"], codepoint: 60042, published_in: 2, updated_in: 2 }, { name: "hair-dryer", pascal_name: "HairDryer", categories: [e.COMMERCE, e.OBJECTS], figma_category: a.COMMERCE, tags: ["*new*", "blow dryer", "beauty", "grooming", "salon"], codepoint: 60006, published_in: 2.1, updated_in: 2.1 }, { name: "hamburger", pascal_name: "Hamburger", categories: [e.COMMERCE, e.MAP], figma_category: a.COMMERCE, tags: ["fast food", "party", "places", "locations", "restaurants", "food", "dining"], codepoint: 59280, published_in: 1.4, updated_in: 1.4 }, { name: "hammer", pascal_name: "Hammer", categories: [e.OBJECTS, e.SYSTEM, e.COMMERCE], figma_category: a.COMMERCE, tags: ["tools", "carpentry", "construction"], codepoint: 59406, published_in: 2, updated_in: 2 }, { name: "hand", pascal_name: "Hand", categories: [e.SYSTEM, e.PEOPLE], figma_category: a.PEOPLE, tags: ["pointers", "cursors", "emoji", "backhand"], codepoint: 58008, published_in: 1, updated_in: 1 }, { name: "hand-arrow-down", pascal_name: "HandArrowDown", categories: [e.PEOPLE, e.COMMERCE, e.FINANCE], figma_category: a.PEOPLE, tags: ["*new*", "take", "receive", "remove", "withdraw", "emoji"], codepoint: 59982, published_in: 2.1, updated_in: 2.1 }, { name: "hand-arrow-up", pascal_name: "HandArrowUp", categories: [e.PEOPLE, e.COMMERCE, e.FINANCE], figma_category: a.PEOPLE, tags: ["*new*", "give", "insert", "deposit", "donation", "emoji"], codepoint: 61018, published_in: 2.1, updated_in: 2.1 }, { name: "hand-coins", pascal_name: "HandCoins", categories: [e.PEOPLE, e.COMMERCE, e.FINANCE], figma_category: a.COMMERCE, tags: ["donation", "payment", "money", "paying", "purchase"], codepoint: 60044, published_in: 2, updated_in: 2 }, { name: "hand-deposit", pascal_name: "HandDeposit", categories: [e.PEOPLE, e.COMMERCE, e.FINANCE], figma_category: a.PEOPLE, tags: ["*new*", "give", "insert", "donation", "atm", "emoji"], codepoint: 61058, published_in: 2.1, updated_in: 2.1 }, { name: "hand-eye", pascal_name: "HandEye", categories: [e.PEOPLE], figma_category: a.PEOPLE, tags: ["*updated*", "emoji", "hamsa", "evil eye"], codepoint: 59980, published_in: 1.4, updated_in: 2.1 }, { name: "hand-fist", pascal_name: "HandFist", categories: [e.PEOPLE], figma_category: a.PEOPLE, tags: ["emoji", "power", "protest", "blm"], codepoint: 58746, published_in: 1.1, updated_in: 1.1 }, { name: "hand-grabbing", pascal_name: "HandGrabbing", categories: [e.SYSTEM, e.PEOPLE], figma_category: a.PEOPLE, tags: ["pointers", "cursors", "emoji", "drag", "hold"], codepoint: 58748, published_in: 1.1, updated_in: 1.1 }, { name: "hand-heart", pascal_name: "HandHeart", categories: [e.PEOPLE], figma_category: a.HEALTH, tags: ["donation", "care", "emoji"], codepoint: 59408, published_in: 2, updated_in: 2 }, { name: "hand-palm", pascal_name: "HandPalm", categories: [e.SYSTEM, e.PEOPLE], figma_category: a.PEOPLE, tags: ["pointers", "cursors", "emoji", "palm", "stop", "wait", "hamsa", "5"], codepoint: 58750, published_in: 1.1, updated_in: 1.1 }, { name: "hand-peace", pascal_name: "HandPeace", categories: [e.PEOPLE, e.COMMUNICATION], figma_category: a.PEOPLE, tags: ["*new*", "emoji", "victory"], codepoint: 59340, published_in: 2.1, updated_in: 2.1 }, { name: "hand-pointing", pascal_name: "HandPointing", categories: [e.SYSTEM, e.PEOPLE], figma_category: a.PEOPLE, tags: ["pointers", "cursors", "emoji", "fingers", "clicks", "mouse"], codepoint: 58010, published_in: 1, updated_in: 1 }, { name: "hand-soap", pascal_name: "HandSoap", categories: [e.HEALTH, e.OBJECTS], figma_category: a.HEALTH, tags: ["dispenser", "pump", "sanitizer", "disinfectant", "lotion", "bottle"], codepoint: 58928, published_in: 1.2, updated_in: 1.2 }, { name: "hand-swipe-left", pascal_name: "HandSwipeLeft", categories: [e.PEOPLE, e.SYSTEM], figma_category: a.SYSTEM, tags: ["pointers", "cursors", "gesture"], codepoint: 60564, published_in: 2, updated_in: 2 }, { name: "hand-swipe-right", pascal_name: "HandSwipeRight", categories: [e.PEOPLE, e.SYSTEM], figma_category: a.SYSTEM, tags: ["pointers", "cursors", "gesture"], codepoint: 60562, published_in: 2, updated_in: 2 }, { name: "hand-tap", pascal_name: "HandTap", categories: [e.PEOPLE, e.SYSTEM], figma_category: a.SYSTEM, tags: ["pointers", "cursors", "gesture"], codepoint: 60560, published_in: 2, updated_in: 2 }, { name: "hand-waving", pascal_name: "HandWaving", categories: [e.SYSTEM, e.PEOPLE], figma_category: a.PEOPLE, tags: ["emoji", "palm", "wave", "hello", "goodbye"], codepoint: 58752, published_in: 1.1, updated_in: 1.1 }, { name: "hand-withdraw", pascal_name: "HandWithdraw", categories: [e.PEOPLE, e.COMMERCE, e.FINANCE], figma_category: a.PEOPLE, tags: ["*new*", "take", "remove", "withdrawal", "atm", "emoji"], codepoint: 61056, published_in: 2.1, updated_in: 2.1 }, { name: "handbag", pascal_name: "Handbag", categories: [e.COMMERCE, e.OBJECTS], figma_category: a.COMMERCE, tags: ["suitcases", "valises", "baggage", "purses"], codepoint: 58012, published_in: 1, updated_in: 1 }, { name: "handbag-simple", pascal_name: "HandbagSimple", categories: [e.COMMERCE, e.OBJECTS], figma_category: a.COMMERCE, tags: ["suitcases", "valises", "baggage", "purses"], codepoint: 58926, published_in: 1.2, updated_in: 1.2 }, { name: "hands-clapping", pascal_name: "HandsClapping", categories: [e.SYSTEM, e.PEOPLE], figma_category: a.PEOPLE, tags: ["emoji", "clap", "applause"], codepoint: 59040, published_in: 1.3, updated_in: 1.4 }, { name: "hands-praying", pascal_name: "HandsPraying", categories: [e.PEOPLE], figma_category: a.PEOPLE, tags: ["emoji", "religion", "worship", "prayer", "thanks", "thank you"], codepoint: 60616, published_in: 2, updated_in: 2 }, { name: "handshake", pascal_name: "Handshake", categories: [e.PEOPLE, e.COMMERCE], figma_category: a.PEOPLE, tags: ["emoji", "deal", "agreement"], codepoint: 58754, published_in: 1.1, updated_in: 1.1 }, { name: "hard-drive", pascal_name: "HardDrive", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["saved", "saving", "archived", "archiving", "archival", "hard disk", "storage", "hdd", "servers", "databases"], codepoint: 58014, published_in: 1, updated_in: 1 }, { name: "hard-drives", pascal_name: "HardDrives", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["saved", "saving", "archived", "archiving", "archival", "hard disk", "storage", "hdd", "servers", "databases"], codepoint: 58016, published_in: 1, updated_in: 1 }, { name: "hard-hat", pascal_name: "HardHat", categories: [e.COMMERCE, e.OBJECTS, e.DEVELOPMENT], figma_category: a.COMMERCE, tags: ["*new*", "safety", "construction", "industry", "helmet", "ppe"], codepoint: 60742, published_in: 2.1, updated_in: 2.1 }, { name: "hash", pascal_name: "Hash", categories: [e.COMMUNICATION], figma_category: a.COMMUNICATION, tags: ["hashtag", "octothorpe", "pound sign", "number sign", "tic-tac-toe", "symbol"], codepoint: 58018, published_in: 1, updated_in: 1 }, { name: "hash-straight", pascal_name: "HashStraight", categories: [e.COMMUNICATION], figma_category: a.COMMUNICATION, tags: ["hashtag", "octothorpe", "pound sign", "number sign", "tic-tac-toe", "symbol"], codepoint: 58020, published_in: 1, updated_in: 1 }, { name: "head-circuit", pascal_name: "HeadCircuit", categories: [e.DEVELOPMENT], figma_category: a.DEVELOPMENT, tags: ["*new*", "automaton", "artificial intelligence", "ai"], codepoint: 59348, published_in: 2.1, updated_in: 2.1 }, { name: "headlights", pascal_name: "Headlights", categories: [e.MAP, e.OBJECTS], figma_category: a.MAP, tags: ["brights", "high beams"], codepoint: 59134, published_in: 1.3, updated_in: 1.3 }, { name: "headphones", pascal_name: "Headphones", categories: [e.MEDIA, e.OBJECTS], figma_category: a.MEDIA, tags: ["music", "audio", "listening"], codepoint: 58022, published_in: 1, updated_in: 1 }, { name: "headset", pascal_name: "Headset", categories: [e.MEDIA, e.GAMES, e.OBJECTS], figma_category: a.MEDIA, tags: ["music", "audio", "listening", "gaming", "voice chat", "microphone", "headphones", "support", "customer-service", "call-center"], codepoint: 58756, published_in: 1.1, updated_in: 1.1 }, { name: "heart", pascal_name: "Heart", categories: [e.COMMUNICATION, e.GAMES, e.HEALTH], figma_category: a.GAMES, tags: ["wellness", "love", "healthy", "like", "favorites", "favorited", "suits", "cards", "gambling", "casino", "gaming", "emoji"], codepoint: 58024, published_in: 1, updated_in: 1 }, { name: "heart-break", pascal_name: "HeartBreak", categories: [e.COMMUNICATION], figma_category: a.GAMES, tags: ["love", "hate", "crack", "split", "divorce", "emoji"], codepoint: 60392, published_in: 1.4, updated_in: 1.4 }, { name: "heart-half", pascal_name: "HeartHalf", categories: [e.COMMUNICATION, e.GAMES, e.HEALTH], figma_category: a.GAMES, tags: ["wellness", "love", "healthy", "like", "favorites", "favorited"], codepoint: 60488, published_in: 2, updated_in: 2 }, { name: "heart-straight", pascal_name: "HeartStraight", categories: [e.COMMUNICATION, e.GAMES, e.HEALTH], figma_category: a.GAMES, tags: ["wellness", "love", "healthy", "like", "favorites", "favorited", "suits", "cards", "gambling", "casino", "gaming", "emoji"], codepoint: 58026, published_in: 1, updated_in: 1 }, { name: "heart-straight-break", pascal_name: "HeartStraightBreak", categories: [e.COMMUNICATION], figma_category: a.GAMES, tags: ["love", "hate", "crack", "split", "divorce", "emoji"], codepoint: 60312, published_in: 1.4, updated_in: 1.4 }, { name: "heartbeat", pascal_name: "Heartbeat", categories: [e.HEALTH, e.SYSTEM], figma_category: a.HEALTH, tags: ["wellness", "healthy", "ecg", "ekg", "vitals", "monitor"], codepoint: 58028, published_in: 1, updated_in: 1.4 }, { name: "hexagon", pascal_name: "Hexagon", categories: [e.DESIGN], figma_category: a.DESIGN, tags: ["6", "shapes", "polygons"], codepoint: 58030, published_in: 1, updated_in: 1 }, { name: "high-definition", pascal_name: "HighDefinition", categories: [e.MEDIA], figma_category: a.MEDIA, tags: ["*new*", "hd", "resolution", "video"], codepoint: 60046, published_in: 2.1, updated_in: 2.1 }, { name: "high-heel", pascal_name: "HighHeel", categories: [e.COMMERCE, e.OBJECTS], figma_category: a.COMMERCE, tags: ["*updated*", "pumps", "clothes", "clothing", "shoes"], codepoint: 59624, published_in: 2, updated_in: 2.1 }, { name: "highlighter", pascal_name: "Highlighter", categories: [e.DESIGN, e.EDITOR, e.OFFICE], figma_category: a.DESIGN, tags: ["*new*", "marker", "write", "writing", "editing"], codepoint: 60534, published_in: 2.1, updated_in: 2.1 }, { name: "highlighter-circle", pascal_name: "HighlighterCircle", categories: [e.DESIGN, e.EDITOR, e.OFFICE], figma_category: a.DESIGN, tags: ["write", "writing", "editing", "drawing"], codepoint: 58930, published_in: 1.2, updated_in: 1.2 }, { name: "hockey", pascal_name: "Hockey", categories: [e.GAMES, e.HEALTH, e.OBJECTS], figma_category: a.GAMES, tags: ["*new*", "sports", "nhl", "stick", "puck"], codepoint: 60550, published_in: 2.1, updated_in: 2.1 }, { name: "hoodie", pascal_name: "Hoodie", categories: [e.COMMERCE, e.OBJECTS], figma_category: a.COMMERCE, tags: ["clothes", "clothing", "sweatshirt"], codepoint: 60624, published_in: 2, updated_in: 2 }, { name: "horse", pascal_name: "Horse", categories: [e.GAMES, e.HEALTH, e.NATURE], figma_category: a.GAMES, tags: ["animals", "equestrian", "chess", "knight", "sports"], codepoint: 58032, published_in: 1, updated_in: 1 }, { name: "hospital", pascal_name: "Hospital", categories: [e.MAP, e.HEALTH], figma_category: a.MAP, tags: ["*new*", "places", "locations", "medical", "medicine", "emergency", "doctor", "buildings"], codepoint: 59460, published_in: 2.1, updated_in: 2.1 }, { name: "hourglass", pascal_name: "Hourglass", categories: [e.SYSTEM, e.OBJECTS], figma_category: a.TIME, tags: ["times", "timer", "alarms", "clock", "schedule", "events", "waiting", "progress"], codepoint: 58034, published_in: 1, updated_in: 1 }, { name: "hourglass-high", pascal_name: "HourglassHigh", categories: [e.SYSTEM, e.OBJECTS], figma_category: a.TIME, tags: ["times", "timer", "alarms", "clock", "schedule", "events", "waiting", "progress"], codepoint: 58036, published_in: 1, updated_in: 1 }, { name: "hourglass-low", pascal_name: "HourglassLow", categories: [e.SYSTEM, e.OBJECTS], figma_category: a.TIME, tags: ["times", "timer", "alarms", "clock", "schedule", "events", "waiting", "progress"], codepoint: 58038, published_in: 1, updated_in: 1 }, { name: "hourglass-medium", pascal_name: "HourglassMedium", categories: [e.SYSTEM, e.OBJECTS], figma_category: a.TIME, tags: ["times", "timer", "alarms", "clock", "schedule", "events", "waiting", "progress"], codepoint: 58040, published_in: 1, updated_in: 1 }, { name: "hourglass-simple", pascal_name: "HourglassSimple", categories: [e.SYSTEM, e.OBJECTS], figma_category: a.TIME, tags: ["times", "timer", "alarms", "clock", "schedule", "events", "waiting", "progress"], codepoint: 58042, published_in: 1, updated_in: 1 }, { name: "hourglass-simple-high", pascal_name: "HourglassSimpleHigh", categories: [e.SYSTEM, e.OBJECTS], figma_category: a.TIME, tags: ["times", "timer", "alarms", "clock", "schedule", "events", "waiting", "progress"], codepoint: 58044, published_in: 1, updated_in: 1 }, { name: "hourglass-simple-low", pascal_name: "HourglassSimpleLow", categories: [e.SYSTEM, e.OBJECTS], figma_category: a.TIME, tags: ["times", "timer", "alarms", "clock", "schedule", "events", "waiting", "progress"], codepoint: 58046, published_in: 1, updated_in: 1 }, { name: "hourglass-simple-medium", pascal_name: "HourglassSimpleMedium", categories: [e.SYSTEM, e.OBJECTS], figma_category: a.TIME, tags: ["times", "timer", "alarms", "clock", "schedule", "events", "waiting", "progress"], codepoint: 58048, published_in: 1, updated_in: 1 }, { name: "house", pascal_name: "House", categories: [e.MAP, e.SYSTEM], figma_category: a.MAP, tags: ["homes", "buildings", "places", "locations"], codepoint: 58050, published_in: 1, updated_in: 1 }, { name: "house-line", pascal_name: "HouseLine", categories: [e.MAP, e.SYSTEM], figma_category: a.MAP, tags: ["*updated*", "homes", "buildings", "places", "locations"], codepoint: 58052, published_in: 1, updated_in: 2.1 }, { name: "house-simple", pascal_name: "HouseSimple", categories: [e.MAP, e.SYSTEM], figma_category: a.MAP, tags: ["homes", "buildings", "places", "locations"], codepoint: 58054, published_in: 1, updated_in: 1 }, { name: "hurricane", pascal_name: "Hurricane", categories: [e.WEATHER], figma_category: a.WEATHER, tags: ["*new*", "meteorology", "cyclone", "storm", "disaster", "wind"], codepoint: 59534, published_in: 2.1, updated_in: 2.1 }, { name: "ice-cream", pascal_name: "IceCream", categories: [e.COMMERCE, e.MAP, e.OBJECTS], figma_category: a.COMMERCE, tags: ["food", "dessert", "cone"], codepoint: 59396, published_in: 2, updated_in: 2 }, { name: "identification-badge", pascal_name: "IdentificationBadge", categories: [e.PEOPLE], figma_category: a.PEOPLE, tags: ["license", "credentials", "nametag", "user", "verification"], codepoint: 59126, published_in: 1.3, updated_in: 1.3 }, { name: "identification-card", pascal_name: "IdentificationCard", categories: [e.PEOPLE], figma_category: a.PEOPLE, tags: ["license", "badge", "credentials", "nametag", "user", "verification"], codepoint: 58056, published_in: 1, updated_in: 1 }, { name: "image", pascal_name: "Image", categories: [e.MEDIA, e.SYSTEM], figma_category: a.MEDIA, tags: ["*updated*", "pictures", "photographs", "photography", "wallpapers", "gallery", "landscape"], codepoint: 58058, published_in: 1, updated_in: 2.1 }, { name: "image-broken", pascal_name: "ImageBroken", categories: [e.MEDIA, e.SYSTEM], figma_category: a.MEDIA, tags: ["*new*", "pictures", "photographs", "photography", "wallpapers", "gallery", "landscape", "missing", "error", "404"], codepoint: 59304, published_in: 2.1, updated_in: 2.1 }, { name: "image-square", pascal_name: "ImageSquare", categories: [e.MEDIA, e.SYSTEM], figma_category: a.MEDIA, tags: ["pictures", "photographs", "photography", "wallpapers", "gallery", "landscape"], codepoint: 58060, published_in: 1, updated_in: 2 }, { name: "images", pascal_name: "Images", categories: [e.MEDIA, e.SYSTEM], figma_category: a.MEDIA, tags: ["*updated*", "pictures", "photographs", "photography", "wallpapers", "gallery", "landscape", "album"], codepoint: 59446, published_in: 2, updated_in: 2.1 }, { name: "images-square", pascal_name: "ImagesSquare", categories: [e.MEDIA, e.SYSTEM], figma_category: a.MEDIA, tags: ["pictures", "photographs", "photography", "wallpapers", "gallery", "landscape", "album"], codepoint: 59444, published_in: 2, updated_in: 2 }, { name: "infinity", pascal_name: "Infinity", alias: { name: "lemniscate", pascal_name: "Lemniscate" }, categories: [e.DEVELOPMENT, e.FINANCE], figma_category: a.FINANCE, tags: ["infinite", "lemniscate", "figure-eight", "mathematics", "arithmetic", "calculator", "\u221E"], codepoint: 58932, published_in: 1.2, updated_in: 1.2 }, { name: "info", pascal_name: "Info", categories: [e.SYSTEM], figma_category: a.SECURITY, tags: ["information", "help", "support"], codepoint: 58062, published_in: 1, updated_in: 1 }, { name: "instagram-logo", pascal_name: "InstagramLogo", categories: [e.BRAND, e.COMMUNICATION], figma_category: a.BRAND, tags: ["logos", "social media", "photography", "camera"], codepoint: 58064, published_in: 1, updated_in: 1 }, { name: "intersect", pascal_name: "Intersect", categories: [e.DESIGN, e.EDITOR], figma_category: a.DESIGN, tags: ["round", "join", "union", "merge", "combine", "intersecting", "intersection"], codepoint: 58066, published_in: 1, updated_in: 1 }, { name: "intersect-square", pascal_name: "IntersectSquare", categories: [e.DESIGN, e.EDITOR], figma_category: a.DESIGN, tags: ["venn-diagram", "join", "intersection"], codepoint: 59514, published_in: 2, updated_in: 2 }, { name: "intersect-three", pascal_name: "IntersectThree", categories: [e.PEOPLE, e.DESIGN, e.EDITOR], figma_category: a.DESIGN, tags: ["venn-diagram", "join", "intersection", "gender", "pronouns"], codepoint: 60612, published_in: 2, updated_in: 2 }, { name: "intersection", pascal_name: "Intersection", categories: [e.FINANCE, e.DEVELOPMENT], figma_category: a.FINANCE, tags: ["*new*", "\u2229", "intersection", "set", "member", "mathematics", "arithmetic", "calculator"], codepoint: 60858, published_in: 2.1, updated_in: 2.1 }, { name: "invoice", pascal_name: "Invoice", categories: [e.COMMERCE, e.FINANCE, e.OFFICE], figma_category: a.COMMERCE, tags: ["*new*", "receipt", "expense", "bill"], codepoint: 60994, published_in: 2.1, updated_in: 2.1 }, { name: "island", pascal_name: "Island", categories: [e.MAP, e.NATURE], figma_category: a.WEATHER, tags: ["*new*", "geography", "beach", "ocean", "tropical", "palm", "vacation", "trip", "locations", "places"], codepoint: 60934, published_in: 2.1, updated_in: 2.1 }, { name: "jar", pascal_name: "Jar", categories: [e.COMMERCE, e.OBJECTS], figma_category: a.COMMERCE, tags: ["*new*", "mason jar", "kitchen", "pantry", "canning", "preserves", "food", "condiments"], codepoint: 59360, published_in: 2.1, updated_in: 2.1 }, { name: "jar-label", pascal_name: "JarLabel", categories: [e.COMMERCE, e.OBJECTS], figma_category: a.COMMERCE, tags: ["*new*", "mason jar", "kitchen", "pantry", "canning", "preserves", "food", "condiments"], codepoint: 59360, published_in: 2.1, updated_in: 2.1 }, { name: "jeep", pascal_name: "Jeep", categories: [e.MAP, e.OBJECTS], figma_category: a.MAP, tags: ["*updated*", "vehicles", "automobile", "suv", "cars", "trucks", "wrangler", "off-road", "transit", "transportation", "traveling"], codepoint: 58068, published_in: 1, updated_in: 2.1 }, { name: "joystick", pascal_name: "Joystick", categories: [e.GAMES, e.MEDIA, e.OBJECTS], figma_category: a.GAMES, tags: ["*new*", "gaming", "game controller", "video games", "arcade game", "atari"], codepoint: 59998, published_in: 2.1, updated_in: 2.1 }, { name: "kanban", pascal_name: "Kanban", categories: [e.OFFICE], figma_category: a.OFFICE, tags: ["scheduling", "tasks", "project management", "process", "lean", "agile"], codepoint: 60244, published_in: 1.4, updated_in: 1.4 }, { name: "key", pascal_name: "Key", categories: [e.OBJECTS, e.SYSTEM], figma_category: a.SECURITY, tags: ["padlock", "security", "secured", "authentication", "authenticated", "login", "locked", "encrypted", "encryption"], codepoint: 58070, published_in: 1, updated_in: 1 }, { name: "key-return", pascal_name: "KeyReturn", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["keyboard", "enter"], codepoint: 59266, published_in: 1.3, updated_in: 1.3 }, { name: "keyboard", pascal_name: "Keyboard", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["typing", "type", "keys", "input"], codepoint: 58072, published_in: 1, updated_in: 1 }, { name: "keyhole", pascal_name: "Keyhole", categories: [e.OBJECTS, e.SYSTEM], figma_category: a.SECURITY, tags: ["lock", "security", "secured", "authentication", "authenticated", "login", "locked", "encrypted", "encryption", "privacy", "private"], codepoint: 60024, published_in: 1.4, updated_in: 1.4 }, { name: "knife", pascal_name: "Knife", categories: [e.COMMERCE, e.OBJECTS], figma_category: a.COMMERCE, tags: ["tools", "food", "meal", "eating", "restaurants", "dining", "utensils"], codepoint: 58934, published_in: 1.2, updated_in: 1.2 }, { name: "ladder", pascal_name: "Ladder", categories: [e.OBJECTS], figma_category: a.COMMERCE, tags: ["stairs", "steps", "climbing"], codepoint: 59876, published_in: 1.4, updated_in: 1.4 }, { name: "ladder-simple", pascal_name: "LadderSimple", categories: [e.OBJECTS], figma_category: a.COMMERCE, tags: ["stairs", "steps", "climbing"], codepoint: 60454, published_in: 1.4, updated_in: 1.4 }, { name: "lamp", pascal_name: "Lamp", categories: [e.OBJECTS, e.COMMERCE], figma_category: a.COMMERCE, tags: ["light", "furniture", "appliances"], codepoint: 58936, published_in: 1.2, updated_in: 1.2 }, { name: "lamp-pendant", pascal_name: "LampPendant", categories: [e.COMMERCE, e.OBJECTS], figma_category: a.COMMERCE, tags: ["*new*", "light", "furniture", "appliances"], codepoint: 60974, published_in: 2.1, updated_in: 2.1 }, { name: "laptop", pascal_name: "Laptop", categories: [e.DEVELOPMENT, e.OBJECTS], figma_category: a.SYSTEM, tags: ["computer", "notebook", "pc", "macbook"], codepoint: 58758, published_in: 1.1, updated_in: 1.1 }, { name: "lasso", pascal_name: "Lasso", categories: [e.DESIGN, e.OBJECTS], figma_category: a.DESIGN, tags: ["*new*", "select", "selection", "loop", "rope", "cowboy"], codepoint: 60870, published_in: 2.1, updated_in: 2.1 }, { name: "lastfm-logo", pascal_name: "LastfmLogo", categories: [e.BRAND, e.MEDIA], figma_category: a.BRAND, tags: ["*new*", "scrobble", "music", "social media"], codepoint: 59458, published_in: 2.1, updated_in: 2.1 }, { name: "layout", pascal_name: "Layout", categories: [e.DESIGN, e.EDITOR], figma_category: a.DESIGN, tags: ["wireframe", "sidebar", "ui", "interface"], codepoint: 59094, published_in: 1.3, updated_in: 1.3 }, { name: "leaf", pascal_name: "Leaf", categories: [e.NATURE], figma_category: a.WEATHER, tags: ["plants", "trees", "branches", "leaves", "nodes", "green", "environmental"], codepoint: 58074, published_in: 1, updated_in: 2 }, { name: "lectern", pascal_name: "Lectern", categories: [e.OBJECTS, e.FINANCE, e.OFFICE], figma_category: a.EDUCATION, tags: ["*new*", "lecture", "podium", "pulpit", "stand", "speech", "presentation", "keynote"], codepoint: 59738, published_in: 2.1, updated_in: 2.1 }, { name: "lego", pascal_name: "Lego", categories: [e.GAMES], figma_category: a.GAMES, tags: ["*new*", "toys", "blocks", "bricks"], codepoint: 59590, published_in: 2.1, updated_in: 2.1 }, { name: "lego-smiley", pascal_name: "LegoSmiley", categories: [e.GAMES, e.COMMUNICATION, e.PEOPLE], figma_category: a.GAMES, tags: ["*new*", "face", "emoji", "toys", "blocks", "bricks"], codepoint: 59590, published_in: 2.1, updated_in: 2.1 }, { name: "less-than", pascal_name: "LessThan", categories: [e.FINANCE, e.DEVELOPMENT], figma_category: a.FINANCE, tags: ["*new*", "<", "less than", "lt", "comparison", "mathematics", "arithmetic", "calculator"], codepoint: 60844, published_in: 2.1, updated_in: 2.1 }, { name: "less-than-or-equal", pascal_name: "LessThanOrEqual", categories: [e.FINANCE, e.DEVELOPMENT], figma_category: a.FINANCE, tags: ["*new*", "\u2264", "less than or equal", "lte", "comparison", "mathematics", "arithmetic", "calculator"], codepoint: 60836, published_in: 2.1, updated_in: 2.1 }, { name: "letter-circle-h", pascal_name: "LetterCircleH", categories: [e.EDITOR, e.MAP, e.DESIGN], figma_category: a.COMMUNICATION, tags: ["*new*", "hospital", "letter", "glyph", "character"], codepoint: 60408, published_in: 2.1, updated_in: 2.1 }, { name: "letter-circle-p", pascal_name: "LetterCircleP", categories: [e.EDITOR, e.MAP, e.DESIGN], figma_category: a.COMMUNICATION, tags: ["*new*", "parking lot", "valet", "vehicles", "letter", "glyph", "character"], codepoint: 60424, published_in: 2.1, updated_in: 2.1 }, { name: "letter-circle-v", pascal_name: "LetterCircleV", categories: [e.EDITOR, e.DESIGN, e.COMMERCE], figma_category: a.COMMUNICATION, tags: ["*new*", "vegan", "letter", "glyph", "character"], codepoint: 60436, published_in: 2.1, updated_in: 2.1 }, { name: "lifebuoy", pascal_name: "Lifebuoy", categories: [e.HEALTH, e.OBJECTS, e.SYSTEM], figma_category: a.HEALTH, tags: ["lifebelt", "lifesaver", "safety", "help", "support", "nautical", "boats", "ships"], codepoint: 58938, published_in: 1.2, updated_in: 1.2 }, { name: "lightbulb", pascal_name: "Lightbulb", categories: [e.SYSTEM, e.OBJECTS], figma_category: a.SYSTEM, tags: ["flashlight", "bulbs", "lighting", "led", "energy", "idea"], codepoint: 58076, published_in: 1, updated_in: 1 }, { name: "lightbulb-filament", pascal_name: "LightbulbFilament", categories: [e.SYSTEM, e.OBJECTS], figma_category: a.SYSTEM, tags: ["flashlight", "bulbs", "lighting", "led", "energy", "idea"], codepoint: 58940, published_in: 1.2, updated_in: 1.2 }, { name: "lighthouse", pascal_name: "Lighthouse", categories: [e.MAP], figma_category: a.MAP, tags: ["buildings", "nautical", "navigation", "boats", "ships", "safety"], codepoint: 59894, published_in: 2, updated_in: 2 }, { name: "lightning", pascal_name: "Lightning", categories: [e.WEATHER, e.SYSTEM], figma_category: a.SYSTEM, tags: ["meteorology", "stormy", "thunderstorm", "thunderbolt", "charged", "charger", "charging", "power", "electricity", "flash"], codepoint: 58078, published_in: 1, updated_in: 1 }, { name: "lightning-a", pascal_name: "LightningA", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["flash", "auto"], codepoint: 60036, published_in: 2, updated_in: 2 }, { name: "lightning-slash", pascal_name: "LightningSlash", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["thunderbolt", "charged", "charger", "charging", "power", "electricity", "disabled", "flash"], codepoint: 58080, published_in: 1, updated_in: 1 }, { name: "line-segment", pascal_name: "LineSegment", categories: [e.DESIGN], figma_category: a.DESIGN, tags: ["shapes", "drawing", "path", "pen", "vector"], codepoint: 59090, published_in: 1.3, updated_in: 1.3 }, { name: "line-segments", pascal_name: "LineSegments", categories: [e.DESIGN], figma_category: a.DESIGN, tags: ["shapes", "drawing", "path", "pen", "vector"], codepoint: 59092, published_in: 1.3, updated_in: 1.3 }, { name: "line-vertical", pascal_name: "LineVertical", categories: [e.DESIGN, e.DEVELOPMENT], figma_category: a.DESIGN, tags: ["*new*", "bar", "pipe", "|", "divider. symbol"], codepoint: 60784, published_in: 2.1, updated_in: 2.1 }, { name: "link", pascal_name: "Link", categories: [e.COMMUNICATION, e.OBJECTS], figma_category: a.SYSTEM, tags: ["*updated*", "anchor", "hyperlink", "hypertext", "chains", "chained"], codepoint: 58082, published_in: 1, updated_in: 2.1 }, { name: "link-break", pascal_name: "LinkBreak", categories: [e.COMMUNICATION, e.OBJECTS], figma_category: a.SYSTEM, tags: ["anchor", "hyperlink", "hypertext", "chains", "chained", "errors", "broken"], codepoint: 58084, published_in: 1, updated_in: 1 }, { name: "link-simple", pascal_name: "LinkSimple", categories: [e.COMMUNICATION, e.OBJECTS], figma_category: a.SYSTEM, tags: ["anchor", "hyperlink", "hypertext", "chains", "chained"], codepoint: 58086, published_in: 1, updated_in: 1 }, { name: "link-simple-break", pascal_name: "LinkSimpleBreak", categories: [e.COMMUNICATION, e.OBJECTS], figma_category: a.SYSTEM, tags: ["anchor", "hyperlink", "hypertext", "chains", "chained", "errors", "broken"], codepoint: 58088, published_in: 1, updated_in: 1 }, { name: "link-simple-horizontal", pascal_name: "LinkSimpleHorizontal", categories: [e.COMMUNICATION, e.OBJECTS], figma_category: a.SYSTEM, tags: ["anchor", "hyperlink", "hypertext", "chains", "chained"], codepoint: 58090, published_in: 1, updated_in: 1 }, { name: "link-simple-horizontal-break", pascal_name: "LinkSimpleHorizontalBreak", categories: [e.COMMUNICATION, e.OBJECTS], figma_category: a.SYSTEM, tags: ["anchor", "hyperlink", "hypertext", "chains", "chained", "errors", "broken"], codepoint: 58092, published_in: 1, updated_in: 1 }, { name: "linkedin-logo", pascal_name: "LinkedinLogo", categories: [e.BRAND, e.COMMUNICATION], figma_category: a.BRAND, tags: ["logos", "jobs", "employment", "social media"], codepoint: 58094, published_in: 1, updated_in: 1 }, { name: "linktree-logo", pascal_name: "LinktreeLogo", categories: [e.BRAND, e.COMMUNICATION], figma_category: a.BRAND, tags: ["*new*", "social media", "links"], codepoint: 60910, published_in: 2.1, updated_in: 2.1 }, { name: "linux-logo", pascal_name: "LinuxLogo", categories: [e.BRAND, e.DEVELOPMENT], figma_category: a.BRAND, tags: ["penguin", "computer", "animals"], codepoint: 60162, published_in: 1.4, updated_in: 1.4 }, { name: "list", pascal_name: "List", categories: [e.SYSTEM, e.EDITOR], figma_category: a.OFFICE, tags: ["*updated*", "hamburger menu", "overflow menu", "sidebar", "3", "ul", "ol", "unordered list", "ordered list", "checklist", "lines"], codepoint: 58096, published_in: 1, updated_in: 2.1 }, { name: "list-bullets", pascal_name: "ListBullets", categories: [e.EDITOR], figma_category: a.OFFICE, tags: ["*updated*", "ul", "unordered list", "bulleted list", "checklist"], codepoint: 58098, published_in: 1, updated_in: 2.1 }, { name: "list-checks", pascal_name: "ListChecks", categories: [e.OFFICE, e.EDITOR], figma_category: a.OFFICE, tags: ["*updated*", "checklist", "todo"], codepoint: 60124, published_in: 1.4, updated_in: 2.1 }, { name: "list-dashes", pascal_name: "ListDashes", categories: [e.EDITOR], figma_category: a.OFFICE, tags: ["*updated*", "ul", "unordered list", "dashed list", "checklist"], codepoint: 58100, published_in: 1, updated_in: 2.1 }, { name: "list-heart", pascal_name: "ListHeart", categories: [e.EDITOR, e.SYSTEM], figma_category: a.SYSTEM, tags: ["*new*", "favorites", "wishlist", "liked"], codepoint: 60382, published_in: 2.1, updated_in: 2.1 }, { name: "list-magnifying-glass", pascal_name: "ListMagnifyingGlass", categories: [e.EDITOR, e.SYSTEM], figma_category: a.SYSTEM, tags: ["search", "find", "locate", "query", "inspect"], codepoint: 60384, published_in: 2, updated_in: 2 }, { name: "list-numbers", pascal_name: "ListNumbers", categories: [e.EDITOR], figma_category: a.OFFICE, tags: ["*updated*", "ol", "ordered list", "numbered list", "checklist"], codepoint: 58102, published_in: 1, updated_in: 2.1 }, { name: "list-plus", pascal_name: "ListPlus", categories: [e.EDITOR], figma_category: a.OFFICE, tags: ["*updated*", "ul", "ol", "unordered list", "ordered list", "checklist", "add", "+"], codepoint: 58104, published_in: 1, updated_in: 2.1 }, { name: "list-star", pascal_name: "ListStar", categories: [e.EDITOR, e.SYSTEM], figma_category: a.SYSTEM, tags: ["*new*", "favorites", "wishlist", "liked"], codepoint: 60380, published_in: 2.1, updated_in: 2.1 }, { name: "lock", pascal_name: "Lock", categories: [e.OBJECTS, e.SYSTEM], figma_category: a.SECURITY, tags: ["padlock", "security", "secured", "authentication", "authenticated", "login", "locked", "encrypted", "encryption", "privacy", "private"], codepoint: 58106, published_in: 1, updated_in: 1 }, { name: "lock-key", pascal_name: "LockKey", categories: [e.OBJECTS, e.SYSTEM], figma_category: a.SECURITY, tags: ["padlock", "security", "secured", "authentication", "authenticated", "login", "locked", "encrypted", "encryption", "privacy", "private"], codepoint: 58110, published_in: 1, updated_in: 1 }, { name: "lock-key-open", pascal_name: "LockKeyOpen", categories: [e.OBJECTS, e.SYSTEM], figma_category: a.SECURITY, tags: ["padlock", "security", "unsecured", "authentication", "unauthenticated", "login", "unlocked", "unencrypted", "encryption", "privacy"], codepoint: 58112, published_in: 1, updated_in: 1 }, { name: "lock-laminated", pascal_name: "LockLaminated", categories: [e.OBJECTS, e.SYSTEM], figma_category: a.SECURITY, tags: ["padlock", "security", "secured", "authentication", "authenticated", "login", "locked", "encrypted", "encryption", "privacy", "private"], codepoint: 58114, published_in: 1, updated_in: 1 }, { name: "lock-laminated-open", pascal_name: "LockLaminatedOpen", categories: [e.OBJECTS, e.SYSTEM], figma_category: a.SECURITY, tags: ["padlock", "security", "unsecured", "authentication", "unauthenticated", "login", "unlocked", "unencrypted", "encryption", "privacy", "private"], codepoint: 58116, published_in: 1, updated_in: 1 }, { name: "lock-open", pascal_name: "LockOpen", categories: [e.OBJECTS, e.SYSTEM], figma_category: a.SECURITY, tags: ["padlock", "security", "unsecured", "authentication", "unauthenticated", "login", "unlocked", "unencrypted", "encryption", "privacy"], codepoint: 58118, published_in: 1, updated_in: 1 }, { name: "lock-simple", pascal_name: "LockSimple", categories: [e.OBJECTS, e.SYSTEM], figma_category: a.SECURITY, tags: ["padlock", "security", "secured", "authentication", "authenticated", "login", "locked", "encrypted", "encryption", "privacy", "private"], codepoint: 58120, published_in: 1, updated_in: 1 }, { name: "lock-simple-open", pascal_name: "LockSimpleOpen", categories: [e.OBJECTS, e.SYSTEM], figma_category: a.SECURITY, tags: ["padlock", "security", "unsecured", "authentication", "unauthenticated", "login", "unlocked", "unencrypted", "encryption", "privacy", "private"], codepoint: 58122, published_in: 1, updated_in: 1 }, { name: "lockers", pascal_name: "Lockers", categories: [e.MAP], figma_category: a.MAP, tags: ["locker room", "gym", "storage"], codepoint: 60600, published_in: 2, updated_in: 2 }, { name: "log", pascal_name: "Log", categories: [e.NATURE], figma_category: a.WEATHER, tags: ["*new*", "tree", "stump", "stick", "branch"], codepoint: 60802, published_in: 2.1, updated_in: 2.1 }, { name: "magic-wand", pascal_name: "MagicWand", categories: [e.DESIGN, e.GAMES, e.OBJECTS], figma_category: a.DESIGN, tags: ["selection", "wizard", "games"], codepoint: 59062, published_in: 1.3, updated_in: 1.3 }, { name: "magnet", pascal_name: "Magnet", categories: [e.DEVELOPMENT, e.OBJECTS], figma_category: a.DEVELOPMENT, tags: ["magnetism", "science", "physics"], codepoint: 59008, published_in: 1.2, updated_in: 1.2 }, { name: "magnet-straight", pascal_name: "MagnetStraight", categories: [e.DEVELOPMENT, e.OBJECTS], figma_category: a.DEVELOPMENT, tags: ["magnetism", "science", "physics"], codepoint: 59010, published_in: 1.2, updated_in: 1.2 }, { name: "magnifying-glass", pascal_name: "MagnifyingGlass", categories: [e.EDITOR, e.SYSTEM], figma_category: a.SYSTEM, tags: ["search", "find", "locate", "query", "inspect"], codepoint: 58124, published_in: 1, updated_in: 1 }, { name: "magnifying-glass-minus", pascal_name: "MagnifyingGlassMinus", categories: [e.EDITOR, e.SYSTEM], figma_category: a.SYSTEM, tags: ["search", "find", "locate", "query", "inspect", "zoom out", "-"], codepoint: 58126, published_in: 1, updated_in: 1 }, { name: "magnifying-glass-plus", pascal_name: "MagnifyingGlassPlus", categories: [e.EDITOR, e.SYSTEM], figma_category: a.SYSTEM, tags: ["search", "find", "locate", "query", "inspect", "zoom in", "+"], codepoint: 58128, published_in: 1, updated_in: 1 }, { name: "mailbox", pascal_name: "Mailbox", categories: [e.COMMUNICATION, e.OBJECTS, e.MAP], figma_category: a.COMMUNICATION, tags: ["*new*", "email", "letters", "messaging", "post"], codepoint: 60446, published_in: 2.1, updated_in: 2.1 }, { name: "map-pin", pascal_name: "MapPin", categories: [e.MAP], figma_category: a.MAP, tags: ["maps", "places", "markers", "pins", "locations", "poi", "point of interest"], codepoint: 58134, published_in: 1, updated_in: 1 }, { name: "map-pin-area", pascal_name: "MapPinArea", categories: [e.MAP], figma_category: a.MAP, tags: ["*new*", "maps", "places", "markers", "pins", "locations", "poi", "point of interest"], codepoint: 60986, published_in: 2.1, updated_in: 2.1 }, { name: "map-pin-line", pascal_name: "MapPinLine", categories: [e.MAP], figma_category: a.MAP, tags: ["maps", "places", "markers", "pins", "locations", "poi", "point of interest"], codepoint: 58136, published_in: 1, updated_in: 1 }, { name: "map-pin-plus", pascal_name: "MapPinPlus", categories: [e.MAP], figma_category: a.MAP, tags: ["*new*", "maps", "places", "markers", "pins", "locations", "add", "point of interest"], codepoint: 58132, published_in: 2.1, updated_in: 2.1 }, { name: "map-pin-simple", pascal_name: "MapPinSimple", categories: [e.MAP], figma_category: a.MAP, tags: ["*new*", "maps", "places", "markers", "pins", "locations", "poi", "point of interest"], codepoint: 60990, published_in: 2.1, updated_in: 2.1 }, { name: "map-pin-simple-area", pascal_name: "MapPinSimpleArea", categories: [e.MAP], figma_category: a.MAP, tags: ["*new*", "maps", "places", "markers", "pins", "locations", "poi", "point of interest"], codepoint: 60988, published_in: 2.1, updated_in: 2.1 }, { name: "map-pin-simple-line", pascal_name: "MapPinSimpleLine", categories: [e.MAP], figma_category: a.MAP, tags: ["*new*", "maps", "places", "markers", "pins", "locations", "poi", "point of interest"], codepoint: 60984, published_in: 2.1, updated_in: 2.1 }, { name: "map-trifold", pascal_name: "MapTrifold", categories: [e.MAP], figma_category: a.MAP, tags: ["maps", "places", "locations", "cartography", "geography"], codepoint: 58138, published_in: 1, updated_in: 2 }, { name: "markdown-logo", pascal_name: "MarkdownLogo", categories: [e.DEVELOPMENT, e.OFFICE, e.MEDIA, e.BRAND], figma_category: a.DEVELOPMENT, tags: ["*new*", "markup", "editor", ".md"], codepoint: 58632, published_in: 2.1, updated_in: 2.1 }, { name: "marker-circle", pascal_name: "MarkerCircle", categories: [e.DESIGN, e.EDITOR, e.OFFICE], figma_category: a.DESIGN, tags: ["write", "writing", "editing", "drawing"], codepoint: 58944, published_in: 1.2, updated_in: 1.2 }, { name: "martini", pascal_name: "Martini", categories: [e.COMMERCE, e.MAP, e.OBJECTS], figma_category: a.COMMERCE, tags: ["glass", "drinks", "beverages", "cocktails", "places", "locations", "bars", "restaurants", "food", "dining"], codepoint: 58140, published_in: 1, updated_in: 1 }, { name: "mask-happy", pascal_name: "MaskHappy", categories: [e.COMMUNICATION, e.GAMES], figma_category: a.GAMES, tags: ["theater", "costume", "smile", "smiling", "thalia"], codepoint: 59892, published_in: 1.4, updated_in: 1.4 }, { name: "mask-sad", pascal_name: "MaskSad", categories: [e.COMMUNICATION, e.GAMES], figma_category: a.GAMES, tags: ["theater", "costume", "cry", "crying", "melpomene"], codepoint: 60318, published_in: 1.4, updated_in: 1.4 }, { name: "mastodon-logo", pascal_name: "MastodonLogo", categories: [e.BRAND, e.COMMUNICATION], figma_category: a.BRAND, tags: ["*new*", "fediverse", "social media", "decentralized"], codepoint: 60776, published_in: 2.1, updated_in: 2.1 }, { name: "math-operations", pascal_name: "MathOperations", categories: [e.DEVELOPMENT, e.FINANCE], figma_category: a.FINANCE, tags: ["addition", "sum", "subtraction", "difference", "multiply", "multiplication", "product", "divide", "division", "divisor", "dividend", "quotient", "equals", "equality", "mathematics", "arithmetic", "calculator", "+", "-", "\xB1", "\xD7", "\xF7", "="], codepoint: 58142, published_in: 1, updated_in: 1 }, { name: "matrix-logo", pascal_name: "MatrixLogo", categories: [e.BRAND, e.COMMUNICATION], figma_category: a.COMMUNICATION, tags: ["*new*", "matrix protocol", "brands", "logos"], codepoint: 60772, published_in: 2.1, updated_in: 2.1 }, { name: "medal", pascal_name: "Medal", categories: [e.OBJECTS, e.GAMES], figma_category: a.GAMES, tags: ["ribbons", "winning", "victory", "awards", "rosette"], codepoint: 58144, published_in: 1, updated_in: 1 }, { name: "medal-military", pascal_name: "MedalMilitary", categories: [e.OBJECTS, e.GAMES], figma_category: a.GAMES, tags: ["ribbons", "winning", "victory", "awards", "military"], codepoint: 60668, published_in: 2, updated_in: 2 }, { name: "medium-logo", pascal_name: "MediumLogo", categories: [e.BRAND], figma_category: a.BRAND, tags: ["logos", "reading", "writing", "news", "social media"], codepoint: 58146, published_in: 1, updated_in: 1 }, { name: "megaphone", pascal_name: "Megaphone", categories: [e.COMMUNICATION, e.OBJECTS], figma_category: a.COMMUNICATION, tags: ["bullhorn", "announcements", "loudspeaker", "broadcast"], codepoint: 58148, published_in: 1, updated_in: 1 }, { name: "megaphone-simple", pascal_name: "MegaphoneSimple", categories: [e.COMMUNICATION, e.OBJECTS], figma_category: a.COMMUNICATION, tags: ["bullhorn", "announcements", "loudspeaker", "broadcast"], codepoint: 58946, published_in: 1.2, updated_in: 1.2 }, { name: "member-of", pascal_name: "MemberOf", categories: [e.FINANCE, e.DEVELOPMENT], figma_category: a.FINANCE, tags: ["*new*", "\u2208", "is element of", "set", "member", "mathematics", "arithmetic", "calculator"], codepoint: 60866, published_in: 2.1, updated_in: 2.1 }, { name: "memory", pascal_name: "Memory", categories: [e.DEVELOPMENT], figma_category: a.SYSTEM, tags: ["*new*", "ram", "microchip", "computer", "circuit", "electronics"], codepoint: 59844, published_in: 2.1, updated_in: 2.1 }, { name: "messenger-logo", pascal_name: "MessengerLogo", categories: [e.BRAND, e.COMMUNICATION], figma_category: a.BRAND, tags: ["logos", "facebook", "social media"], codepoint: 59096, published_in: 1.3, updated_in: 1.3 }, { name: "meta-logo", pascal_name: "MetaLogo", categories: [e.BRAND], figma_category: a.BRAND, tags: ["*updated*", "facebook", "logos", "social media", "logos"], codepoint: 60674, published_in: 2, updated_in: 2.1 }, { name: "meteor", pascal_name: "Meteor", categories: [e.WEATHER, e.NATURE], figma_category: a.WEATHER, tags: ["*new*", "astronomy", "asteroid", "fireball"], codepoint: 59834, published_in: 2.1, updated_in: 2.1 }, { name: "metronome", pascal_name: "Metronome", categories: [e.OBJECTS, e.MEDIA], figma_category: a.MEDIA, tags: ["music", "beat", "tempo", "bpm"], codepoint: 60558, published_in: 2, updated_in: 2 }, { name: "microphone", pascal_name: "Microphone", categories: [e.COMMUNICATION, e.MEDIA, e.SYSTEM], figma_category: a.MEDIA, tags: ["audio", "recording", "music", "sound", "podcast", "studio"], codepoint: 58150, published_in: 1, updated_in: 1 }, { name: "microphone-slash", pascal_name: "MicrophoneSlash", categories: [e.COMMUNICATION, e.MEDIA, e.SYSTEM], figma_category: a.MEDIA, tags: ["audio", "recording", "music", "sound", "podcast", "studio", "muted", "disabled"], codepoint: 58152, published_in: 1, updated_in: 1 }, { name: "microphone-stage", pascal_name: "MicrophoneStage", categories: [e.COMMUNICATION, e.MEDIA, e.SYSTEM], figma_category: a.MEDIA, tags: ["audio", "recording", "music", "sound", "performance", "concert"], codepoint: 59228, published_in: 1.4, updated_in: 1.4 }, { name: "microscope", pascal_name: "Microscope", categories: [e.NATURE, e.DEVELOPMENT, e.OBJECTS, e.HEALTH], figma_category: a.HEALTH, tags: ["*new*", "science", "biology", "experiment", "magnify"], codepoint: 60538, published_in: 2.1, updated_in: 2.1 }, { name: "microsoft-excel-logo", pascal_name: "MicrosoftExcelLogo", categories: [e.BRAND, e.OFFICE], figma_category: a.BRAND, tags: ["tables", "spreadsheets", "tabular"], codepoint: 60268, published_in: 1.4, updated_in: 1.4 }, { name: "microsoft-outlook-logo", pascal_name: "MicrosoftOutlookLogo", categories: [e.BRAND, e.COMMUNICATION, e.OFFICE], figma_category: a.BRAND, tags: ["email", "logos"], codepoint: 60272, published_in: 2, updated_in: 2 }, { name: "microsoft-powerpoint-logo", pascal_name: "MicrosoftPowerpointLogo", categories: [e.BRAND, e.OFFICE], figma_category: a.BRAND, tags: ["slides", "slideshow", "presentation"], codepoint: 60110, published_in: 1.4, updated_in: 1.4 }, { name: "microsoft-teams-logo", pascal_name: "MicrosoftTeamsLogo", categories: [e.BRAND, e.COMMUNICATION], figma_category: a.BRAND, tags: ["chat", "video conference"], codepoint: 60262, published_in: 1.4, updated_in: 1.4 }, { name: "microsoft-word-logo", pascal_name: "MicrosoftWordLogo", categories: [e.BRAND, e.EDITOR, e.OFFICE], figma_category: a.BRAND, tags: ["documents", "word processor", "doc", "docx"], codepoint: 60266, published_in: 1.4, updated_in: 1.4 }, { name: "minus", pascal_name: "Minus", categories: [e.DEVELOPMENT, e.FINANCE, e.SYSTEM], figma_category: a.FINANCE, tags: ["-", "subtraction", "difference", "mathematics", "arithmetic", "calculator", "line", "horizontal", "divider"], codepoint: 58154, published_in: 1, updated_in: 1 }, { name: "minus-circle", pascal_name: "MinusCircle", categories: [e.DEVELOPMENT, e.FINANCE, e.SYSTEM], figma_category: a.FINANCE, tags: ["-", "subtraction", "difference", "mathematics", "arithmetic", "calculator", "round"], codepoint: 58156, published_in: 1, updated_in: 1 }, { name: "minus-square", pascal_name: "MinusSquare", categories: [e.FINANCE, e.SYSTEM], figma_category: a.FINANCE, tags: ["-", "subtraction", "difference", "mathematics", "arithmetic", "calculator"], codepoint: 60748, published_in: 2, updated_in: 2 }, { name: "money", pascal_name: "Money", categories: [e.COMMERCE, e.FINANCE], figma_category: a.COMMERCE, tags: ["cash", "dollars", "paper bills", "payment", "paying", "purchase"], codepoint: 58760, published_in: 1.1, updated_in: 2 }, { name: "money-wavy", pascal_name: "MoneyWavy", categories: [e.FINANCE, e.COMMERCE], figma_category: a.COMMERCE, tags: ["*new*", "cash", "dollars", "paper bills", "payment", "paying", "purchase"], codepoint: 61032, published_in: 2.1, updated_in: 2.1 }, { name: "monitor", pascal_name: "Monitor", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["screen", "television", "tv", "displays"], codepoint: 58158, published_in: 1, updated_in: 1 }, { name: "monitor-arrow-up", pascal_name: "MonitorArrowUp", categories: [e.SYSTEM, e.MEDIA], figma_category: a.SYSTEM, tags: ["*new*", "screen", "screencast", "screenshare", "upload", "video", "movie"], codepoint: 58762, published_in: 2.1, updated_in: 2.1 }, { name: "monitor-play", pascal_name: "MonitorPlay", categories: [e.SYSTEM, e.MEDIA], figma_category: a.SYSTEM, tags: ["screen", "television", "tv", "displays", "screencast", "video", "movie"], codepoint: 58764, published_in: 1.1, updated_in: 1.1 }, { name: "moon", pascal_name: "Moon", categories: [e.NATURE, e.SYSTEM, e.WEATHER], figma_category: a.WEATHER, tags: ["night", "evening", "clear", "sleep", "snooze", "night mode", "dark mode", "astronomy", "stargazing"], codepoint: 58160, published_in: 1, updated_in: 1 }, { name: "moon-stars", pascal_name: "MoonStars", categories: [e.NATURE, e.WEATHER], figma_category: a.WEATHER, tags: ["night", "evening", "clear", "sleep", "snooze", "night mode", "dark mode", "astronomy", "stargazing", "constellation"], codepoint: 58766, published_in: 1.1, updated_in: 1.1 }, { name: "moped", pascal_name: "Moped", categories: [e.MAP, e.OBJECTS], figma_category: a.MAP, tags: ["scooter", "vehicles", "vespa", "transportation", "travel"], codepoint: 59428, published_in: 2, updated_in: 2 }, { name: "moped-front", pascal_name: "MopedFront", categories: [e.MAP, e.OBJECTS], figma_category: a.MAP, tags: ["scooter", "vehicles", "vespa", "transportation", "travel"], codepoint: 59426, published_in: 2, updated_in: 2 }, { name: "mosque", pascal_name: "Mosque", categories: [e.MAP], figma_category: a.MAP, tags: ["islam", "muslim", "religion", "worship"], codepoint: 60654, published_in: 2, updated_in: 2 }, { name: "motorcycle", pascal_name: "Motorcycle", categories: [e.MAP, e.OBJECTS], figma_category: a.MAP, tags: ["vehicles", "motorbike", "transportation", "travel"], codepoint: 59402, published_in: 2, updated_in: 2 }, { name: "mountains", pascal_name: "Mountains", categories: [e.NATURE, e.MAP], figma_category: a.WEATHER, tags: ["*updated*", "hills", "outdoors", "terrain", "geology", "adventure"], codepoint: 59310, published_in: 1.4, updated_in: 2.1 }, { name: "mouse", pascal_name: "Mouse", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["*updated*", "clicks", "input"], codepoint: 58170, published_in: 1, updated_in: 2.1 }, { name: "mouse-left-click", pascal_name: "MouseLeftClick", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["*new*", "clicks", "input"], codepoint: 58164, published_in: 2.1, updated_in: 2.1 }, { name: "mouse-middle-click", pascal_name: "MouseMiddleClick", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["*new*", "clicks", "input"], codepoint: 58168, published_in: 2.1, updated_in: 2.1 }, { name: "mouse-right-click", pascal_name: "MouseRightClick", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["*new*", "clicks", "input"], codepoint: 58166, published_in: 2.1, updated_in: 2.1 }, { name: "mouse-scroll", pascal_name: "MouseScroll", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["*new*", "clicks", "input"], codepoint: 58162, published_in: 2.1, updated_in: 2.1 }, { name: "mouse-simple", pascal_name: "MouseSimple", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["clicks", "input"], codepoint: 58948, published_in: 1.2, updated_in: 1.2 }, { name: "music-note", pascal_name: "MusicNote", categories: [e.MEDIA], figma_category: a.MEDIA, tags: ["songs", "audio", "playlist", "albums"], codepoint: 58172, published_in: 1, updated_in: 1 }, { name: "music-note-simple", pascal_name: "MusicNoteSimple", categories: [e.MEDIA], figma_category: a.MEDIA, tags: ["songs", "audio", "playlist", "albums"], codepoint: 58174, published_in: 1, updated_in: 1 }, { name: "music-notes", pascal_name: "MusicNotes", categories: [e.MEDIA], figma_category: a.MEDIA, tags: ["songs", "audio", "playlist", "albums"], codepoint: 58176, published_in: 1, updated_in: 1 }, { name: "music-notes-minus", pascal_name: "MusicNotesMinus", categories: [e.MEDIA], figma_category: a.MEDIA, tags: ["*new*", "songs", "audio", "playlist", "albums", "remove", "subtract"], codepoint: 60940, published_in: 2.1, updated_in: 2.1 }, { name: "music-notes-plus", pascal_name: "MusicNotesPlus", categories: [e.MEDIA], figma_category: a.MEDIA, tags: ["songs", "audio", "playlist", "albums", "add"], codepoint: 60284, published_in: 1.4, updated_in: 1.4 }, { name: "music-notes-simple", pascal_name: "MusicNotesSimple", categories: [e.MEDIA], figma_category: a.MEDIA, tags: ["songs", "audio", "playlist", "albums"], codepoint: 58178, published_in: 1, updated_in: 1 }, { name: "navigation-arrow", pascal_name: "NavigationArrow", categories: [e.MAP], figma_category: a.MAP, tags: ["location", "directions", "compass", "gps"], codepoint: 60126, published_in: 1.1, updated_in: 1.1 }, { name: "needle", pascal_name: "Needle", categories: [e.OBJECTS, e.COMMERCE], figma_category: a.COMMERCE, tags: ["sewing", "thread", "awl", "tailor"], codepoint: 59438, published_in: 1.4, updated_in: 1.4 }, { name: "network", pascal_name: "Network", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["*new*", "internet", "ethernet", "lan"], codepoint: 60894, published_in: 2.1, updated_in: 2.1 }, { name: "network-slash", pascal_name: "NetworkSlash", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["*new*", "internet", "ethernet", "lan", "error"], codepoint: 60892, published_in: 2.1, updated_in: 2.1 }, { name: "network-x", pascal_name: "NetworkX", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["*new*", "internet", "ethernet", "lan", "disabled"], codepoint: 60890, published_in: 2.1, updated_in: 2.1 }, { name: "newspaper", pascal_name: "Newspaper", categories: [e.MEDIA, e.OBJECTS], figma_category: a.MEDIA, tags: ["reading", "writing", "journals", "periodicals"], codepoint: 58180, published_in: 1, updated_in: 1 }, { name: "newspaper-clipping", pascal_name: "NewspaperClipping", categories: [e.MEDIA, e.OBJECTS], figma_category: a.MEDIA, tags: ["*updated*", "reading", "writing", "journals", "periodicals"], codepoint: 58182, published_in: 1, updated_in: 2.1 }, { name: "not-equals", pascal_name: "NotEquals", categories: [e.FINANCE, e.DEVELOPMENT], figma_category: a.FINANCE, tags: ["*new*", "\u2260", "equality", "equivalent", "equivalence", "mathematics", "arithmetic", "calculator"], codepoint: 60838, published_in: 2.1, updated_in: 2.1 }, { name: "not-member-of", pascal_name: "NotMemberOf", categories: [e.FINANCE, e.DEVELOPMENT], figma_category: a.FINANCE, tags: ["*new*", "\u2209", "is not element of", "set", "member", "mathematics", "arithmetic", "calculator"], codepoint: 60846, published_in: 2.1, updated_in: 2.1 }, { name: "not-subset-of", pascal_name: "NotSubsetOf", categories: [e.FINANCE, e.DEVELOPMENT], figma_category: a.FINANCE, tags: ["*new*", "\u2284", "not subset of", "set", "member", "mathematics", "arithmetic", "calculator"], codepoint: 60848, published_in: 2.1, updated_in: 2.1 }, { name: "not-superset-of", pascal_name: "NotSupersetOf", categories: [e.FINANCE, e.DEVELOPMENT], figma_category: a.FINANCE, tags: ["*new*", "\u2289", "not superset of", "set", "member", "mathematics", "arithmetic", "calculator"], codepoint: 60850, published_in: 2.1, updated_in: 2.1 }, { name: "notches", pascal_name: "Notches", categories: [e.SYSTEM, e.EDITOR], figma_category: a.DESIGN, tags: ["textarea", "resize", "drag handle", "knurling"], codepoint: 60730, published_in: 2, updated_in: 2 }, { name: "note", pascal_name: "Note", categories: [e.OFFICE, e.EDITOR], figma_category: a.OFFICE, tags: ["notes", "note-taking", "memorandum", "post-it", "reminders"], codepoint: 58184, published_in: 1, updated_in: 1 }, { name: "note-blank", pascal_name: "NoteBlank", categories: [e.OFFICE, e.EDITOR], figma_category: a.OFFICE, tags: ["notes", "note-taking", "memorandum", "post-it", "reminders"], codepoint: 58186, published_in: 1, updated_in: 1 }, { name: "note-pencil", pascal_name: "NotePencil", categories: [e.OFFICE, e.EDITOR], figma_category: a.OFFICE, tags: ["notes", "note-taking", "memorandum", "post-it", "reminders"], codepoint: 58188, published_in: 1, updated_in: 1 }, { name: "notebook", pascal_name: "Notebook", categories: [e.OFFICE, e.EDITOR], figma_category: a.OFFICE, tags: ["notes", "note-taking", "memorandum", "journal", "diary", "logs", "logbook"], codepoint: 58190, published_in: 1, updated_in: 1 }, { name: "notepad", pascal_name: "Notepad", categories: [e.OFFICE, e.EDITOR], figma_category: a.OFFICE, tags: ["*updated*", "logs", "logbook", "notes", "note-taking", "memorandum", "journal", "diary"], codepoint: 58942, published_in: 1.2, updated_in: 2.1 }, { name: "notification", pascal_name: "Notification", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["badge", "pip"], codepoint: 59130, published_in: 1.3, updated_in: 1.3 }, { name: "notion-logo", pascal_name: "NotionLogo", categories: [e.BRAND], figma_category: a.BRAND, tags: ["documentation", "productivity", "wiki", "logos"], codepoint: 59808, published_in: 2, updated_in: 2 }, { name: "nuclear-plant", pascal_name: "NuclearPlant", categories: [e.COMMERCE, e.OBJECTS], figma_category: a.COMMERCE, tags: ["*new*", "renewable", "energy", "power", "electricity"], codepoint: 60796, published_in: 2.1, updated_in: 2.1 }, { name: "number-circle-eight", pascal_name: "NumberCircleEight", categories: [e.FINANCE], figma_category: a.FINANCE, tags: ["8", "round", "numbers", "numerals", "digits", "mathematics", "arithmetic", "calculator"], codepoint: 58194, published_in: 1, updated_in: 1 }, { name: "number-circle-five", pascal_name: "NumberCircleFive", categories: [e.FINANCE], figma_category: a.FINANCE, tags: ["5", "round", "numbers", "numerals", "digits", "mathematics", "arithmetic", "calculator"], codepoint: 58200, published_in: 1, updated_in: 1 }, { name: "number-circle-four", pascal_name: "NumberCircleFour", categories: [e.FINANCE], figma_category: a.FINANCE, tags: ["*updated*", "4", "round", "numbers", "numerals", "digits", "mathematics", "arithmetic", "calculator"], codepoint: 58206, published_in: 1, updated_in: 2.1 }, { name: "number-circle-nine", pascal_name: "NumberCircleNine", categories: [e.FINANCE], figma_category: a.FINANCE, tags: ["9", "round", "numbers", "numerals", "digits", "mathematics", "arithmetic", "calculator"], codepoint: 58212, published_in: 1, updated_in: 1 }, { name: "number-circle-one", pascal_name: "NumberCircleOne", categories: [e.FINANCE], figma_category: a.FINANCE, tags: ["1", "round", "numbers", "numerals", "digits", "mathematics", "arithmetic", "calculator"], codepoint: 58218, published_in: 1, updated_in: 1 }, { name: "number-circle-seven", pascal_name: "NumberCircleSeven", categories: [e.FINANCE], figma_category: a.FINANCE, tags: ["7", "round", "numbers", "numerals", "digits", "mathematics", "arithmetic", "calculator"], codepoint: 58224, published_in: 1, updated_in: 1 }, { name: "number-circle-six", pascal_name: "NumberCircleSix", categories: [e.FINANCE], figma_category: a.FINANCE, tags: ["6", "round", "numbers", "numerals", "digits", "mathematics", "arithmetic", "calculator"], codepoint: 58230, published_in: 1, updated_in: 1 }, { name: "number-circle-three", pascal_name: "NumberCircleThree", categories: [e.FINANCE], figma_category: a.FINANCE, tags: ["3", "round", "numbers", "numerals", "digits", "mathematics", "arithmetic", "calculator"], codepoint: 58236, published_in: 1, updated_in: 1 }, { name: "number-circle-two", pascal_name: "NumberCircleTwo", categories: [e.FINANCE], figma_category: a.FINANCE, tags: ["2", "round", "numbers", "numerals", "digits", "mathematics", "arithmetic", "calculator"], codepoint: 58242, published_in: 1, updated_in: 1 }, { name: "number-circle-zero", pascal_name: "NumberCircleZero", categories: [e.FINANCE], figma_category: a.FINANCE, tags: ["0", "round", "numbers", "numerals", "digits", "mathematics", "arithmetic", "calculator"], codepoint: 58248, published_in: 1, updated_in: 1 }, { name: "number-eight", pascal_name: "NumberEight", categories: [e.FINANCE], figma_category: a.FINANCE, tags: ["8", "numbers", "numerals", "digits", "mathematics", "arithmetic", "calculator"], codepoint: 58192, published_in: 1, updated_in: 1 }, { name: "number-five", pascal_name: "NumberFive", categories: [e.FINANCE], figma_category: a.FINANCE, tags: ["5", "numbers", "numerals", "digits", "mathematics", "arithmetic", "calculator"], codepoint: 58198, published_in: 1, updated_in: 1 }, { name: "number-four", pascal_name: "NumberFour", categories: [e.FINANCE], figma_category: a.FINANCE, tags: ["*updated*", "4", "numbers", "numerals", "digits", "mathematics", "arithmetic", "calculator"], codepoint: 58204, published_in: 1, updated_in: 2.1 }, { name: "number-nine", pascal_name: "NumberNine", categories: [e.FINANCE], figma_category: a.FINANCE, tags: ["9", "numbers", "numerals", "digits", "mathematics", "arithmetic", "calculator"], codepoint: 58210, published_in: 1, updated_in: 1 }, { name: "number-one", pascal_name: "NumberOne", categories: [e.FINANCE], figma_category: a.FINANCE, tags: ["1", "numbers", "numerals", "digits", "mathematics", "arithmetic", "calculator"], codepoint: 58216, published_in: 1, updated_in: 1 }, { name: "number-seven", pascal_name: "NumberSeven", categories: [e.FINANCE], figma_category: a.FINANCE, tags: ["7", "numbers", "numerals", "digits", "mathematics", "arithmetic", "calculator"], codepoint: 58222, published_in: 1, updated_in: 1 }, { name: "number-six", pascal_name: "NumberSix", categories: [e.FINANCE], figma_category: a.FINANCE, tags: ["6", "numbers", "numerals", "digits", "mathematics", "arithmetic", "calculator"], codepoint: 58228, published_in: 1, updated_in: 1 }, { name: "number-square-eight", pascal_name: "NumberSquareEight", categories: [e.FINANCE], figma_category: a.FINANCE, tags: ["8", "numbers", "numerals", "digits", "mathematics", "arithmetic", "calculator"], codepoint: 58196, published_in: 1, updated_in: 1 }, { name: "number-square-five", pascal_name: "NumberSquareFive", categories: [e.FINANCE], figma_category: a.FINANCE, tags: ["5", "numbers", "numerals", "digits", "mathematics", "arithmetic", "calculator"], codepoint: 58202, published_in: 1, updated_in: 1 }, { name: "number-square-four", pascal_name: "NumberSquareFour", categories: [e.FINANCE], figma_category: a.FINANCE, tags: ["*updated*", "4", "numbers", "numerals", "digits", "mathematics", "arithmetic", "calculator"], codepoint: 58208, published_in: 1, updated_in: 2.1 }, { name: "number-square-nine", pascal_name: "NumberSquareNine", categories: [e.FINANCE], figma_category: a.FINANCE, tags: ["9", "numbers", "numerals", "digits", "mathematics", "arithmetic", "calculator"], codepoint: 58214, published_in: 1, updated_in: 1 }, { name: "number-square-one", pascal_name: "NumberSquareOne", categories: [e.FINANCE], figma_category: a.FINANCE, tags: ["1", "numbers", "numerals", "digits", "mathematics", "arithmetic", "calculator"], codepoint: 58220, published_in: 1, updated_in: 1 }, { name: "number-square-seven", pascal_name: "NumberSquareSeven", categories: [e.FINANCE], figma_category: a.FINANCE, tags: ["7", "numbers", "numerals", "digits", "mathematics", "arithmetic", "calculator"], codepoint: 58226, published_in: 1, updated_in: 1 }, { name: "number-square-six", pascal_name: "NumberSquareSix", categories: [e.FINANCE], figma_category: a.FINANCE, tags: ["6", "numbers", "numerals", "digits", "mathematics", "arithmetic", "calculator"], codepoint: 58232, published_in: 1, updated_in: 1 }, { name: "number-square-three", pascal_name: "NumberSquareThree", categories: [e.FINANCE], figma_category: a.FINANCE, tags: ["3", "numbers", "numerals", "digits", "mathematics", "arithmetic", "calculator"], codepoint: 58238, published_in: 1, updated_in: 1 }, { name: "number-square-two", pascal_name: "NumberSquareTwo", categories: [e.FINANCE], figma_category: a.FINANCE, tags: ["2", "numbers", "numerals", "digits", "mathematics", "arithmetic", "calculator"], codepoint: 58244, published_in: 1, updated_in: 1 }, { name: "number-square-zero", pascal_name: "NumberSquareZero", categories: [e.FINANCE], figma_category: a.FINANCE, tags: ["0", "numbers", "numerals", "digits", "mathematics", "arithmetic", "calculator"], codepoint: 58250, published_in: 1, updated_in: 1 }, { name: "number-three", pascal_name: "NumberThree", categories: [e.FINANCE], figma_category: a.FINANCE, tags: ["3", "numbers", "numerals", "digits", "mathematics", "arithmetic", "calculator"], codepoint: 58234, published_in: 1, updated_in: 1 }, { name: "number-two", pascal_name: "NumberTwo", categories: [e.FINANCE], figma_category: a.FINANCE, tags: ["2", "numbers", "numerals", "digits", "mathematics", "arithmetic", "calculator"], codepoint: 58240, published_in: 1, updated_in: 1 }, { name: "number-zero", pascal_name: "NumberZero", categories: [e.FINANCE], figma_category: a.FINANCE, tags: ["0", "numbers", "numerals", "digits", "mathematics", "arithmetic", "calculator"], codepoint: 58246, published_in: 1, updated_in: 1 }, { name: "numpad", pascal_name: "Numpad", categories: [e.COMMUNICATION, e.SYSTEM], figma_category: a.COMMUNICATION, tags: ["*new*", "dialer", "dialpad", "call-center", "telephone", "landline", "password", "passcode"], codepoint: 58312, published_in: 2.1, updated_in: 2.1 }, { name: "nut", pascal_name: "Nut", categories: [e.OBJECTS, e.SYSTEM], figma_category: a.SYSTEM, tags: ["bolts", "screws", "machinery", "tools", "hexagon"], codepoint: 58252, published_in: 1, updated_in: 1 }, { name: "ny-times-logo", pascal_name: "NyTimesLogo", categories: [e.BRAND], figma_category: a.BRAND, tags: ["nyt", "new york times", "logos", "reading", "writing", "news", "newspaper"], codepoint: 58950, published_in: 1.2, updated_in: 1.2 }, { name: "octagon", pascal_name: "Octagon", categories: [e.DESIGN], figma_category: a.DESIGN, tags: ["8", "shapes", "polygons"], codepoint: 58254, published_in: 1, updated_in: 1 }, { name: "office-chair", pascal_name: "OfficeChair", categories: [e.OBJECTS, e.COMMERCE], figma_category: a.COMMERCE, tags: ["furniture", "seat"], codepoint: 59974, published_in: 2, updated_in: 2 }, { name: "onigiri", pascal_name: "Onigiri", categories: [e.COMMERCE, e.MAP], figma_category: a.COMMERCE, tags: ["*new*", "rice ball", "japanese", "food", "restaurant"], codepoint: 60972, published_in: 2.1, updated_in: 2.1 }, { name: "open-ai-logo", pascal_name: "OpenAiLogo", categories: [e.DEVELOPMENT, e.BRAND], figma_category: a.BRAND, tags: ["*new*", "artificial intelligence", "ai", "chatgpt", "llm", "logos"], codepoint: 59346, published_in: 2.1, updated_in: 2.1 }, { name: "option", pascal_name: "Option", categories: [e.SYSTEM, e.EDITOR], figma_category: a.SYSTEM, tags: ["keyboard", "shortcut", "modifier"], codepoint: 59560, published_in: 1.4, updated_in: 1.4 }, { name: "orange", pascal_name: "Orange", categories: [e.COMMERCE, e.NATURE], figma_category: a.COMMERCE, tags: ["*new*", "food", "fruit", "juice", "citrus", "groceries", "market"], codepoint: 60992, published_in: 2.1, updated_in: 2.1 }, { name: "orange-slice", pascal_name: "OrangeSlice", categories: [e.MAP, e.COMMERCE, e.NATURE], figma_category: a.COMMERCE, tags: ["food", "fruit", "juice", "citrus", "groceries", "market"], codepoint: 60726, published_in: 2, updated_in: 2 }, { name: "oven", pascal_name: "Oven", categories: [e.COMMERCE, e.OBJECTS], figma_category: a.COMMERCE, tags: ["*new*", "stove", "stovetop", "food", "cooking", "cuisine", "kitchen"], codepoint: 60812, published_in: 2.1, updated_in: 2.1 }, { name: "package", pascal_name: "Package", categories: [e.DEVELOPMENT, e.OBJECTS], figma_category: a.COMMERCE, tags: ["packages", "boxes", "delivery", "mail", "postal service", "bundles", "library", "libraries", "shipping"], codepoint: 58256, published_in: 1, updated_in: 1 }, { name: "paint-brush", pascal_name: "PaintBrush", categories: [e.DESIGN, e.EDITOR, e.OBJECTS], figma_category: a.DESIGN, tags: ["colors", "color picker", "arts"], codepoint: 59120, published_in: 1.3, updated_in: 1.3 }, { name: "paint-brush-broad", pascal_name: "PaintBrushBroad", categories: [e.DESIGN, e.EDITOR, e.OBJECTS], figma_category: a.DESIGN, tags: ["fill", "colors", "color picker", "arts"], codepoint: 58768, published_in: 1.1, updated_in: 1.1 }, { name: "paint-brush-household", pascal_name: "PaintBrushHousehold", categories: [e.DESIGN, e.EDITOR, e.OBJECTS], figma_category: a.DESIGN, tags: ["colors", "color picker", "arts"], codepoint: 59122, published_in: 1.3, updated_in: 1.3 }, { name: "paint-bucket", pascal_name: "PaintBucket", categories: [e.DESIGN, e.EDITOR, e.OBJECTS], figma_category: a.DESIGN, tags: ["*updated*", "paintbucket", "colors", "color picker", "fill", "arts"], codepoint: 58258, published_in: 1, updated_in: 2.1 }, { name: "paint-roller", pascal_name: "PaintRoller", categories: [e.DESIGN, e.EDITOR, e.OBJECTS], figma_category: a.DESIGN, tags: ["colors", "color picker", "fill", "arts", "theme"], codepoint: 59124, published_in: 1.3, updated_in: 1.3 }, { name: "palette", pascal_name: "Palette", categories: [e.DESIGN, e.EDITOR, e.OBJECTS], figma_category: a.DESIGN, tags: ["paint", "colors", "color picker", "arts"], codepoint: 59080, published_in: 1.3, updated_in: 1.3 }, { name: "panorama", pascal_name: "Panorama", categories: [e.MEDIA], figma_category: a.MEDIA, tags: ["*new*", "image", "picture", "photography", "landscape", "360"], codepoint: 60066, published_in: 2.1, updated_in: 2.1 }, { name: "pants", pascal_name: "Pants", categories: [e.COMMERCE, e.OBJECTS], figma_category: a.COMMERCE, tags: ["clothing", "clothes", "jeans"], codepoint: 60552, published_in: 2, updated_in: 2 }, { name: "paper-plane", pascal_name: "PaperPlane", categories: [e.COMMUNICATION, e.MAP, e.OBJECTS], figma_category: a.COMMUNICATION, tags: ["mail", "email", "send", "sent", "messages", "messaging", "toys", "games"], codepoint: 58260, published_in: 1, updated_in: 1.4 }, { name: "paper-plane-right", pascal_name: "PaperPlaneRight", categories: [e.COMMUNICATION, e.MAP, e.OBJECTS], figma_category: a.COMMUNICATION, tags: ["mail", "email", "send", "sent", "messages", "messaging", "toys", "games"], codepoint: 58262, published_in: 1, updated_in: 1.4 }, { name: "paper-plane-tilt", pascal_name: "PaperPlaneTilt", categories: [e.COMMUNICATION, e.MAP, e.OBJECTS], figma_category: a.COMMUNICATION, tags: ["mail", "email", "send", "sent", "messages", "messaging", "toys", "games"], codepoint: 58264, published_in: 1, updated_in: 1.4 }, { name: "paperclip", pascal_name: "Paperclip", categories: [e.COMMUNICATION, e.EDITOR, e.OFFICE, e.OBJECTS], figma_category: a.OFFICE, tags: ["attachments", "mail", "email", "office"], codepoint: 58266, published_in: 1, updated_in: 1 }, { name: "paperclip-horizontal", pascal_name: "PaperclipHorizontal", categories: [e.COMMUNICATION, e.EDITOR, e.OFFICE, e.OBJECTS], figma_category: a.OFFICE, tags: ["attachments", "mail", "email", "office"], codepoint: 58770, published_in: 1.1, updated_in: 1.1 }, { name: "parachute", pascal_name: "Parachute", categories: [e.OBJECTS, e.DEVELOPMENT], figma_category: a.GAMES, tags: ["skydiving", "safety"], codepoint: 60028, published_in: 1.4, updated_in: 1.4 }, { name: "paragraph", pascal_name: "Paragraph", categories: [e.EDITOR], figma_category: a.OFFICE, tags: ["pilcrow"], codepoint: 59744, published_in: 2, updated_in: 2 }, { name: "parallelogram", pascal_name: "Parallelogram", categories: [e.BRAND, e.MEDIA, e.DESIGN], figma_category: a.DESIGN, tags: ["shapes", "bandcamp", "logos"], codepoint: 60614, published_in: 2, updated_in: 2 }, { name: "park", pascal_name: "Park", categories: [e.MAP, e.NATURE], figma_category: a.MAP, tags: ["bench", "outdoors"], codepoint: 60594, published_in: 2, updated_in: 2 }, { name: "password", pascal_name: "Password", categories: [e.SYSTEM], figma_category: a.SECURITY, tags: ["security", "secured", "authentication", "authenticated", "login", "locked", "encrypted", "encryption"], codepoint: 59218, published_in: 1.4, updated_in: 1.4 }, { name: "path", pascal_name: "Path", categories: [e.DESIGN, e.MAP], figma_category: a.MAP, tags: ["transit", "travel", "trail", "gps", "navigation", "route", "destination", "vector"], codepoint: 58268, published_in: 1, updated_in: 1 }, { name: "patreon-logo", pascal_name: "PatreonLogo", categories: [e.BRAND], figma_category: a.BRAND, tags: ["*updated*", "crowdfunding", "logos"], codepoint: 59786, published_in: 2, updated_in: 2.1 }, { name: "pause", pascal_name: "Pause", categories: [e.MEDIA, e.SYSTEM], figma_category: a.MEDIA, tags: ["music", "audio", "resume", "start", "stop"], codepoint: 58270, published_in: 1, updated_in: 1 }, { name: "pause-circle", pascal_name: "PauseCircle", categories: [e.MEDIA, e.SYSTEM], figma_category: a.MEDIA, tags: ["music", "audio", "resume", "start", "stop", "round"], codepoint: 58272, published_in: 1, updated_in: 1 }, { name: "paw-print", pascal_name: "PawPrint", categories: [e.NATURE, e.COMMERCE, e.HEALTH], figma_category: a.WEATHER, tags: ["pets", "pet store", "pet shop", "animals", "cat", "dog", "veterinarian"], codepoint: 58952, published_in: 1.2, updated_in: 1.2 }, { name: "paypal-logo", pascal_name: "PaypalLogo", categories: [e.BRAND, e.FINANCE, e.COMMERCE], figma_category: a.BRAND, tags: ["payments", "paying", "purchase", "logos"], codepoint: 59788, published_in: 2, updated_in: 2 }, { name: "peace", pascal_name: "Peace", categories: [e.COMMUNICATION], figma_category: a.COMMUNICATION, tags: ["love", "hippies", "peace sign", "symbols"], codepoint: 58274, published_in: 1, updated_in: 1 }, { name: "pen", pascal_name: "Pen", categories: [e.DESIGN, e.EDITOR, e.OFFICE], figma_category: a.DESIGN, tags: ["ink", "write", "writing", "editing", "sign", "signature"], codepoint: 58282, published_in: 1, updated_in: 1 }, { name: "pen-nib", pascal_name: "PenNib", categories: [e.DESIGN, e.EDITOR, e.OFFICE], figma_category: a.DESIGN, tags: ["ink", "write", "writing", "editing", "sign", "signature", "fountain pen", "illustrator"], codepoint: 58284, published_in: 1, updated_in: 1 }, { name: "pen-nib-straight", pascal_name: "PenNibStraight", categories: [e.DESIGN, e.EDITOR, e.OFFICE], figma_category: a.DESIGN, tags: ["ink", "write", "writing", "editing", "sign", "signature", "fountain pen", "illustrator"], codepoint: 58954, published_in: 1.2, updated_in: 1.2 }, { name: "pencil", pascal_name: "Pencil", categories: [e.DESIGN, e.EDITOR, e.OFFICE], figma_category: a.DESIGN, tags: ["write", "writing", "editing", "sign", "signature"], codepoint: 58286, published_in: 1, updated_in: 1.4 }, { name: "pencil-circle", pascal_name: "PencilCircle", categories: [e.DESIGN, e.EDITOR, e.OFFICE], figma_category: a.DESIGN, tags: ["write", "writing", "editing", "sign", "signature"], codepoint: 58288, published_in: 1, updated_in: 1.4 }, { name: "pencil-line", pascal_name: "PencilLine", categories: [e.DESIGN, e.EDITOR, e.OFFICE], figma_category: a.DESIGN, tags: ["write", "writing", "editing", "sign", "signature"], codepoint: 58290, published_in: 1, updated_in: 1.4 }, { name: "pencil-ruler", pascal_name: "PencilRuler", categories: [e.DESIGN, e.EDITOR, e.OFFICE], figma_category: a.DESIGN, tags: ["*new*", "drawing", "drafting", "construction", "tools"], codepoint: 59654, published_in: 2.1, updated_in: 2.1 }, { name: "pencil-simple", pascal_name: "PencilSimple", categories: [e.DESIGN, e.EDITOR, e.OFFICE], figma_category: a.DESIGN, tags: ["write", "writing", "editing", "sign", "signature"], codepoint: 58292, published_in: 1, updated_in: 1 }, { name: "pencil-simple-line", pascal_name: "PencilSimpleLine", categories: [e.DESIGN, e.EDITOR, e.OFFICE], figma_category: a.DESIGN, tags: ["write", "writing", "editing", "sign", "signature"], codepoint: 60358, published_in: 1.4, updated_in: 1.4 }, { name: "pencil-simple-slash", pascal_name: "PencilSimpleSlash", categories: [e.DESIGN, e.EDITOR, e.OFFICE], figma_category: a.DESIGN, tags: ["read-only", "write", "writing", "editing"], codepoint: 60662, published_in: 2, updated_in: 2 }, { name: "pencil-slash", pascal_name: "PencilSlash", categories: [e.DESIGN, e.EDITOR, e.OFFICE], figma_category: a.DESIGN, tags: ["read-only", "write", "writing", "editing"], codepoint: 60664, published_in: 2, updated_in: 2 }, { name: "pentagon", pascal_name: "Pentagon", categories: [e.DESIGN], figma_category: a.DESIGN, tags: ["*new*", "shapes", "polygons", "5"], codepoint: 60542, published_in: 2.1, updated_in: 2.1 }, { name: "pentagram", pascal_name: "Pentagram", categories: [e.GAMES, e.DESIGN], figma_category: a.DESIGN, tags: ["star", "wicca", "satan", "satanism", "religion", "spirituality", "evil", "magic"], codepoint: 60508, published_in: 2, updated_in: 2 }, { name: "pepper", pascal_name: "Pepper", categories: [e.COMMERCE, e.NATURE], figma_category: a.COMMERCE, tags: ["food", "spicy", "chile", "vegetable"], codepoint: 59722, published_in: 2, updated_in: 2 }, { name: "percent", pascal_name: "Percent", categories: [e.DEVELOPMENT, e.FINANCE], figma_category: a.FINANCE, tags: ["%", "percentage", "percentile", "ratio", "delta", "mathematics", "arithmetic", "calculator"], codepoint: 58294, published_in: 1, updated_in: 1 }, { name: "person", pascal_name: "Person", categories: [e.MAP, e.PEOPLE], figma_category: a.PEOPLE, tags: ["walking", "human", "woman", "man", "body", "transit", "transportation", "travel", "commuter", "user"], codepoint: 58280, published_in: 1, updated_in: 1 }, { name: "person-arms-spread", pascal_name: "PersonArmsSpread", categories: [e.HEALTH, e.MAP, e.PEOPLE], figma_category: a.PEOPLE, tags: ["accessibility", "vitruvian", "stretch", "sports"], codepoint: 60670, published_in: 2, updated_in: 2 }, { name: "person-simple", pascal_name: "PersonSimple", categories: [e.MAP, e.PEOPLE, e.HEALTH], figma_category: a.PEOPLE, tags: ["pedestrian", "walking", "human", "woman", "man", "body", "transit", "transportation", "travel", "commuter", "user", "exercise"], codepoint: 59182, published_in: 1.3, updated_in: 1.3 }, { name: "person-simple-bike", pascal_name: "PersonSimpleBike", categories: [e.MAP, e.PEOPLE, e.HEALTH], figma_category: a.PEOPLE, tags: ["pedestrian", "biking", "bicycle", "human", "woman", "man", "body", "sports", "exercise"], codepoint: 59188, published_in: 2, updated_in: 2 }, { name: "person-simple-circle", pascal_name: "PersonSimpleCircle", categories: [e.PEOPLE], figma_category: a.PEOPLE, tags: ["*new*", "human", "accessibility", "a11y", "vitruvius", "vitruvian"], codepoint: 61016, published_in: 2.1, updated_in: 2.1 }, { name: "person-simple-hike", pascal_name: "PersonSimpleHike", categories: [e.NATURE, e.HEALTH, e.MAP, e.PEOPLE], figma_category: a.PEOPLE, tags: ["*new*", "pedestrian", "climbing", "mountaineering", "bouldering"], codepoint: 60756, published_in: 2.1, updated_in: 2.1 }, { name: "person-simple-run", pascal_name: "PersonSimpleRun", categories: [e.MAP, e.PEOPLE, e.HEALTH], figma_category: a.PEOPLE, tags: ["pedestrian", "running", "human", "woman", "man", "body", "transit", "transportation", "travel", "commuter", "user", "exercise"], codepoint: 59184, published_in: 1.3, updated_in: 1.3 }, { name: "person-simple-ski", pascal_name: "PersonSimpleSki", categories: [e.GAMES, e.HEALTH], figma_category: a.GAMES, tags: ["*new*", "sports", "skiing", "winter", "mountain"], codepoint: 59164, published_in: 2.1, updated_in: 2.1 }, { name: "person-simple-snowboard", pascal_name: "PersonSimpleSnowboard", categories: [e.GAMES, e.HEALTH], figma_category: a.GAMES, tags: ["*new*", "sports", "snowboarding", "winter", "mountain"], codepoint: 59166, published_in: 2.1, updated_in: 2.1 }, { name: "person-simple-swim", pascal_name: "PersonSimpleSwim", categories: [e.MAP, e.PEOPLE, e.HEALTH], figma_category: a.PEOPLE, tags: ["*new*", "pedestrian", "swimming", "human", "woman", "man", "body", "sports", "exercise"], codepoint: 59190, published_in: 2.1, updated_in: 2.1 }, { name: "person-simple-tai-chi", pascal_name: "PersonSimpleTaiChi", categories: [e.HEALTH, e.MAP, e.PEOPLE], figma_category: a.PEOPLE, tags: ["*new*", "mindfulness", "martial arts", "meditation", "sports", "exercise", "yoga"], codepoint: 60764, published_in: 2.1, updated_in: 2.1 }, { name: "person-simple-throw", pascal_name: "PersonSimpleThrow", categories: [e.MAP, e.PEOPLE, e.HEALTH], figma_category: a.PEOPLE, tags: ["pedestrian", "tennis", "human", "woman", "man", "body", "sports", "exercise"], codepoint: 59186, published_in: 2, updated_in: 2 }, { name: "person-simple-walk", pascal_name: "PersonSimpleWalk", categories: [e.MAP, e.PEOPLE, e.HEALTH], figma_category: a.PEOPLE, tags: ["pedestrian", "walking", "human", "woman", "man", "body", "transit", "transportation", "travel", "commuter", "user", "exercise"], codepoint: 59194, published_in: 1.3, updated_in: 1.3 }, { name: "perspective", pascal_name: "Perspective", categories: [e.DESIGN, e.EDITOR], figma_category: a.DESIGN, tags: ["3d", "skew", "warp", "trapezoid"], codepoint: 60390, published_in: 1.4, updated_in: 1.4 }, { name: "phone", pascal_name: "Phone", categories: [e.COMMUNICATION, e.SYSTEM], figma_category: a.COMMUNICATION, tags: ["calls", "telephone", "landline", "talk"], codepoint: 58296, published_in: 1, updated_in: 1 }, { name: "phone-call", pascal_name: "PhoneCall", categories: [e.COMMUNICATION, e.SYSTEM], figma_category: a.COMMUNICATION, tags: ["calls", "calling", "ringing", "telephone", "landline", "talk"], codepoint: 58298, published_in: 1, updated_in: 1 }, { name: "phone-disconnect", pascal_name: "PhoneDisconnect", categories: [e.COMMUNICATION, e.SYSTEM], figma_category: a.COMMUNICATION, tags: ["calls", "hang up", "disconnected", "telephone", "landline", "talk"], codepoint: 58300, published_in: 1, updated_in: 1 }, { name: "phone-incoming", pascal_name: "PhoneIncoming", categories: [e.COMMUNICATION, e.SYSTEM], figma_category: a.COMMUNICATION, tags: ["calls", "calling", "telephone", "landline", "talk"], codepoint: 58302, published_in: 1, updated_in: 1 }, { name: "phone-list", pascal_name: "PhoneList", categories: [e.COMMUNICATION, e.SYSTEM], figma_category: a.COMMUNICATION, tags: ["*new*", "calls", "call-center", "telephone", "landline", "talk"], codepoint: 58316, published_in: 2.1, updated_in: 2.1 }, { name: "phone-outgoing", pascal_name: "PhoneOutgoing", categories: [e.COMMUNICATION, e.SYSTEM], figma_category: a.COMMUNICATION, tags: ["calls", "calling", "telephone", "landline", "talk"], codepoint: 58304, published_in: 1, updated_in: 1 }, { name: "phone-pause", pascal_name: "PhonePause", categories: [e.COMMUNICATION, e.SYSTEM], figma_category: a.COMMUNICATION, tags: ["*new*", "calls", "hold", "call-center", "telephone", "landline", "talk"], codepoint: 58314, published_in: 2.1, updated_in: 2.1 }, { name: "phone-plus", pascal_name: "PhonePlus", categories: [e.COMMUNICATION, e.SYSTEM], figma_category: a.COMMUNICATION, tags: ["calls", "telephone", "landline", "talk", "conference", "add"], codepoint: 60502, published_in: 2, updated_in: 2 }, { name: "phone-slash", pascal_name: "PhoneSlash", categories: [e.COMMUNICATION, e.SYSTEM], figma_category: a.COMMUNICATION, tags: ["calls", "disabled", "disconnected", "telephone", "landline", "talk"], codepoint: 58306, published_in: 1, updated_in: 1 }, { name: "phone-transfer", pascal_name: "PhoneTransfer", categories: [e.COMMUNICATION, e.SYSTEM], figma_category: a.COMMUNICATION, tags: ["*new*", "calls", "call-center", "telephone", "landline", "talk"], codepoint: 58310, published_in: 2.1, updated_in: 2.1 }, { name: "phone-x", pascal_name: "PhoneX", categories: [e.COMMUNICATION, e.SYSTEM], figma_category: a.COMMUNICATION, tags: ["calls", "missed", "errors", "telephone", "landline", "talk"], codepoint: 58308, published_in: 1, updated_in: 1 }, { name: "phosphor-logo", pascal_name: "PhosphorLogo", categories: [e.BRAND], figma_category: a.BRAND, tags: ["logos"], codepoint: 58318, published_in: 1, updated_in: 1 }, { name: "pi", pascal_name: "Pi", categories: [e.FINANCE, e.DEVELOPMENT], figma_category: a.FINANCE, tags: ["\u03C0", "symbol", "mathematics", "circle"], codepoint: 60544, published_in: 2, updated_in: 2 }, { name: "piano-keys", pascal_name: "PianoKeys", categories: [e.MEDIA, e.OBJECTS], figma_category: a.MEDIA, tags: ["music", "instrument", "keyboard"], codepoint: 59848, published_in: 1.4, updated_in: 1.4 }, { name: "picnic-table", pascal_name: "PicnicTable", categories: [e.MAP, e.NATURE], figma_category: a.COMMERCE, tags: ["*new*", "bench", "park", "outdoors"], codepoint: 60966, published_in: 2.1, updated_in: 2.1 }, { name: "picture-in-picture", pascal_name: "PictureInPicture", categories: [e.MEDIA, e.SYSTEM], figma_category: a.MEDIA, tags: ["pip", "pop-out", "minimize", "maximize"], codepoint: 58956, published_in: 1.2, updated_in: 1.2 }, { name: "piggy-bank", pascal_name: "PiggyBank", categories: [e.FINANCE, e.OBJECTS], figma_category: a.COMMERCE, tags: ["savings", "deposit", "money", "coins"], codepoint: 59908, published_in: 2, updated_in: 2 }, { name: "pill", pascal_name: "Pill", categories: [e.HEALTH], figma_category: a.HEALTH, tags: ["capsule", "medicine", "rx", "pharmacy", "pharmacist", "pharmaceuticals", "prescription", "drugs"], codepoint: 59136, published_in: 1.3, updated_in: 1.3 }, { name: "ping-pong", pascal_name: "PingPong", categories: [e.GAMES, e.HEALTH, e.OBJECTS], figma_category: a.GAMES, tags: ["*new*", "sports", "paddle"], codepoint: 59970, published_in: 2.1, updated_in: 2.1 }, { name: "pint-glass", pascal_name: "PintGlass", categories: [e.COMMERCE, e.HEALTH, e.OBJECTS], figma_category: a.COMMERCE, tags: ["*new*", "water", "beverage", "drinks", "beverages", "food", "dining"], codepoint: 60880, published_in: 2.1, updated_in: 2.1 }, { name: "pinterest-logo", pascal_name: "PinterestLogo", categories: [e.BRAND, e.COMMUNICATION], figma_category: a.BRAND, tags: ["logos", "vision board", "mood board", "social media"], codepoint: 58958, published_in: 1.2, updated_in: 1.4 }, { name: "pinwheel", pascal_name: "Pinwheel", categories: [e.GAMES, e.OBJECTS], figma_category: a.GAMES, tags: ["toys", "whirligig"], codepoint: 60316, published_in: 1.4, updated_in: 1.4 }, { name: "pipe", pascal_name: "Pipe", categories: [e.COMMERCE, e.OBJECTS], figma_category: a.COMMERCE, tags: ["*new*", "tube", "plumber", "plumbing", "construction"], codepoint: 60806, published_in: 2.1, updated_in: 2.1 }, { name: "pipe-wrench", pascal_name: "PipeWrench", categories: [e.COMMERCE, e.OBJECTS], figma_category: a.COMMERCE, tags: ["*new*", "plumber", "plumbing", "tools", "construction"], codepoint: 60808, published_in: 2.1, updated_in: 2.1 }, { name: "pix-logo", pascal_name: "PixLogo", categories: [e.COMMERCE, e.FINANCE], figma_category: a.COMMERCE, tags: ["*new*", "payments", "paying", "purchase", "logos"], codepoint: 60610, published_in: 2.1, updated_in: 2.1 }, { name: "pizza", pascal_name: "Pizza", categories: [e.COMMERCE, e.MAP], figma_category: a.COMMERCE, tags: ["fast food", "party", "places", "locations", "restaurants", "food", "dining"], codepoint: 59286, published_in: 1.3, updated_in: 1.3 }, { name: "placeholder", pascal_name: "Placeholder", categories: [e.DESIGN, e.EDITOR], figma_category: a.DESIGN, tags: ["empty", "notdef", "tofu", "rectangle slash", "missing"], codepoint: 58960, published_in: 1.2, updated_in: 1.2 }, { name: "planet", pascal_name: "Planet", categories: [e.NATURE], figma_category: a.WEATHER, tags: ["saturn", "world", "globe", "astronomy", "space"], codepoint: 58962, published_in: 1.2, updated_in: 1.2 }, { name: "plant", pascal_name: "Plant", categories: [e.COMMERCE, e.NATURE], figma_category: a.WEATHER, tags: ["sprout", "vegan", "farm", "farming", "garden", "gardening"], codepoint: 60334, published_in: 2, updated_in: 2 }, { name: "play", pascal_name: "Play", categories: [e.MEDIA, e.SYSTEM], figma_category: a.MEDIA, tags: ["music", "audio", "resume", "start"], codepoint: 58320, published_in: 1, updated_in: 1 }, { name: "play-circle", pascal_name: "PlayCircle", categories: [e.MEDIA, e.SYSTEM], figma_category: a.MEDIA, tags: ["music", "audio", "resume", "start", "round"], codepoint: 58322, published_in: 1, updated_in: 1 }, { name: "play-pause", pascal_name: "PlayPause", categories: [e.MEDIA, e.SYSTEM], figma_category: a.MEDIA, tags: ["music", "audio", "resume", "start", "stop"], codepoint: 59582, published_in: 2, updated_in: 2 }, { name: "playlist", pascal_name: "Playlist", categories: [e.MEDIA, e.SYSTEM], figma_category: a.MEDIA, tags: ["*updated*", "music", "audio", "queue"], codepoint: 59050, published_in: 1.3, updated_in: 2.1 }, { name: "plug", pascal_name: "Plug", categories: [e.SYSTEM, e.OBJECTS], figma_category: a.SYSTEM, tags: ["outlet", "socket", "plugin", "integration"], codepoint: 59718, published_in: 1.4, updated_in: 1.4 }, { name: "plug-charging", pascal_name: "PlugCharging", categories: [e.SYSTEM, e.OBJECTS], figma_category: a.SYSTEM, tags: ["outlet", "socket", "plugin", "integration", "charge", "charging"], codepoint: 60252, published_in: 2, updated_in: 2 }, { name: "plugs", pascal_name: "Plugs", categories: [e.SYSTEM, e.OBJECTS], figma_category: a.SYSTEM, tags: ["outlet", "socket", "plugin", "integration", "disconnected"], codepoint: 60246, published_in: 1.4, updated_in: 1.4 }, { name: "plugs-connected", pascal_name: "PlugsConnected", categories: [e.SYSTEM, e.OBJECTS], figma_category: a.SYSTEM, tags: ["*updated*", "outlet", "socket", "plugin", "integration"], codepoint: 60250, published_in: 1.4, updated_in: 2.1 }, { name: "plus", pascal_name: "Plus", categories: [e.DEVELOPMENT, e.FINANCE, e.SYSTEM], figma_category: a.FINANCE, tags: ["addition", "sum", "mathematics", "arithmetic", "calculator", "+"], codepoint: 58324, published_in: 1, updated_in: 1 }, { name: "plus-circle", pascal_name: "PlusCircle", categories: [e.DEVELOPMENT, e.FINANCE, e.SYSTEM], figma_category: a.FINANCE, tags: ["addition", "sum", "mathematics", "arithmetic", "calculator", "round", "+"], codepoint: 58326, published_in: 1, updated_in: 1 }, { name: "plus-minus", pascal_name: "PlusMinus", categories: [e.DEVELOPMENT, e.FINANCE], figma_category: a.FINANCE, tags: ["plus or minus", "plus/minus", "add/subtract", "addition", "sum", "subtraction", "difference", "mathematics", "arithmetic", "calculator", "+", "-", "\xB1"], codepoint: 58328, published_in: 1, updated_in: 1 }, { name: "plus-square", pascal_name: "PlusSquare", categories: [e.FINANCE, e.DEVELOPMENT, e.SYSTEM], figma_category: a.FINANCE, tags: ["addition", "sum", "mathematics", "arithmetic", "calculator", "+"], codepoint: 60746, published_in: 2, updated_in: 2 }, { name: "poker-chip", pascal_name: "PokerChip", categories: [e.GAMES], figma_category: a.GAMES, tags: ["chips", "tokens", "cards", "gambling", "casino"], codepoint: 58772, published_in: 1.1, updated_in: 1.1 }, { name: "police-car", pascal_name: "PoliceCar", categories: [e.MAP, e.OBJECTS], figma_category: a.MAP, tags: ["*updated*", "vehicles", "cars", "automobiles", "law enforcement"], codepoint: 60490, published_in: 1.4, updated_in: 2.1 }, { name: "polygon", pascal_name: "Polygon", categories: [e.DESIGN], figma_category: a.DESIGN, tags: ["shapes", "drawing"], codepoint: 59088, published_in: 1.3, updated_in: 1.3 }, { name: "popcorn", pascal_name: "Popcorn", categories: [e.MAP, e.COMMERCE], figma_category: a.COMMERCE, tags: ["food", "movies", "theater"], codepoint: 60238, published_in: 1.4, updated_in: 1.4 }, { name: "popsicle", pascal_name: "Popsicle", categories: [e.COMMERCE, e.MAP], figma_category: a.COMMERCE, tags: ["*new*", "ice cream", "dessert", "summer", "food"], codepoint: 60350, published_in: 2.1, updated_in: 2.1 }, { name: "potted-plant", pascal_name: "PottedPlant", categories: [e.COMMERCE, e.NATURE], figma_category: a.COMMERCE, tags: ["sprout", "vegan", "garden", "gardening"], codepoint: 60450, published_in: 2, updated_in: 2 }, { name: "power", pascal_name: "Power", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["charged", "charger", "charging", "on", "off", "on/off", "switch", "power switch"], codepoint: 58330, published_in: 1, updated_in: 1 }, { name: "prescription", pascal_name: "Prescription", categories: [e.HEALTH], figma_category: a.HEALTH, tags: ["rx", "medicine", "drugs", "pharmacy", "pharmacist", "pharmaceuticals", "doctor"], codepoint: 59298, published_in: 1.3, updated_in: 1.3 }, { name: "presentation", pascal_name: "Presentation", categories: [e.FINANCE, e.OFFICE], figma_category: a.OFFICE, tags: ["whiteboard", "flipchart", "charts", "statistics", "analyze", "analysis", "meeting"], codepoint: 58964, published_in: 1.2, updated_in: 1.2 }, { name: "presentation-chart", pascal_name: "PresentationChart", categories: [e.FINANCE, e.OFFICE], figma_category: a.OFFICE, tags: ["whiteboard", "flipchart", "graphs", "graphing", "charts", "statistics", "analyze", "analysis", "meeting"], codepoint: 58966, published_in: 1.2, updated_in: 1.2 }, { name: "printer", pascal_name: "Printer", categories: [e.EDITOR, e.OFFICE], figma_category: a.OFFICE, tags: ["printing"], codepoint: 58332, published_in: 1, updated_in: 1 }, { name: "prohibit", pascal_name: "Prohibit", categories: [e.MAP, e.SYSTEM], figma_category: a.SECURITY, tags: ["forbidden", "prohibited", "cancelled", "prevent", "stop", "do not enter"], codepoint: 58334, published_in: 1, updated_in: 1 }, { name: "prohibit-inset", pascal_name: "ProhibitInset", categories: [e.MAP, e.SYSTEM], figma_category: a.SECURITY, tags: ["forbidden", "prohibited", "cancelled", "prevent", "stop", "do not enter"], codepoint: 58336, published_in: 1, updated_in: 1 }, { name: "projector-screen", pascal_name: "ProjectorScreen", categories: [e.FINANCE, e.MEDIA, e.OFFICE], figma_category: a.OFFICE, tags: ["projection", "presentation", "slideshow", "movies", "charts", "statistics", "analyze", "analysis"], codepoint: 58968, published_in: 1.2, updated_in: 1.2 }, { name: "projector-screen-chart", pascal_name: "ProjectorScreenChart", categories: [e.FINANCE, e.OFFICE], figma_category: a.OFFICE, tags: ["projection", "presentation", "slideshow", "graphs", "graphing", "charts", "statistics", "analyze", "analysis"], codepoint: 58970, published_in: 1.2, updated_in: 1.2 }, { name: "pulse", pascal_name: "Pulse", alias: { name: "activity", pascal_name: "Activity" }, categories: [e.HEALTH], figma_category: a.HEALTH, tags: ["activity", "heartbeat", "medical", "ecg", "ekg", "vitals", "monitor", "medicine"], codepoint: 57344, published_in: 1, updated_in: 1 }, { name: "push-pin", pascal_name: "PushPin", categories: [e.OFFICE, e.MAP, e.OBJECTS], figma_category: a.OFFICE, tags: ["favorites", "favorited", "pushpin"], codepoint: 58338, published_in: 1, updated_in: 1 }, { name: "push-pin-simple", pascal_name: "PushPinSimple", categories: [e.OFFICE, e.MAP, e.OBJECTS], figma_category: a.OFFICE, tags: ["favorites", "favorited", "pushpin"], codepoint: 58972, published_in: 1.2, updated_in: 1.2 }, { name: "push-pin-simple-slash", pascal_name: "PushPinSimpleSlash", categories: [e.OFFICE, e.MAP, e.OBJECTS], figma_category: a.OFFICE, tags: ["favorites", "favorited", "pushpin", "disabled"], codepoint: 58974, published_in: 1.2, updated_in: 1.2 }, { name: "push-pin-slash", pascal_name: "PushPinSlash", categories: [e.OFFICE, e.MAP, e.OBJECTS], figma_category: a.OFFICE, tags: ["favorites", "favorited", "pushpin", "disabled"], codepoint: 58340, published_in: 1, updated_in: 1 }, { name: "puzzle-piece", pascal_name: "PuzzlePiece", categories: [e.GAMES, e.DEVELOPMENT], figma_category: a.GAMES, tags: ["board game", "element", "component", "extension", "plugin"], codepoint: 58774, published_in: 1.1, updated_in: 1.1 }, { name: "qr-code", pascal_name: "QrCode", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["upc", "barcode", "products", "shopping", "scanner"], codepoint: 58342, published_in: 1, updated_in: 1 }, { name: "question", pascal_name: "Question", categories: [e.SYSTEM], figma_category: a.SECURITY, tags: ["information", "help", "support", "questions"], codepoint: 58344, published_in: 1, updated_in: 1 }, { name: "question-mark", pascal_name: "QuestionMark", categories: [e.SYSTEM], figma_category: a.SECURITY, tags: ["*new*", "?", "information", "help", "support", "questions", "punctuation", "symbol"], codepoint: 58344, published_in: 2.1, updated_in: 2.1 }, { name: "queue", pascal_name: "Queue", categories: [e.MEDIA, e.SYSTEM], figma_category: a.MEDIA, tags: ["*updated*", "music", "audio", "playlist"], codepoint: 59052, published_in: 1.3, updated_in: 2.1 }, { name: "quotes", pascal_name: "Quotes", categories: [e.COMMUNICATION, e.EDITOR, e.MEDIA], figma_category: a.COMMUNICATION, tags: ["quoations", "quotation marks", "double-quotes", "writing", "books"], codepoint: 58976, published_in: 1.2, updated_in: 1.2 }, { name: "rabbit", pascal_name: "Rabbit", categories: [e.NATURE], figma_category: a.WEATHER, tags: ["*new*", "hare", "fast", "animal"], codepoint: 60098, published_in: 2.1, updated_in: 2.1 }, { name: "racquet", pascal_name: "Racquet", categories: [e.GAMES, e.HEALTH, e.OBJECTS], figma_category: a.GAMES, tags: ["*new*", "sports", "tennis", "squash", "pickleball"], codepoint: 60930, published_in: 2.1, updated_in: 2.1 }, { name: "radical", pascal_name: "Radical", categories: [e.DEVELOPMENT, e.FINANCE], figma_category: a.FINANCE, tags: ["\u221A", "radix", "radicand", "square root", "squareroot", "mathematics", "arithmetic", "calculator"], codepoint: 58346, published_in: 1, updated_in: 1 }, { name: "radio", pascal_name: "Radio", categories: [e.COMMUNICATION, e.MEDIA, e.OBJECTS], figma_category: a.COMMUNICATION, tags: ["broadcast", "fm", "am", "xm", "transmitter", "receiver"], codepoint: 59262, published_in: 1.3, updated_in: 1.3 }, { name: "radio-button", pascal_name: "RadioButton", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["input", "checkbox", "checked"], codepoint: 60168, published_in: 1.4, updated_in: 1.4 }, { name: "radioactive", pascal_name: "Radioactive", categories: [e.NATURE, e.HEALTH], figma_category: a.SECURITY, tags: ["radiation", "danger", "warning", "nuclear", "atomic"], codepoint: 59868, published_in: 2, updated_in: 2 }, { name: "rainbow", pascal_name: "Rainbow", categories: [e.WEATHER], figma_category: a.WEATHER, tags: ["meteorology", "rainstorm", "arc", "pride", "lgbtq+", "leprechaun"], codepoint: 58776, published_in: 1.1, updated_in: 1.1 }, { name: "rainbow-cloud", pascal_name: "RainbowCloud", categories: [e.WEATHER], figma_category: a.WEATHER, tags: ["meteorology", "rainstorm", "cloudy", "partly cloudy", "partly sunny", "pride", "lgbtq+", "leprechaun"], codepoint: 58778, published_in: 1.1, updated_in: 1.1 }, { name: "ranking", pascal_name: "Ranking", categories: [e.GAMES, e.OBJECTS], figma_category: a.GAMES, tags: ["*new*", "medal", "rank", "leaderboard", "winner", "sports"], codepoint: 60770, published_in: 2.1, updated_in: 2.1 }, { name: "read-cv-logo", pascal_name: "ReadCvLogo", categories: [e.BRAND], figma_category: a.BRAND, tags: ["resume", "jobs", "logos"], codepoint: 60684, published_in: 2, updated_in: 2 }, { name: "receipt", pascal_name: "Receipt", categories: [e.COMMERCE, e.FINANCE], figma_category: a.COMMERCE, tags: ["purchase", "money", "clipping", "expense"], codepoint: 58348, published_in: 1, updated_in: 1 }, { name: "receipt-x", pascal_name: "ReceiptX", categories: [e.COMMERCE, e.FINANCE], figma_category: a.COMMERCE, tags: ["purchase", "money", "clipping", "expense", "cancel"], codepoint: 60736, published_in: 2, updated_in: 2 }, { name: "record", pascal_name: "Record", categories: [e.MEDIA, e.SYSTEM], figma_category: a.MEDIA, tags: ["music", "audio", "recording", "recorder", "voice memo"], codepoint: 58350, published_in: 1, updated_in: 1 }, { name: "rectangle", pascal_name: "Rectangle", categories: [e.DESIGN], figma_category: a.DESIGN, tags: ["4", "shapes", "polygons", "box"], codepoint: 58352, published_in: 1, updated_in: 1 }, { name: "rectangle-dashed", pascal_name: "RectangleDashed", categories: [e.DESIGN], figma_category: a.DESIGN, tags: ["*new*", "4", "shapes", "polygons", "box", "missing"], codepoint: 58354, published_in: 2.1, updated_in: 2.1 }, { name: "recycle", pascal_name: "Recycle", categories: [e.ARROWS, e.NATURE], figma_category: a.ARROWS, tags: ["recycling", "trash", "environmental", "green"], codepoint: 59226, published_in: 1.3, updated_in: 1.3 }, { name: "reddit-logo", pascal_name: "RedditLogo", categories: [e.BRAND, e.COMMUNICATION], figma_category: a.BRAND, tags: ["logos", "subreddit", "snoo", "social media"], codepoint: 58780, published_in: 1.1, updated_in: 1.1 }, { name: "repeat", pascal_name: "Repeat", categories: [e.MEDIA, e.SYSTEM], figma_category: a.MEDIA, tags: ["music", "audio", "recycle"], codepoint: 58358, published_in: 1, updated_in: 1 }, { name: "repeat-once", pascal_name: "RepeatOnce", categories: [e.MEDIA, e.SYSTEM], figma_category: a.MEDIA, tags: ["music", "audio", "recycle"], codepoint: 58360, published_in: 1, updated_in: 1 }, { name: "replit-logo", pascal_name: "ReplitLogo", categories: [e.BRAND, e.DEVELOPMENT], figma_category: a.BRAND, tags: ["*new*", "logos", "ide", "editor", "coding"], codepoint: 60298, published_in: 2.1, updated_in: 2.1 }, { name: "resize", pascal_name: "Resize", categories: [e.DESIGN, e.EDITOR], figma_category: a.DESIGN, tags: ["*new*", "maximize", "expand", "grow"], codepoint: 60782, published_in: 2.1, updated_in: 2.1 }, { name: "rewind", pascal_name: "Rewind", categories: [e.MEDIA, e.SYSTEM], figma_category: a.MEDIA, tags: ["music", "audio", "seek", "scrub", "scan", "skip", "back", "backwards", "reverse"], codepoint: 59048, published_in: 1.3, updated_in: 1.3 }, { name: "rewind-circle", pascal_name: "RewindCircle", categories: [e.MEDIA, e.SYSTEM], figma_category: a.MEDIA, tags: ["music", "audio", "seek", "scrub", "scan", "skip", "back", "backwards", "reverse"], codepoint: 58362, published_in: 1, updated_in: 1 }, { name: "road-horizon", pascal_name: "RoadHorizon", categories: [e.MAP], figma_category: a.MAP, tags: ["trip", "drive", "road", "travel", "transportation", "highway"], codepoint: 59448, published_in: 2, updated_in: 2 }, { name: "robot", pascal_name: "Robot", categories: [e.DEVELOPMENT, e.OBJECTS], figma_category: a.DEVELOPMENT, tags: ["automaton", "artificial intelligence", "ai"], codepoint: 59234, published_in: 1.3, updated_in: 1.3 }, { name: "rocket", pascal_name: "Rocket", categories: [e.DEVELOPMENT, e.MAP, e.OBJECTS], figma_category: a.MAP, tags: ["spaceship", "launch", "deployment", "rocketship"], codepoint: 58364, published_in: 1, updated_in: 1 }, { name: "rocket-launch", pascal_name: "RocketLaunch", categories: [e.DEVELOPMENT, e.MAP, e.OBJECTS], figma_category: a.MAP, tags: ["*updated*", "spaceship", "flying", "blastoff", "deployment", "rocketship"], codepoint: 58366, published_in: 1, updated_in: 2.1 }, { name: "rows", pascal_name: "Rows", categories: [e.DESIGN], figma_category: a.DESIGN, tags: ["2", "shapes", "polygons", "box", "stack", "list", "table", "cards"], codepoint: 58786, published_in: 1.1, updated_in: 1.1 }, { name: "rows-plus-bottom", pascal_name: "RowsPlusBottom", categories: [e.DESIGN], figma_category: a.DESIGN, tags: ["*new*", "2", "shapes", "polygons", "box", "stack", "list", "table", "cards", "prepend", "insert"], codepoint: 58782, published_in: 2.1, updated_in: 2.1 }, { name: "rows-plus-top", pascal_name: "RowsPlusTop", categories: [e.DESIGN], figma_category: a.DESIGN, tags: ["*new*", "2", "shapes", "polygons", "box", "stack", "list", "table", "cards", "prepend", "insert"], codepoint: 58784, published_in: 2.1, updated_in: 2.1 }, { name: "rss", pascal_name: "Rss", categories: [e.COMMUNICATION], figma_category: a.COMMUNICATION, tags: ["radio", "broadcast", "web feed", "news", "aggregator"], codepoint: 58368, published_in: 1, updated_in: 1 }, { name: "rss-simple", pascal_name: "RssSimple", categories: [e.COMMUNICATION], figma_category: a.COMMUNICATION, tags: ["radio", "broadcast", "web feed", "news", "aggregator"], codepoint: 58370, published_in: 1, updated_in: 1 }, { name: "rug", pascal_name: "Rug", categories: [e.OBJECTS], figma_category: a.COMMERCE, tags: ["*updated*", "tapestry", "carpet"], codepoint: 59930, published_in: 1.4, updated_in: 2.1 }, { name: "ruler", pascal_name: "Ruler", categories: [e.DESIGN, e.EDITOR, e.OBJECTS], figma_category: a.DESIGN, tags: ["measure", "scale", "distance"], codepoint: 59064, published_in: 1.3, updated_in: 1.4 }, { name: "sailboat", pascal_name: "Sailboat", categories: [e.MAP, e.OBJECTS], figma_category: a.MAP, tags: ["*new*", "sailing", "ship", "vehicles", "transportation", "sports", "places", "locations"], codepoint: 59274, published_in: 2.1, updated_in: 2.1 }, { name: "scales", pascal_name: "Scales", categories: [e.COMMERCE, e.MAP, e.OBJECTS], figma_category: a.COMMERCE, tags: ["measure", "balance", "law", "justice", "government"], codepoint: 59216, published_in: 1.3, updated_in: 1.3 }, { name: "scan", pascal_name: "Scan", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["upc", "barcode", "products", "shopping", "scanner"], codepoint: 60342, published_in: 1.4, updated_in: 1.4 }, { name: "scan-smiley", pascal_name: "ScanSmiley", categories: [e.SYSTEM, e.PEOPLE], figma_category: a.SYSTEM, tags: ["*new*", "facial recognition", "face unlock", "scanner"], codepoint: 60340, published_in: 2.1, updated_in: 2.1 }, { name: "scissors", pascal_name: "Scissors", categories: [e.DESIGN, e.EDITOR, e.OFFICE, e.SYSTEM], figma_category: a.DESIGN, tags: ["*updated*", "cut", "snip", "clipboard"], codepoint: 60128, published_in: 1.1, updated_in: 2.1 }, { name: "scooter", pascal_name: "Scooter", categories: [e.MAP, e.HEALTH], figma_category: a.MAP, tags: ["vehicles", "transportation", "travel", "transit"], codepoint: 59424, published_in: 2, updated_in: 2 }, { name: "screencast", pascal_name: "Screencast", categories: [e.MEDIA, e.SYSTEM], figma_category: a.MEDIA, tags: ["apple", "airplay", "screencasting", "screen share", "television", "tv"], codepoint: 58372, published_in: 1, updated_in: 1 }, { name: "screwdriver", pascal_name: "Screwdriver", categories: [e.COMMERCE, e.OBJECTS], figma_category: a.COMMERCE, tags: ["*new*", "tools", "construction", "flathead", "drill"], codepoint: 59502, published_in: 2.1, updated_in: 2.1 }, { name: "scribble", pascal_name: "Scribble", categories: [e.DESIGN], figma_category: a.DESIGN, tags: ["*new*", "doodles", "squiggle", "drawing", "sign", "signature"], codepoint: 59398, published_in: 2.1, updated_in: 2.1 }, { name: "scribble-loop", pascal_name: "ScribbleLoop", categories: [e.DESIGN], figma_category: a.DESIGN, tags: ["doodles", "drawing", "sign", "signature"], codepoint: 58978, published_in: 1.2, updated_in: 1.2 }, { name: "scroll", pascal_name: "Scroll", categories: [e.GAMES, e.OBJECTS], figma_category: a.GAMES, tags: ["*updated*", "parchment", "paper", "script", "spell", "fantasy"], codepoint: 60282, published_in: 1.4, updated_in: 2.1 }, { name: "seal", pascal_name: "Seal", alias: { name: "circle-wavy", pascal_name: "CircleWavy" }, categories: [e.DESIGN], figma_category: a.SECURITY, tags: ["badge", "verified", "verification", "shapes", "polygons", "circle-wavy"], codepoint: 58884, published_in: 1.2, updated_in: 1.2 }, { name: "seal-check", pascal_name: "SealCheck", alias: { name: "circle-wavy-check", pascal_name: "CircleWavyCheck" }, categories: [e.DESIGN], figma_category: a.SECURITY, tags: ["badge", "verified", "verification", "shapes", "polygons", "circle-wavy"], codepoint: 58886, published_in: 1.2, updated_in: 1.2 }, { name: "seal-percent", pascal_name: "SealPercent", categories: [e.DESIGN], figma_category: a.SECURITY, tags: ["*new*", "badge", "discount", "sale", "shapes", "polygons", "circle-wavy"], codepoint: 58890, published_in: 2.1, updated_in: 2.1 }, { name: "seal-question", pascal_name: "SealQuestion", alias: { name: "circle-wavy-question", pascal_name: "CircleWavyQuestion" }, categories: [e.DESIGN], figma_category: a.SECURITY, tags: ["badge", "unverified", "verification", "shapes", "polygons", "circle-wavy"], codepoint: 58888, published_in: 1.2, updated_in: 1.2 }, { name: "seal-warning", pascal_name: "SealWarning", alias: { name: "circle-wavy-warning", pascal_name: "CircleWavyWarning" }, categories: [e.DESIGN], figma_category: a.SECURITY, tags: ["badge", "unverified", "verification", "errors", "shapes", "polygons", "circle-wavy"], codepoint: 58892, published_in: 1.2, updated_in: 1.2 }, { name: "seat", pascal_name: "Seat", categories: [e.MAP, e.OBJECTS], figma_category: a.MAP, tags: ["*new*", "chair", "car seat", "airplane seat", "transit", "transportation", "traveling"], codepoint: 60302, published_in: 2.1, updated_in: 2.1 }, { name: "seatbelt", pascal_name: "Seatbelt", categories: [e.COMMERCE, e.OBJECTS], figma_category: a.COMMERCE, tags: ["*new*", "vehicles", "safety"], codepoint: 60926, published_in: 2.1, updated_in: 2.1 }, { name: "security-camera", pascal_name: "SecurityCamera", categories: [e.OBJECTS, e.SYSTEM], figma_category: a.SECURITY, tags: ["*new*", "cctv", "surveillance", "video", "monitor", "motion detector", "safety"], codepoint: 60580, published_in: 2.1, updated_in: 2.1 }, { name: "selection", pascal_name: "Selection", categories: [e.DESIGN, e.EDITOR], figma_category: a.DESIGN, tags: ["marquis", "select", "square dashed"], codepoint: 59034, published_in: 1.3, updated_in: 1.3 }, { name: "selection-all", pascal_name: "SelectionAll", categories: [e.DESIGN, e.EDITOR], figma_category: a.DESIGN, tags: ["marquis", "select all"], codepoint: 59206, published_in: 1.3, updated_in: 1.3 }, { name: "selection-background", pascal_name: "SelectionBackground", categories: [e.DESIGN, e.EDITOR], figma_category: a.DESIGN, tags: ["marquis"], codepoint: 60152, published_in: 1.3, updated_in: 1.3 }, { name: "selection-foreground", pascal_name: "SelectionForeground", categories: [e.DESIGN, e.EDITOR], figma_category: a.DESIGN, tags: ["marquis"], codepoint: 60150, published_in: 1.3, updated_in: 1.3 }, { name: "selection-inverse", pascal_name: "SelectionInverse", categories: [e.DESIGN, e.EDITOR], figma_category: a.DESIGN, tags: ["marquis", "invert"], codepoint: 59204, published_in: 1.3, updated_in: 1.3 }, { name: "selection-plus", pascal_name: "SelectionPlus", categories: [e.DESIGN, e.EDITOR], figma_category: a.DESIGN, tags: ["marquis", "add"], codepoint: 59036, published_in: 1.3, updated_in: 1.3 }, { name: "selection-slash", pascal_name: "SelectionSlash", categories: [e.DESIGN, e.EDITOR], figma_category: a.DESIGN, tags: ["marquis", "unselect"], codepoint: 59038, published_in: 1.3, updated_in: 1.3 }, { name: "shapes", pascal_name: "Shapes", categories: [e.DESIGN], figma_category: a.DESIGN, tags: ["geometry", "square", "circle", "triangle"], codepoint: 60510, published_in: 2, updated_in: 2 }, { name: "share", pascal_name: "Share", categories: [e.COMMUNICATION, e.SYSTEM], figma_category: a.COMMUNICATION, tags: ["send to", "export", "arrows"], codepoint: 58374, published_in: 1, updated_in: 1 }, { name: "share-fat", pascal_name: "ShareFat", categories: [e.ARROWS, e.SYSTEM, e.COMMUNICATION], figma_category: a.COMMUNICATION, tags: ["export", "send to"], codepoint: 60754, published_in: 2, updated_in: 2 }, { name: "share-network", pascal_name: "ShareNetwork", categories: [e.COMMUNICATION, e.SYSTEM], figma_category: a.COMMUNICATION, tags: ["send to", "export"], codepoint: 58376, published_in: 1, updated_in: 1 }, { name: "shield", pascal_name: "Shield", categories: [e.SYSTEM, e.OBJECTS], figma_category: a.SECURITY, tags: ["badge", "security", "secured", "defense", "defended", "authentication", "authenticated", "guarded", "locked", "encrypted", "encryption"], codepoint: 58378, published_in: 1, updated_in: 1 }, { name: "shield-check", pascal_name: "ShieldCheck", categories: [e.SYSTEM, e.OBJECTS], figma_category: a.SECURITY, tags: ["badge", "security", "defense", "authentication", "authenticated", "guarded", "locked", "encrypted", "encryption"], codepoint: 58380, published_in: 1, updated_in: 1 }, { name: "shield-checkered", pascal_name: "ShieldCheckered", categories: [e.SYSTEM, e.OBJECTS], figma_category: a.SECURITY, tags: ["badge", "security", "defense", "authentication", "authenticated", "guarded", "locked", "encrypted", "encryption"], codepoint: 59144, published_in: 1.3, updated_in: 1.3 }, { name: "shield-chevron", pascal_name: "ShieldChevron", categories: [e.SYSTEM, e.OBJECTS], figma_category: a.SECURITY, tags: ["badge", "security", "defense", "authentication", "authenticated", "guarded", "locked", "encrypted", "encryption"], codepoint: 58382, published_in: 1, updated_in: 1 }, { name: "shield-plus", pascal_name: "ShieldPlus", categories: [e.SYSTEM, e.OBJECTS], figma_category: a.SECURITY, tags: ["badge", "security", "defense", "authentication", "authenticated", "guarded", "locked", "encrypted", "encryption"], codepoint: 59142, published_in: 1.3, updated_in: 1.3 }, { name: "shield-slash", pascal_name: "ShieldSlash", categories: [e.SYSTEM, e.OBJECTS], figma_category: a.SECURITY, tags: ["badge", "security", "unsecured", "defense", "undefended", "authentication", "unauthenticated", "unguarded", "unlocked", "unencrypted", "encryption", "disabled"], codepoint: 58384, published_in: 1, updated_in: 1 }, { name: "shield-star", pascal_name: "ShieldStar", categories: [e.OBJECTS, e.SYSTEM], figma_category: a.SECURITY, tags: ["badge", "security", "defense", "authentication", "authenticated", "guarded", "locked", "encrypted", "encryption"], codepoint: 60468, published_in: 1.4, updated_in: 1.4 }, { name: "shield-warning", pascal_name: "ShieldWarning", categories: [e.SYSTEM, e.OBJECTS], figma_category: a.SECURITY, tags: ["badge", "security", "unsecured", "defense", "undefended", "authentication", "unauthenticated", "unguarded", "unlocked", "unencrypted", "encryption", "errors"], codepoint: 58386, published_in: 1, updated_in: 1 }, { name: "shipping-container", pascal_name: "ShippingContainer", categories: [e.MAP, e.OBJECTS, e.COMMERCE], figma_category: a.MAP, tags: ["*new*", "shipping", "transportation", "places", "locations"], codepoint: 59276, published_in: 2.1, updated_in: 2.1 }, { name: "shirt-folded", pascal_name: "ShirtFolded", categories: [e.COMMERCE, e.OBJECTS], figma_category: a.COMMERCE, tags: ["clothes", "clothing"], codepoint: 60050, published_in: 2, updated_in: 2 }, { name: "shooting-star", pascal_name: "ShootingStar", categories: [e.NATURE], figma_category: a.WEATHER, tags: ["wish", "comet", "meteor"], codepoint: 60666, published_in: 2, updated_in: 2 }, { name: "shopping-bag", pascal_name: "ShoppingBag", categories: [e.COMMERCE, e.MAP, e.OBJECTS], figma_category: a.COMMERCE, tags: ["ecommerce", "market", "basket", "cart", "buying", "checkout", "places", "locations"], codepoint: 58390, published_in: 1, updated_in: 1 }, { name: "shopping-bag-open", pascal_name: "ShoppingBagOpen", categories: [e.COMMERCE, e.MAP, e.OBJECTS], figma_category: a.COMMERCE, tags: ["ecommerce", "market", "basket", "cart", "buying", "checkout", "places", "locations"], codepoint: 58392, published_in: 1, updated_in: 1 }, { name: "shopping-cart", pascal_name: "ShoppingCart", categories: [e.COMMERCE, e.MAP, e.OBJECTS], figma_category: a.COMMERCE, tags: ["ecommerce", "market", "basket", "buying", "groceries", "checkout", "places", "locations"], codepoint: 58398, published_in: 1, updated_in: 1 }, { name: "shopping-cart-simple", pascal_name: "ShoppingCartSimple", categories: [e.COMMERCE, e.MAP, e.OBJECTS], figma_category: a.COMMERCE, tags: ["ecommerce", "market", "basket", "buying", "groceries", "checkout", "places", "locations"], codepoint: 58400, published_in: 1, updated_in: 1 }, { name: "shovel", pascal_name: "Shovel", categories: [e.COMMERCE, e.OBJECTS], figma_category: a.COMMERCE, tags: ["*new*", "tools", "digging", "construction"], codepoint: 59878, published_in: 2.1, updated_in: 2.1 }, { name: "shower", pascal_name: "Shower", categories: [e.OBJECTS], figma_category: a.COMMERCE, tags: ["bath", "bathtub", "bathroom", "faucet"], codepoint: 59254, published_in: 1.3, updated_in: 1.3 }, { name: "shrimp", pascal_name: "Shrimp", categories: [e.COMMERCE, e.NATURE], figma_category: a.WEATHER, tags: ["food", "seafood", "prawn"], codepoint: 60084, published_in: 2, updated_in: 2 }, { name: "shuffle", pascal_name: "Shuffle", categories: [e.MEDIA, e.ARROWS, e.SYSTEM], figma_category: a.MEDIA, tags: ["music", "audio", "randomize", "crossed"], codepoint: 58402, published_in: 1, updated_in: 1 }, { name: "shuffle-angular", pascal_name: "ShuffleAngular", categories: [e.MEDIA, e.ARROWS, e.SYSTEM], figma_category: a.MEDIA, tags: ["music", "audio", "randomize", "crossed"], codepoint: 58404, published_in: 1, updated_in: 1 }, { name: "shuffle-simple", pascal_name: "ShuffleSimple", categories: [e.MEDIA, e.ARROWS, e.SYSTEM], figma_category: a.MEDIA, tags: ["music", "audio", "randomize", "crossed"], codepoint: 58406, published_in: 1, updated_in: 1 }, { name: "sidebar", pascal_name: "Sidebar", categories: [e.DESIGN, e.EDITOR], figma_category: a.DESIGN, tags: ["left rail", "wireframe", "ui", "interface"], codepoint: 60086, published_in: 1.4, updated_in: 1.4 }, { name: "sidebar-simple", pascal_name: "SidebarSimple", categories: [e.DESIGN, e.EDITOR], figma_category: a.DESIGN, tags: ["left rail", "wireframe", "ui", "interface"], codepoint: 60452, published_in: 1.4, updated_in: 1.4 }, { name: "sigma", pascal_name: "Sigma", categories: [e.FINANCE, e.DEVELOPMENT], figma_category: a.FINANCE, tags: ["\u03C3", "symbol", "mathematics", "sum"], codepoint: 60088, published_in: 2, updated_in: 2 }, { name: "sign-in", pascal_name: "SignIn", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["*updated*", "signin", "login", "log in", "enter"], codepoint: 58408, published_in: 1, updated_in: 2.1 }, { name: "sign-out", pascal_name: "SignOut", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["*updated*", "signout", "logout", "log out", "exit"], codepoint: 58410, published_in: 1, updated_in: 2.1 }, { name: "signature", pascal_name: "Signature", categories: [e.COMMUNICATION, e.OFFICE], figma_category: a.COMMUNICATION, tags: ["*updated*", "sign", "autograph", "verify"], codepoint: 60332, published_in: 2, updated_in: 2.1 }, { name: "signpost", pascal_name: "Signpost", categories: [e.MAP], figma_category: a.MAP, tags: ["direction", "traffic", "road sign", "transit", "transportation"], codepoint: 59548, published_in: 1.4, updated_in: 1.4 }, { name: "sim-card", pascal_name: "SimCard", categories: [e.COMMUNICATION, e.SYSTEM], figma_category: a.SYSTEM, tags: ["*updated*", "cellular", "cellphone", "mobile"], codepoint: 58980, published_in: 1.2, updated_in: 2.1 }, { name: "siren", pascal_name: "Siren", categories: [e.OBJECTS, e.MAP], figma_category: a.SECURITY, tags: ["alarm", "police", "lights", "warning"], codepoint: 59832, published_in: 2, updated_in: 2 }, { name: "sketch-logo", pascal_name: "SketchLogo", categories: [e.DESIGN], figma_category: a.BRAND, tags: ["drawing", "art", "illustration", "ui", "interface", "prototype", "prototyping", "gemstone", "diamond"], codepoint: 58412, published_in: 1, updated_in: 1 }, { name: "skip-back", pascal_name: "SkipBack", categories: [e.MEDIA, e.SYSTEM], figma_category: a.MEDIA, tags: ["music", "audio", "seek", "scrub", "scan", "back", "backwards", "reverse", "previous"], codepoint: 58788, published_in: 1.1, updated_in: 1.1 }, { name: "skip-back-circle", pascal_name: "SkipBackCircle", categories: [e.MEDIA, e.SYSTEM], figma_category: a.MEDIA, tags: ["music", "audio", "seek", "scrub", "scan", "back", "backwards", "reverse", "previous"], codepoint: 58414, published_in: 1, updated_in: 1 }, { name: "skip-forward", pascal_name: "SkipForward", categories: [e.MEDIA, e.SYSTEM], figma_category: a.MEDIA, tags: ["music", "audio", "seek", "scrub", "scan", "ahead", "next"], codepoint: 58790, published_in: 1.1, updated_in: 1.1 }, { name: "skip-forward-circle", pascal_name: "SkipForwardCircle", categories: [e.MEDIA, e.SYSTEM], figma_category: a.MEDIA, tags: ["music", "audio", "seek", "scrub", "scan", "ahead", "next"], codepoint: 58416, published_in: 1, updated_in: 1 }, { name: "skull", pascal_name: "Skull", categories: [e.GAMES], figma_category: a.GAMES, tags: ["death", "dead", "kill"], codepoint: 59670, published_in: 1.4, updated_in: 1.4 }, { name: "skype-logo", pascal_name: "SkypeLogo", categories: [e.BRAND, e.COMMUNICATION], figma_category: a.BRAND, tags: ["*new*", "chat", "video conference"], codepoint: 59612, published_in: 2.1, updated_in: 2.1 }, { name: "slack-logo", pascal_name: "SlackLogo", categories: [e.BRAND, e.COMMUNICATION], figma_category: a.BRAND, tags: ["logos", "messaging"], codepoint: 58792, published_in: 1.1, updated_in: 1.1 }, { name: "sliders", pascal_name: "Sliders", categories: [e.MEDIA, e.SYSTEM], figma_category: a.MEDIA, tags: ["music", "audio", "faders", "filters", "equalizer", "volume", "settings", "preferences"], codepoint: 58418, published_in: 1, updated_in: 1 }, { name: "sliders-horizontal", pascal_name: "SlidersHorizontal", categories: [e.MEDIA, e.SYSTEM], figma_category: a.MEDIA, tags: ["music", "audio", "faders", "filters", "equalizer", "volume", "settings", "preferences"], codepoint: 58420, published_in: 1, updated_in: 1 }, { name: "slideshow", pascal_name: "Slideshow", categories: [e.MEDIA, e.SYSTEM], figma_category: a.MEDIA, tags: ["pictures", "images", "photography", "gallery", "carousel"], codepoint: 60722, published_in: 2, updated_in: 2 }, { name: "smiley", pascal_name: "Smiley", categories: [e.COMMUNICATION, e.PEOPLE], figma_category: a.PEOPLE, tags: ["face", "emoji", "happy", "grinning", "smiling"], codepoint: 58422, published_in: 1, updated_in: 1 }, { name: "smiley-angry", pascal_name: "SmileyAngry", categories: [e.COMMUNICATION, e.PEOPLE], figma_category: a.PEOPLE, tags: ["face", "emoji", "mad", "frown"], codepoint: 60514, published_in: 2, updated_in: 2 }, { name: "smiley-blank", pascal_name: "SmileyBlank", categories: [e.COMMUNICATION, e.PEOPLE], figma_category: a.PEOPLE, tags: ["face", "emoji", "unimpressed", "no face"], codepoint: 58424, published_in: 1, updated_in: 1 }, { name: "smiley-meh", pascal_name: "SmileyMeh", categories: [e.COMMUNICATION, e.PEOPLE], figma_category: a.PEOPLE, tags: ["face", "emoji", "unimpressed", "neutral"], codepoint: 58426, published_in: 1, updated_in: 1 }, { name: "smiley-melting", pascal_name: "SmileyMelting", categories: [e.COMMUNICATION, e.PEOPLE], figma_category: a.PEOPLE, tags: ["*new*", "face", "emoji", "embarrassment", "sarcasm", "shame", "hot", "heat"], codepoint: 61014, published_in: 2.1, updated_in: 2.1 }, { name: "smiley-nervous", pascal_name: "SmileyNervous", categories: [e.COMMUNICATION, e.PEOPLE], figma_category: a.PEOPLE, tags: ["*updated*", "face", "emoji", "anxious", "uncomfortable", "uneasy", "queasy", "sick", "ill"], codepoint: 58428, published_in: 1, updated_in: 2.1 }, { name: "smiley-sad", pascal_name: "SmileySad", categories: [e.COMMUNICATION, e.PEOPLE], figma_category: a.PEOPLE, tags: ["face", "emoji", "unhappy", "frowning"], codepoint: 58430, published_in: 1, updated_in: 1 }, { name: "smiley-sticker", pascal_name: "SmileySticker", categories: [e.COMMUNICATION, e.PEOPLE], figma_category: a.PEOPLE, tags: ["face", "emoji", "happy", "grinning", "smiling"], codepoint: 58432, published_in: 1, updated_in: 1 }, { name: "smiley-wink", pascal_name: "SmileyWink", categories: [e.COMMUNICATION, e.PEOPLE], figma_category: a.PEOPLE, tags: ["face", "emoji", "winking", "flirting", "cute"], codepoint: 58982, published_in: 1.2, updated_in: 1.2 }, { name: "smiley-x-eyes", pascal_name: "SmileyXEyes", categories: [e.COMMUNICATION, e.PEOPLE], figma_category: a.PEOPLE, tags: ["face", "emoji", "dead", "killed", "unconscious"], codepoint: 58434, published_in: 1, updated_in: 1 }, { name: "snapchat-logo", pascal_name: "SnapchatLogo", categories: [e.BRAND, e.COMMUNICATION], figma_category: a.BRAND, tags: ["logos", "messaging", "social media"], codepoint: 58984, published_in: 1.2, updated_in: 1.2 }, { name: "sneaker", pascal_name: "Sneaker", categories: [e.COMMERCE, e.OBJECTS, e.HEALTH], figma_category: a.COMMERCE, tags: ["clothes", "clothing", "shoes", "trainers", "sports"], codepoint: 59404, published_in: 2, updated_in: 2 }, { name: "sneaker-move", pascal_name: "SneakerMove", categories: [e.COMMERCE, e.OBJECTS, e.HEALTH], figma_category: a.COMMERCE, tags: ["*updated*", "clothes", "clothing", "shoes", "trainers", "sports"], codepoint: 60768, published_in: 2, updated_in: 2.1 }, { name: "snowflake", pascal_name: "Snowflake", categories: [e.WEATHER], figma_category: a.WEATHER, tags: ["meteorology", "snowy", "snowing", "snowstorm"], codepoint: 58794, published_in: 1.1, updated_in: 1.1 }, { name: "soccer-ball", pascal_name: "SoccerBall", categories: [e.GAMES, e.HEALTH, e.OBJECTS], figma_category: a.GAMES, tags: ["*updated*", "sports", "football", "mls"], codepoint: 59158, published_in: 1.3, updated_in: 2.1 }, { name: "sock", pascal_name: "Sock", categories: [e.COMMERCE, e.OBJECTS], figma_category: a.COMMERCE, tags: ["*new*", "clothes", "clothing"], codepoint: 60622, published_in: 2.1, updated_in: 2.1 }, { name: "solar-panel", pascal_name: "SolarPanel", categories: [e.COMMERCE, e.OBJECTS], figma_category: a.COMMERCE, tags: ["*new*", "renewable", "energy", "power", "electricity"], codepoint: 60794, published_in: 2.1, updated_in: 2.1 }, { name: "solar-roof", pascal_name: "SolarRoof", categories: [e.COMMERCE, e.OBJECTS], figma_category: a.COMMERCE, tags: ["*new*", "renewable", "energy", "power", "electricity"], codepoint: 60794, published_in: 2.1, updated_in: 2.1 }, { name: "sort-ascending", pascal_name: "SortAscending", categories: [e.EDITOR], figma_category: a.OFFICE, tags: ["*updated*", "sorted", "sorting", "increasing", "a to z", "arrows", "list"], codepoint: 58436, published_in: 1, updated_in: 2.1 }, { name: "sort-descending", pascal_name: "SortDescending", categories: [e.EDITOR], figma_category: a.OFFICE, tags: ["*updated*", "sorted", "sorting", "decreasing", "z to a", "arrows", "list"], codepoint: 58438, published_in: 1, updated_in: 2.1 }, { name: "soundcloud-logo", pascal_name: "SoundcloudLogo", categories: [e.BRAND, e.MEDIA], figma_category: a.BRAND, tags: ["music", "social media", "logos"], codepoint: 59614, published_in: 2, updated_in: 2 }, { name: "spade", pascal_name: "Spade", categories: [e.GAMES], figma_category: a.GAMES, tags: ["spades", "suits", "cards", "gambling", "casino", "gaming"], codepoint: 58440, published_in: 1, updated_in: 1 }, { name: "sparkle", pascal_name: "Sparkle", categories: [e.COMMUNICATION, e.NATURE], figma_category: a.WEATHER, tags: ["star", "rate", "ratings", "favorites", "favorited"], codepoint: 59042, published_in: 1.3, updated_in: 1.3 }, { name: "speaker-hifi", pascal_name: "SpeakerHifi", categories: [e.MEDIA, e.OBJECTS], figma_category: a.MEDIA, tags: ["music", "audio", "sound", "stereo"], codepoint: 59912, published_in: 2, updated_in: 2 }, { name: "speaker-high", pascal_name: "SpeakerHigh", categories: [e.MEDIA, e.SYSTEM], figma_category: a.MEDIA, tags: ["*updated*", "music", "audio", "volume", "sound"], codepoint: 58442, published_in: 1, updated_in: 2.1 }, { name: "speaker-low", pascal_name: "SpeakerLow", categories: [e.MEDIA, e.SYSTEM], figma_category: a.MEDIA, tags: ["*updated*", "music", "audio", "volume", "sound"], codepoint: 58444, published_in: 1, updated_in: 2.1 }, { name: "speaker-none", pascal_name: "SpeakerNone", categories: [e.MEDIA, e.SYSTEM], figma_category: a.MEDIA, tags: ["*updated*", "music", "audio", "muted", "volume", "sound"], codepoint: 58446, published_in: 1, updated_in: 2.1 }, { name: "speaker-simple-high", pascal_name: "SpeakerSimpleHigh", categories: [e.MEDIA, e.SYSTEM], figma_category: a.MEDIA, tags: ["music", "audio", "volume", "sound"], codepoint: 58448, published_in: 1, updated_in: 1 }, { name: "speaker-simple-low", pascal_name: "SpeakerSimpleLow", categories: [e.MEDIA, e.SYSTEM], figma_category: a.MEDIA, tags: ["music", "audio", "volume", "sound"], codepoint: 58450, published_in: 1, updated_in: 1 }, { name: "speaker-simple-none", pascal_name: "SpeakerSimpleNone", categories: [e.MEDIA, e.SYSTEM], figma_category: a.MEDIA, tags: ["music", "audio", "muted", "volume", "sound"], codepoint: 58452, published_in: 1, updated_in: 1 }, { name: "speaker-simple-slash", pascal_name: "SpeakerSimpleSlash", categories: [e.MEDIA, e.SYSTEM], figma_category: a.MEDIA, tags: ["music", "audio", "muted", "volume", "sound", "disabled"], codepoint: 58454, published_in: 1, updated_in: 1 }, { name: "speaker-simple-x", pascal_name: "SpeakerSimpleX", categories: [e.MEDIA, e.SYSTEM], figma_category: a.MEDIA, tags: ["music", "audio", "muted", "volume", "sound", "disabled", "errors"], codepoint: 58456, published_in: 1, updated_in: 1 }, { name: "speaker-slash", pascal_name: "SpeakerSlash", categories: [e.MEDIA, e.SYSTEM], figma_category: a.MEDIA, tags: ["*updated*", "music", "audio", "muted", "volume", "sound", "disabled"], codepoint: 58458, published_in: 1, updated_in: 2.1 }, { name: "speaker-x", pascal_name: "SpeakerX", categories: [e.MEDIA, e.SYSTEM], figma_category: a.MEDIA, tags: ["*updated*", "music", "audio", "muted", "volume", "sound", "disabled", "errors"], codepoint: 58460, published_in: 1, updated_in: 2.1 }, { name: "speedometer", pascal_name: "Speedometer", categories: [e.DEVELOPMENT, e.OBJECTS, e.SYSTEM], figma_category: a.SYSTEM, tags: ["*new*", "gauge", "dashboard", "meter", "speed", "odometer", "performance"], codepoint: 61044, published_in: 2.1, updated_in: 2.1 }, { name: "sphere", pascal_name: "Sphere", categories: [e.DESIGN], figma_category: a.DESIGN, tags: ["*new*", "circle", "ball", "3d", "mesh", "cad", "model"], codepoint: 61030, published_in: 2.1, updated_in: 2.1 }, { name: "spinner", pascal_name: "Spinner", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["loading", "loader", "waiting", "progress"], codepoint: 58986, published_in: 1.2, updated_in: 1.2 }, { name: "spinner-ball", pascal_name: "SpinnerBall", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["*new*", "loading", "loader", "waiting", "progress"], codepoint: 60968, published_in: 2.1, updated_in: 2.1 }, { name: "spinner-gap", pascal_name: "SpinnerGap", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["loading", "loader", "waiting", "progress"], codepoint: 58988, published_in: 1.2, updated_in: 1.2 }, { name: "spiral", pascal_name: "Spiral", categories: [e.COMMUNICATION, e.DESIGN], figma_category: a.GAMES, tags: ["*updated*", "spin", "rotate", "dizzy"], codepoint: 59898, published_in: 1.4, updated_in: 2.1 }, { name: "split-horizontal", pascal_name: "SplitHorizontal", categories: [e.ARROWS, e.DESIGN, e.EDITOR], figma_category: a.DESIGN, tags: ["resize", "columns"], codepoint: 59506, published_in: 2, updated_in: 2 }, { name: "split-vertical", pascal_name: "SplitVertical", categories: [e.ARROWS, e.DESIGN, e.EDITOR], figma_category: a.DESIGN, tags: ["resize", "rows"], codepoint: 59510, published_in: 2, updated_in: 2 }, { name: "spotify-logo", pascal_name: "SpotifyLogo", categories: [e.BRAND, e.MEDIA], figma_category: a.BRAND, tags: ["music", "player", "streaming"], codepoint: 58990, published_in: 1.2, updated_in: 1.2 }, { name: "spray-bottle", pascal_name: "SprayBottle", categories: [e.OBJECTS, e.HEALTH], figma_category: a.DESIGN, tags: ["*new*", "cleaner", "cleaning"], codepoint: 59364, published_in: 2.1, updated_in: 2.1 }, { name: "square", pascal_name: "Square", categories: [e.DESIGN], figma_category: a.DESIGN, tags: ["4", "shapes", "polygons", "box"], codepoint: 58462, published_in: 1, updated_in: 1 }, { name: "square-half", pascal_name: "SquareHalf", categories: [e.DESIGN], figma_category: a.DESIGN, tags: ["4", "shapes", "polygons", "box", "columns", "sidebar", "split vertical"], codepoint: 58466, published_in: 1, updated_in: 1.4 }, { name: "square-half-bottom", pascal_name: "SquareHalfBottom", categories: [e.DESIGN], figma_category: a.DESIGN, tags: ["4", "shapes", "polygons", "box", "columns", "sidebar", "split vertical"], codepoint: 60182, published_in: 1.4, updated_in: 1.4 }, { name: "square-logo", pascal_name: "SquareLogo", categories: [e.BRAND, e.COMMERCE, e.FINANCE], figma_category: a.BRAND, tags: ["squareup", "payment"], codepoint: 59024, published_in: 1.3, updated_in: 1.3 }, { name: "square-split-horizontal", pascal_name: "SquareSplitHorizontal", categories: [e.DESIGN, e.EDITOR], figma_category: a.DESIGN, tags: ["shapes", "polygons", "columns"], codepoint: 59504, published_in: 2, updated_in: 2 }, { name: "square-split-vertical", pascal_name: "SquareSplitVertical", categories: [e.DESIGN, e.EDITOR], figma_category: a.DESIGN, tags: ["shapes", "polygons", "rows"], codepoint: 59508, published_in: 2, updated_in: 2 }, { name: "squares-four", pascal_name: "SquaresFour", categories: [e.DESIGN, e.SYSTEM], figma_category: a.DESIGN, tags: ["4", "shapes", "polygons", "apps", "applications", "grid", "table", "microsoft", "logos"], codepoint: 58468, published_in: 1, updated_in: 1 }, { name: "stack", pascal_name: "Stack", categories: [e.DESIGN, e.OFFICE, e.EDITOR], figma_category: a.DESIGN, tags: ["cards", "layers"], codepoint: 58470, published_in: 1, updated_in: 1 }, { name: "stack-minus", pascal_name: "StackMinus", categories: [e.DESIGN, e.OFFICE, e.EDITOR], figma_category: a.DESIGN, tags: ["*new*", "cards", "layers", "remove", "delete"], codepoint: 60916, published_in: 2.1, updated_in: 2.1 }, { name: "stack-overflow-logo", pascal_name: "StackOverflowLogo", categories: [e.BRAND, e.DEVELOPMENT], figma_category: a.BRAND, tags: ["logos", "code"], codepoint: 60280, published_in: 1.4, updated_in: 1.4 }, { name: "stack-plus", pascal_name: "StackPlus", categories: [e.DESIGN, e.OFFICE, e.EDITOR], figma_category: a.DESIGN, tags: ["*new*", "cards", "layers", "add"], codepoint: 60918, published_in: 2.1, updated_in: 2.1 }, { name: "stack-simple", pascal_name: "StackSimple", categories: [e.DESIGN, e.OFFICE, e.EDITOR], figma_category: a.DESIGN, tags: ["cards", "layers"], codepoint: 58472, published_in: 1, updated_in: 1 }, { name: "stairs", pascal_name: "Stairs", categories: [e.COMMERCE, e.OBJECTS], figma_category: a.COMMERCE, tags: ["staircase", "steps", "escalator", "exit", "signs"], codepoint: 59628, published_in: 2, updated_in: 2 }, { name: "stamp", pascal_name: "Stamp", categories: [e.DESIGN, e.OBJECTS], figma_category: a.DESIGN, tags: ["clone", "seal", "official"], codepoint: 59976, published_in: 1.4, updated_in: 1.4 }, { name: "standard-definition", pascal_name: "StandardDefinition", categories: [e.MEDIA], figma_category: a.MEDIA, tags: ["*new*", "sd", "resolution", "video"], codepoint: 60048, published_in: 2.1, updated_in: 2.1 }, { name: "star", pascal_name: "Star", categories: [e.COMMUNICATION, e.MAP, e.NATURE], figma_category: a.COMMUNICATION, tags: ["rate", "ratings", "favorites", "favorited"], codepoint: 58474, published_in: 1, updated_in: 1 }, { name: "star-and-crescent", pascal_name: "StarAndCrescent", categories: [e.COMMUNICATION, e.PEOPLE], figma_category: a.COMMUNICATION, tags: ["islam", "muslim", "moon", "religion", "worship", "symbol"], codepoint: 60660, published_in: 2, updated_in: 2 }, { name: "star-four", pascal_name: "StarFour", categories: [e.COMMUNICATION, e.NATURE], figma_category: a.WEATHER, tags: ["rate", "ratings", "favorites", "favorited"], codepoint: 59044, published_in: 1.3, updated_in: 1.3 }, { name: "star-half", pascal_name: "StarHalf", categories: [e.COMMUNICATION], figma_category: a.COMMUNICATION, tags: ["rate", "ratings"], codepoint: 59146, published_in: 1.3, updated_in: 1.4 }, { name: "star-of-david", pascal_name: "StarOfDavid", categories: [e.COMMUNICATION, e.PEOPLE], figma_category: a.COMMUNICATION, tags: ["judaism", "jewish", "hexagram", "religion", "worship", "symbol"], codepoint: 59550, published_in: 2, updated_in: 2 }, { name: "steam-logo", pascal_name: "SteamLogo", categories: [e.BRAND, e.GAMES], figma_category: a.BRAND, tags: ["*new*", "gaming", "games"], codepoint: 60116, published_in: 2.1, updated_in: 2.1 }, { name: "steering-wheel", pascal_name: "SteeringWheel", categories: [e.MAP, e.OBJECTS], figma_category: a.MAP, tags: ["cars", "vehicles", "automobiles", "driving"], codepoint: 59820, published_in: 2, updated_in: 2 }, { name: "steps", pascal_name: "Steps", categories: [e.COMMERCE, e.OBJECTS], figma_category: a.MAP, tags: ["stairs", "staircase", "exit", "signs"], codepoint: 60606, published_in: 2, updated_in: 2 }, { name: "stethoscope", pascal_name: "Stethoscope", categories: [e.HEALTH, e.OBJECTS], figma_category: a.HEALTH, tags: ["hospital", "medical", "medicine", "injury", "safety", "emergency", "doctor", "heart"], codepoint: 59370, published_in: 2, updated_in: 2 }, { name: "sticker", pascal_name: "Sticker", categories: [e.COMMUNICATION], figma_category: a.COMMUNICATION, tags: ["stickers", "sticker pack", "labels"], codepoint: 58796, published_in: 1.1, updated_in: 1.1 }, { name: "stool", pascal_name: "Stool", categories: [e.OBJECTS, e.COMMERCE], figma_category: a.COMMERCE, tags: ["chair", "seat", "furniture"], codepoint: 59972, published_in: 2, updated_in: 2 }, { name: "stop", pascal_name: "Stop", categories: [e.MEDIA, e.SYSTEM], figma_category: a.MEDIA, tags: ["music", "audio"], codepoint: 58476, published_in: 1, updated_in: 1 }, { name: "stop-circle", pascal_name: "StopCircle", categories: [e.MEDIA, e.SYSTEM], figma_category: a.MEDIA, tags: ["music", "audio", "round"], codepoint: 58478, published_in: 1, updated_in: 1 }, { name: "storefront", pascal_name: "Storefront", categories: [e.COMMERCE, e.MAP], figma_category: a.COMMERCE, tags: ["shops", "shopping", "markets", "stores", "buildings", "places", "locations"], codepoint: 58480, published_in: 1, updated_in: 1 }, { name: "strategy", pascal_name: "Strategy", categories: [e.GAMES, e.FINANCE], figma_category: a.GAMES, tags: ["sports", "strategem", "plan", "tic-tac-toe"], codepoint: 59962, published_in: 1.4, updated_in: 1.4 }, { name: "stripe-logo", pascal_name: "StripeLogo", categories: [e.BRAND, e.COMMERCE, e.FINANCE], figma_category: a.BRAND, tags: ["payment"], codepoint: 59032, published_in: 1.3, updated_in: 1.3 }, { name: "student", pascal_name: "Student", categories: [e.PEOPLE], figma_category: a.EDUCATION, tags: ["pupil", "graduate", "classroom", "teacher", "education", "school", "college", "university"], codepoint: 59198, published_in: 1.3, updated_in: 1.3 }, { name: "subset-of", pascal_name: "SubsetOf", categories: [e.FINANCE, e.DEVELOPMENT], figma_category: a.FINANCE, tags: ["*new*", "\u2286", "subset of", "set", "member", "mathematics", "arithmetic", "calculator"], codepoint: 60864, published_in: 2.1, updated_in: 2.1 }, { name: "subset-proper-of", pascal_name: "SubsetProperOf", categories: [e.FINANCE, e.DEVELOPMENT], figma_category: a.FINANCE, tags: ["*new*", "\u2282", "proper subset of", "set", "member", "mathematics", "arithmetic", "calculator"], codepoint: 60854, published_in: 2.1, updated_in: 2.1 }, { name: "subtitles", pascal_name: "Subtitles", categories: [e.MEDIA], figma_category: a.MEDIA, tags: ["subtitles", "television", "tv", "transcribed", "transcription", "accessibility", "a11y"], codepoint: 57768, published_in: 2, updated_in: 2 }, { name: "subtitles-slash", pascal_name: "SubtitlesSlash", categories: [e.MEDIA], figma_category: a.MEDIA, tags: ["*new*", "subtitles", "television", "tv", "transcribed", "transcription", "accessibility", "a11y", "disabled"], codepoint: 57766, published_in: 2.1, updated_in: 2.1 }, { name: "subtract", pascal_name: "Subtract", categories: [e.DESIGN, e.EDITOR], figma_category: a.DESIGN, tags: ["boolean", "intersection", "combine", "split", "merge", "union"], codepoint: 60374, published_in: 2, updated_in: 2 }, { name: "subtract-square", pascal_name: "SubtractSquare", categories: [e.DESIGN, e.EDITOR], figma_category: a.DESIGN, tags: ["boolean", "intersection", "combine", "split", "merge", "union"], codepoint: 60372, published_in: 2, updated_in: 2 }, { name: "subway", pascal_name: "Subway", categories: [e.MAP, e.OBJECTS], figma_category: a.MAP, tags: ["*new*", "vehicles", "underground", "train", "tunnel", "metro", "light rail", "public transit", "transportation", "commuter", "traveling", "places", "locations"], codepoint: 58520, published_in: 2.1, updated_in: 2.1 }, { name: "suitcase", pascal_name: "Suitcase", categories: [e.OFFICE, e.OBJECTS], figma_category: a.MAP, tags: ["briefcase", "valise", "baggage", "folders", "portfolio"], codepoint: 58798, published_in: 1.1, updated_in: 1.1 }, { name: "suitcase-rolling", pascal_name: "SuitcaseRolling", categories: [e.MAP, e.OBJECTS], figma_category: a.MAP, tags: ["suitcase", "luggage", "travel", "transportation"], codepoint: 59824, published_in: 2, updated_in: 2 }, { name: "suitcase-simple", pascal_name: "SuitcaseSimple", categories: [e.OFFICE, e.OBJECTS], figma_category: a.MAP, tags: ["briefcase", "valise", "baggage", "folders", "portfolio"], codepoint: 58800, published_in: 1.1, updated_in: 1.1 }, { name: "sun", pascal_name: "Sun", categories: [e.NATURE, e.SYSTEM, e.WEATHER], figma_category: a.WEATHER, tags: ["day", "daytime", "daylight", "clear", "sunny", "sunshine", "light mode", "brightness", "lighten", "brighten"], codepoint: 58482, published_in: 1, updated_in: 1 }, { name: "sun-dim", pascal_name: "SunDim", categories: [e.NATURE, e.SYSTEM, e.WEATHER], figma_category: a.WEATHER, tags: ["day", "daytime", "daylight", "clear", "sunny", "sunshine", "light mode", "brightness", "darken"], codepoint: 58484, published_in: 1, updated_in: 1 }, { name: "sun-horizon", pascal_name: "SunHorizon", categories: [e.NATURE, e.WEATHER], figma_category: a.WEATHER, tags: ["day", "daytime", "daylight", "clear", "sunny", "sunshine", "sunrise", "sunset"], codepoint: 58806, published_in: 1.1, updated_in: 1.1 }, { name: "sunglasses", pascal_name: "Sunglasses", categories: [e.HEALTH, e.OBJECTS], figma_category: a.COMMERCE, tags: ["vision", "sun", "spectacles"], codepoint: 59414, published_in: 1.4, updated_in: 1.4 }, { name: "superset-of", pascal_name: "SupersetOf", categories: [e.FINANCE, e.DEVELOPMENT], figma_category: a.FINANCE, tags: ["*new*", "\u2287", "superset of", "set", "member", "mathematics", "arithmetic", "calculator"], codepoint: 60856, published_in: 2.1, updated_in: 2.1 }, { name: "superset-proper-of", pascal_name: "SupersetProperOf", categories: [e.FINANCE, e.DEVELOPMENT], figma_category: a.FINANCE, tags: ["*new*", "\u2283", "proper superset of", "set", "member", "mathematics", "arithmetic", "calculator"], codepoint: 60852, published_in: 2.1, updated_in: 2.1 }, { name: "swap", pascal_name: "Swap", categories: [e.DESIGN, e.EDITOR], figma_category: a.SYSTEM, tags: ["layers", "replace", "exchange", "reverse"], codepoint: 59452, published_in: 1.3, updated_in: 1.3 }, { name: "swatches", pascal_name: "Swatches", categories: [e.DESIGN, e.EDITOR, e.OBJECTS], figma_category: a.DESIGN, tags: ["colors", "color picker", "samples", "pantone"], codepoint: 58808, published_in: 1.1, updated_in: 1.1 }, { name: "swimming-pool", pascal_name: "SwimmingPool", categories: [e.HEALTH, e.MAP, e.GAMES], figma_category: a.MAP, tags: ["swim", "sports", "exercise", "olympics", "aquatics"], codepoint: 60598, published_in: 2, updated_in: 2 }, { name: "sword", pascal_name: "Sword", categories: [e.GAMES, e.OBJECTS], figma_category: a.GAMES, tags: ["weapon", "knife", "dagger", "gladius", "video games", "rpg", "gaming", "war"], codepoint: 58810, published_in: 1.1, updated_in: 1.1 }, { name: "synagogue", pascal_name: "Synagogue", categories: [e.MAP], figma_category: a.MAP, tags: ["jewish", "judaism", "temple", "religion", "worship"], codepoint: 60652, published_in: 2, updated_in: 2 }, { name: "syringe", pascal_name: "Syringe", categories: [e.HEALTH], figma_category: a.HEALTH, tags: ["needle", "hypodermic", "vaccine", "medicine", "doctor", "shot", "hospital"], codepoint: 59752, published_in: 1.4, updated_in: 1.4 }, { name: "t-shirt", pascal_name: "TShirt", categories: [e.OBJECTS, e.COMMERCE], figma_category: a.COMMERCE, tags: ["clothes", "clothing"], codepoint: 58992, published_in: 1.2, updated_in: 1.2 }, { name: "table", pascal_name: "Table", categories: [e.FINANCE, e.OFFICE, e.EDITOR], figma_category: a.FINANCE, tags: ["tables", "tabular", "speadsheets", "excel", "grid", "form"], codepoint: 58486, published_in: 1, updated_in: 1 }, { name: "tabs", pascal_name: "Tabs", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["*updated*", "browser", "window", "folders", "files"], codepoint: 59256, published_in: 1.4, updated_in: 2.1 }, { name: "tag", pascal_name: "Tag", categories: [e.COMMERCE, e.DEVELOPMENT, e.OBJECTS], figma_category: a.COMMERCE, tags: ["tags", "hashtag", "labels", "sale", "sell", "price", "discount"], codepoint: 58488, published_in: 1, updated_in: 1 }, { name: "tag-chevron", pascal_name: "TagChevron", categories: [e.COMMERCE, e.DEVELOPMENT, e.OBJECTS], figma_category: a.COMMERCE, tags: ["tags", "hashtag", "labels", "sale"], codepoint: 58994, published_in: 1.2, updated_in: 1.2 }, { name: "tag-simple", pascal_name: "TagSimple", categories: [e.COMMERCE, e.DEVELOPMENT, e.OBJECTS], figma_category: a.COMMERCE, tags: ["tags", "hashtag", "labels", "sale", "sell", "price", "discount"], codepoint: 58490, published_in: 1, updated_in: 1 }, { name: "target", pascal_name: "Target", categories: [e.MAP, e.OBJECTS], figma_category: a.GAMES, tags: ["bullseye", "radar", "archery", "accuracy", "precision"], codepoint: 58492, published_in: 1, updated_in: 1 }, { name: "taxi", pascal_name: "Taxi", categories: [e.MAP, e.OBJECTS], figma_category: a.MAP, tags: ["*updated*", "vehicles", "cars", "automobiles", "livery", "limousine", "uber"], codepoint: 59650, published_in: 1.4, updated_in: 2.1 }, { name: "tea-bag", pascal_name: "TeaBag", categories: [e.COMMERCE, e.MAP, e.OBJECTS], figma_category: a.COMMERCE, tags: ["*new*", "drinks", "beverages", "sachet", "caffeine", "places", "locations", "bars", "restaurants", "food", "dining"], codepoint: 59622, published_in: 2.1, updated_in: 2.1 }, { name: "telegram-logo", pascal_name: "TelegramLogo", categories: [e.BRAND, e.COMMUNICATION], figma_category: a.BRAND, tags: ["logos", "messages", "messaging"], codepoint: 58812, published_in: 1.1, updated_in: 1.1 }, { name: "television", pascal_name: "Television", categories: [e.SYSTEM, e.OBJECTS], figma_category: a.MEDIA, tags: ["screen", "tv", "displays"], codepoint: 59220, published_in: 1.3, updated_in: 1.3 }, { name: "television-simple", pascal_name: "TelevisionSimple", categories: [e.SYSTEM, e.OBJECTS], figma_category: a.MEDIA, tags: ["*updated*", "screen", "tv", "displays"], codepoint: 60134, published_in: 1.3, updated_in: 2.1 }, { name: "tennis-ball", pascal_name: "TennisBall", categories: [e.GAMES, e.HEALTH, e.OBJECTS], figma_category: a.GAMES, tags: ["sports", "mlb"], codepoint: 59168, published_in: 1.3, updated_in: 1.4 }, { name: "tent", pascal_name: "Tent", categories: [e.HEALTH, e.OBJECTS, e.NATURE, e.MAP], figma_category: a.MAP, tags: ["camping", "outdoors", "tarp"], codepoint: 59578, published_in: 2, updated_in: 2 }, { name: "terminal", pascal_name: "Terminal", categories: [e.DEVELOPMENT, e.SYSTEM], figma_category: a.DEVELOPMENT, tags: ["command line", "cli", "bash", "shell", "caret", "console"], codepoint: 58494, published_in: 1, updated_in: 1 }, { name: "terminal-window", pascal_name: "TerminalWindow", categories: [e.DEVELOPMENT, e.SYSTEM], figma_category: a.DEVELOPMENT, tags: ["command line", "cli", "bash", "shell", "caret", "console"], codepoint: 60136, published_in: 1.3, updated_in: 1.3 }, { name: "test-tube", pascal_name: "TestTube", categories: [e.DEVELOPMENT, e.NATURE, e.HEALTH, e.OBJECTS], figma_category: a.HEALTH, tags: ["science", "chemistry", "experiment", "vial"], codepoint: 59296, published_in: 1.3, updated_in: 1.3 }, { name: "text-a-underline", pascal_name: "TextAUnderline", categories: [e.DESIGN, e.EDITOR], figma_category: a.DESIGN, tags: ["typography", "typeface", "print", "font", "underscore", "emphasis"], codepoint: 60724, published_in: 2, updated_in: 2 }, { name: "text-aa", pascal_name: "TextAa", categories: [e.DESIGN, e.EDITOR], figma_category: a.OFFICE, tags: ["typography", "typeface", "print", "font"], codepoint: 59118, published_in: 1.3, updated_in: 1.3 }, { name: "text-align-center", pascal_name: "TextAlignCenter", categories: [e.DESIGN, e.EDITOR], figma_category: a.OFFICE, tags: ["*updated*", "typography", "print", "font", "alignment", "centered"], codepoint: 58496, published_in: 1, updated_in: 2.1 }, { name: "text-align-justify", pascal_name: "TextAlignJustify", categories: [e.DESIGN, e.EDITOR], figma_category: a.OFFICE, tags: ["*updated*", "typography", "print", "font", "alignment", "justified"], codepoint: 58498, published_in: 1, updated_in: 2.1 }, { name: "text-align-left", pascal_name: "TextAlignLeft", categories: [e.DESIGN, e.EDITOR], figma_category: a.OFFICE, tags: ["*updated*", "typography", "print", "font", "alignment", "flush left"], codepoint: 58500, published_in: 1, updated_in: 2.1 }, { name: "text-align-right", pascal_name: "TextAlignRight", categories: [e.DESIGN, e.EDITOR], figma_category: a.OFFICE, tags: ["*updated*", "typography", "print", "font", "alignment", "flush right"], codepoint: 58502, published_in: 1, updated_in: 2.1 }, { name: "text-b", pascal_name: "TextB", alias: { name: "text-bolder", pascal_name: "TextBolder" }, categories: [e.DESIGN, e.EDITOR], figma_category: a.OFFICE, tags: ["typography", "typeface", "print", "font", "bold", "boldface", "emphasis"], codepoint: 58814, published_in: 1.1, updated_in: 1.1 }, { name: "text-columns", pascal_name: "TextColumns", categories: [e.DESIGN, e.EDITOR], figma_category: a.OFFICE, tags: ["*updated*", "typography", "print", "font", "alignment", "article"], codepoint: 60566, published_in: 2, updated_in: 2.1 }, { name: "text-h", pascal_name: "TextH", categories: [e.DESIGN, e.EDITOR], figma_category: a.OFFICE, tags: ["heading", "typography", "print"], codepoint: 59066, published_in: 1.3, updated_in: 1.3 }, { name: "text-h-five", pascal_name: "TextHFive", categories: [e.DESIGN, e.EDITOR], figma_category: a.OFFICE, tags: ["heading", "h5", "typography", "print"], codepoint: 59076, published_in: 1.3, updated_in: 1.3 }, { name: "text-h-four", pascal_name: "TextHFour", categories: [e.DESIGN, e.EDITOR], figma_category: a.OFFICE, tags: ["*updated*", "heading", "h4", "typography", "print"], codepoint: 59074, published_in: 1.3, updated_in: 2.1 }, { name: "text-h-one", pascal_name: "TextHOne", categories: [e.DESIGN, e.EDITOR], figma_category: a.OFFICE, tags: ["heading", "h1", "typography", "print"], codepoint: 59068, published_in: 1.3, updated_in: 1.3 }, { name: "text-h-six", pascal_name: "TextHSix", categories: [e.DESIGN, e.EDITOR], figma_category: a.OFFICE, tags: ["heading", "h6", "typography", "print"], codepoint: 59078, published_in: 1.3, updated_in: 1.3 }, { name: "text-h-three", pascal_name: "TextHThree", categories: [e.DESIGN, e.EDITOR], figma_category: a.OFFICE, tags: ["heading", "h3", "typography", "print"], codepoint: 59072, published_in: 1.3, updated_in: 1.3 }, { name: "text-h-two", pascal_name: "TextHTwo", categories: [e.DESIGN, e.EDITOR], figma_category: a.OFFICE, tags: ["heading", "h2", "typography", "print"], codepoint: 59070, published_in: 1.3, updated_in: 1.3 }, { name: "text-indent", pascal_name: "TextIndent", categories: [e.DESIGN, e.EDITOR], figma_category: a.OFFICE, tags: ["*updated*", "alignment", "tab", "menu"], codepoint: 59934, published_in: 1.4, updated_in: 2.1 }, { name: "text-italic", pascal_name: "TextItalic", categories: [e.DESIGN, e.EDITOR], figma_category: a.OFFICE, tags: ["typography", "typeface", "print", "font", "slant", "oblique", "stress", "emphasis", "calligraphy"], codepoint: 58816, published_in: 1.1, updated_in: 1.1 }, { name: "text-outdent", pascal_name: "TextOutdent", categories: [e.DESIGN, e.EDITOR], figma_category: a.OFFICE, tags: ["*updated*", "alignment", "tab", "unindent", "dedent", "menu"], codepoint: 59932, published_in: 1.4, updated_in: 2.1 }, { name: "text-strikethrough", pascal_name: "TextStrikethrough", categories: [e.DESIGN, e.EDITOR], figma_category: a.OFFICE, tags: ["typography", "typeface", "print", "font", "struck", "remove", "delete", "change"], codepoint: 58818, published_in: 1.1, updated_in: 1.1 }, { name: "text-subscript", pascal_name: "TextSubscript", categories: [e.DESIGN, e.EDITOR, e.FINANCE], figma_category: a.OFFICE, tags: ["*new*", "typography", "font", "formatting", "mathematics", "power", "exponent", "calculator"], codepoint: 60568, published_in: 2.1, updated_in: 2.1 }, { name: "text-superscript", pascal_name: "TextSuperscript", categories: [e.DESIGN, e.EDITOR, e.FINANCE], figma_category: a.OFFICE, tags: ["*new*", "typography", "font", "formatting", "mathematics", "calculator"], codepoint: 60570, published_in: 2.1, updated_in: 2.1 }, { name: "text-t", pascal_name: "TextT", categories: [e.DESIGN, e.EDITOR], figma_category: a.OFFICE, tags: ["typography", "typeface", "print", "font"], codepoint: 58506, published_in: 1, updated_in: 1 }, { name: "text-t-slash", pascal_name: "TextTSlash", categories: [e.DESIGN, e.EDITOR], figma_category: a.OFFICE, tags: ["*new*", "typography", "typeface", "print", "font", "formatting", "clear"], codepoint: 58504, published_in: 2.1, updated_in: 2.1 }, { name: "text-underline", pascal_name: "TextUnderline", categories: [e.DESIGN, e.EDITOR], figma_category: a.OFFICE, tags: ["typography", "typeface", "print", "font", "underscore", "emphasis"], codepoint: 58820, published_in: 1.1, updated_in: 1.1 }, { name: "textbox", pascal_name: "Textbox", categories: [e.EDITOR, e.SYSTEM], figma_category: a.OFFICE, tags: ["input", "cursor", "field"], codepoint: 60170, published_in: 1.4, updated_in: 1.4 }, { name: "thermometer", pascal_name: "Thermometer", categories: [e.WEATHER, e.HEALTH, e.OBJECTS], figma_category: a.WEATHER, tags: ["meteorology", "temperature", "degrees", "\xB0", "celcius", "centigrade", "kelvin", "fahrenheit", "hot", "warm", "cold"], codepoint: 58822, published_in: 1.1, updated_in: 1.1 }, { name: "thermometer-cold", pascal_name: "ThermometerCold", categories: [e.WEATHER, e.HEALTH, e.OBJECTS], figma_category: a.WEATHER, tags: ["meteorology", "temperature", "degrees", "\xB0", "celcius", "centigrade", "kelvin", "fahrenheit"], codepoint: 58824, published_in: 1.1, updated_in: 1.1 }, { name: "thermometer-hot", pascal_name: "ThermometerHot", categories: [e.WEATHER, e.HEALTH, e.OBJECTS], figma_category: a.WEATHER, tags: ["meteorology", "temperature", "degrees", "\xB0", "celcius", "centigrade", "kelvin", "fahrenheit", "warm"], codepoint: 58826, published_in: 1.1, updated_in: 1.1 }, { name: "thermometer-simple", pascal_name: "ThermometerSimple", categories: [e.WEATHER, e.HEALTH, e.OBJECTS], figma_category: a.WEATHER, tags: ["meteorology", "temperature", "degrees", "\xB0", "celcius", "centigrade", "kelvin", "fahrenheit", "hot", "warm", "cold"], codepoint: 58828, published_in: 1.1, updated_in: 1.1 }, { name: "threads-logo", pascal_name: "ThreadsLogo", categories: [e.BRAND, e.COMMUNICATION], figma_category: a.BRAND, tags: ["*new*", "meta", "instagram", "social media"], codepoint: 60830, published_in: 2.1, updated_in: 2.1 }, { name: "three-d", pascal_name: "ThreeD", categories: [e.MEDIA, e.DEVELOPMENT], figma_category: a.MEDIA, tags: ["*new*", "3d", "cad", "model"], codepoint: 59994, published_in: 2.1, updated_in: 2.1 }, { name: "thumbs-down", pascal_name: "ThumbsDown", categories: [e.COMMUNICATION, e.PEOPLE], figma_category: a.COMMUNICATION, tags: ["dislike", "hate", "emoji", "no"], codepoint: 58508, published_in: 1, updated_in: 1 }, { name: "thumbs-up", pascal_name: "ThumbsUp", categories: [e.COMMUNICATION, e.PEOPLE], figma_category: a.COMMUNICATION, tags: ["like", "love", "favorited", "favorites", "emoji", "yes"], codepoint: 58510, published_in: 1, updated_in: 1 }, { name: "ticket", pascal_name: "Ticket", categories: [e.COMMERCE, e.MAP, e.OBJECTS], figma_category: a.COMMERCE, tags: ["ticketstub", "movie ticket", "entry", "admissions", "events"], codepoint: 58512, published_in: 1, updated_in: 1 }, { name: "tidal-logo", pascal_name: "TidalLogo", categories: [e.BRAND, e.MEDIA], figma_category: a.BRAND, tags: ["music", "logos"], codepoint: 60700, published_in: 2, updated_in: 2 }, { name: "tiktok-logo", pascal_name: "TiktokLogo", categories: [e.BRAND, e.COMMUNICATION], figma_category: a.BRAND, tags: ["logos", "social media"], codepoint: 60146, published_in: 1.3, updated_in: 1.3 }, { name: "tilde", pascal_name: "Tilde", categories: [e.FINANCE, e.DEVELOPMENT], figma_category: a.FINANCE, tags: ["*new*", "~", "\u223C", "proportional", "comparison", "mathematics", "arithmetic", "calculator"], codepoint: 60840, published_in: 2.1, updated_in: 2.1 }, { name: "timer", pascal_name: "Timer", categories: [e.SYSTEM, e.OBJECTS], figma_category: a.TIME, tags: ["clock", "alarm", "schedule", "events", "stopwatch", "sports"], codepoint: 58514, published_in: 1, updated_in: 1 }, { name: "tip-jar", pascal_name: "TipJar", categories: [e.COMMERCE, e.FINANCE, e.OBJECTS], figma_category: a.COMMERCE, tags: ["*new*", "give", "deposit", "donation", "savings", "money"], codepoint: 59360, published_in: 2.1, updated_in: 2.1 }, { name: "tipi", pascal_name: "Tipi", categories: [e.NATURE, e.OBJECTS, e.MAP], figma_category: a.MAP, tags: ["teepee", "lodge", "tent", "outdoors", "camping", "tarp"], codepoint: 60720, published_in: 2, updated_in: 2 }, { name: "tire", pascal_name: "Tire", categories: [e.COMMERCE, e.OBJECTS], figma_category: a.COMMERCE, tags: ["*new*", "wheel", "vehicles", "transportation"], codepoint: 60882, published_in: 2.1, updated_in: 2.1 }, { name: "toggle-left", pascal_name: "ToggleLeft", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["switch", "controls", "settings", "preferences"], codepoint: 58996, published_in: 1.2, updated_in: 1.2 }, { name: "toggle-right", pascal_name: "ToggleRight", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["switch", "controls", "settings", "preferences"], codepoint: 58998, published_in: 1.2, updated_in: 1.2 }, { name: "toilet", pascal_name: "Toilet", categories: [e.HEALTH, e.OBJECTS], figma_category: a.HEALTH, tags: ["bathroom", "restroom", "lavatory", "water closet"], codepoint: 59290, published_in: 1.4, updated_in: 1.4 }, { name: "toilet-paper", pascal_name: "ToiletPaper", categories: [e.HEALTH, e.OBJECTS], figma_category: a.HEALTH, tags: ["bathroom", "restroom", "lavatory", "water closet"], codepoint: 59292, published_in: 1.3, updated_in: 1.3 }, { name: "toolbox", pascal_name: "Toolbox", categories: [e.OBJECTS, e.SYSTEM, e.COMMERCE], figma_category: a.COMMERCE, tags: ["tools", "carpentry", "construction"], codepoint: 60576, published_in: 2, updated_in: 2 }, { name: "tooth", pascal_name: "Tooth", categories: [e.HEALTH], figma_category: a.HEALTH, tags: ["teeth", "dentistry", "medical", "medicine", "doctor", "cavity"], codepoint: 59852, published_in: 2, updated_in: 2 }, { name: "tornado", pascal_name: "Tornado", categories: [e.WEATHER], figma_category: a.WEATHER, tags: ["*new*", "meteorology", "twister", "storm", "wind", "disaster"], codepoint: 59532, published_in: 2.1, updated_in: 2.1 }, { name: "tote", pascal_name: "Tote", categories: [e.COMMERCE, e.OBJECTS], figma_category: a.COMMERCE, tags: ["suitcases", "valises", "baggage", "tote-bag", "portfolios"], codepoint: 58516, published_in: 1, updated_in: 1 }, { name: "tote-simple", pascal_name: "ToteSimple", categories: [e.COMMERCE, e.OBJECTS], figma_category: a.COMMERCE, tags: ["suitcases", "valises", "baggage", "tote-bag", "portfolios"], codepoint: 59e3, published_in: 1.2, updated_in: 1.2 }, { name: "towel", pascal_name: "Towel", categories: [e.COMMERCE, e.OBJECTS], figma_category: a.COMMERCE, tags: ["*new*", "clothing", "linen", "hotel", "beach", "pool", "swimming", "shower", "bath"], codepoint: 60902, published_in: 2.1, updated_in: 2.1 }, { name: "tractor", pascal_name: "Tractor", categories: [e.COMMERCE, e.OBJECTS], figma_category: a.COMMERCE, tags: ["*new*", "vehicles", "farmer", "field", "farming", "agriculture"], codepoint: 60526, published_in: 2.1, updated_in: 2.1 }, { name: "trademark", pascal_name: "Trademark", categories: [e.COMMERCE], figma_category: a.COMMERCE, tags: ["tm", "\xAE", "\u2122", "intellectual property"], codepoint: 59888, published_in: 2, updated_in: 2 }, { name: "trademark-registered", pascal_name: "TrademarkRegistered", categories: [e.COMMERCE], figma_category: a.COMMERCE, tags: ["\xAE", "\u2122", "intellectual property"], codepoint: 58356, published_in: 1.4, updated_in: 1.4 }, { name: "traffic-cone", pascal_name: "TrafficCone", categories: [e.MAP], figma_category: a.MAP, tags: ["pylon", "safety", "transit", "transportation"], codepoint: 59816, published_in: 1.4, updated_in: 1.4 }, { name: "traffic-sign", pascal_name: "TrafficSign", categories: [e.MAP], figma_category: a.MAP, tags: ["road signs", "transit", "transportation"], codepoint: 59002, published_in: 1.2, updated_in: 1.2 }, { name: "traffic-signal", pascal_name: "TrafficSignal", categories: [e.MAP], figma_category: a.MAP, tags: ["stop light", "safety", "transit", "transportation"], codepoint: 59818, published_in: 1.4, updated_in: 1.4 }, { name: "train", pascal_name: "Train", categories: [e.MAP, e.OBJECTS], figma_category: a.MAP, tags: ["vehicles", "subway", "light rail", "public transit", "transportation", "commuter", "traveling", "places", "locations"], codepoint: 58518, published_in: 1, updated_in: 1 }, { name: "train-regional", pascal_name: "TrainRegional", categories: [e.MAP, e.OBJECTS], figma_category: a.MAP, tags: ["vehicles", "subway", "railroad", "public transit", "transportation", "commuter", "freight", "shipping", "traveling", "places", "locations"], codepoint: 58526, published_in: 1, updated_in: 1 }, { name: "train-simple", pascal_name: "TrainSimple", categories: [e.MAP, e.OBJECTS], figma_category: a.MAP, tags: ["vehicles", "subway", "light rail", "public transit", "transportation", "commuter", "traveling", "places", "locations"], codepoint: 58528, published_in: 1, updated_in: 1 }, { name: "tram", pascal_name: "Tram", categories: [e.MAP, e.OBJECTS], figma_category: a.MAP, tags: ["vehicles", "subway", "railroad", "public transit", "transportation", "commuter", "light rail", "shipping", "traveling", "places", "locations"], codepoint: 59884, published_in: 2, updated_in: 2 }, { name: "translate", pascal_name: "Translate", categories: [e.COMMUNICATION, e.SYSTEM], figma_category: a.COMMUNICATION, tags: ["translation", "languages", "internationalization", "i18n", "speech"], codepoint: 58530, published_in: 1, updated_in: 1 }, { name: "trash", pascal_name: "Trash", categories: [e.OFFICE, e.SYSTEM], figma_category: a.OFFICE, tags: ["garbage", "remove", "delete", "destroy", "recycle", "recycling"], codepoint: 58534, published_in: 1, updated_in: 1 }, { name: "trash-simple", pascal_name: "TrashSimple", categories: [e.OFFICE, e.SYSTEM], figma_category: a.OFFICE, tags: ["garbage", "remove", "delete", "destroy", "recycle", "recycling"], codepoint: 58536, published_in: 1, updated_in: 1 }, { name: "tray", pascal_name: "Tray", categories: [e.OFFICE, e.COMMUNICATION, e.SYSTEM], figma_category: a.OFFICE, tags: ["inbox", "mailbox", "bin"], codepoint: 58538, published_in: 1, updated_in: 1 }, { name: "tray-arrow-down", pascal_name: "TrayArrowDown", alias: { name: "archive-tray", pascal_name: "ArchiveTray" }, categories: [e.OFFICE, e.SYSTEM], figma_category: a.OFFICE, tags: ["inbox", "saved", "saving", "archived", "archiving", "archival", "downloaded", "downloading"], codepoint: 57360, published_in: 1, updated_in: 1 }, { name: "tray-arrow-up", pascal_name: "TrayArrowUp", categories: [e.OFFICE, e.SYSTEM], figma_category: a.OFFICE, tags: ["*new*", "outbox", "archival", "unarchive", "uploaded", "uploading"], codepoint: 61010, published_in: 2.1, updated_in: 2.1 }, { name: "treasure-chest", pascal_name: "TreasureChest", categories: [e.GAMES, e.OBJECTS], figma_category: a.GAMES, tags: ["*new*", "loot", "lootbox", "inventory", "rewards", "gaming", "pirate"], codepoint: 60898, published_in: 2.1, updated_in: 2.1 }, { name: "tree", pascal_name: "Tree", categories: [e.NATURE], figma_category: a.WEATHER, tags: ["plants", "branches", "leaves", "green", "environmental"], codepoint: 59098, published_in: 1.3, updated_in: 1.3 }, { name: "tree-evergreen", pascal_name: "TreeEvergreen", categories: [e.NATURE], figma_category: a.WEATHER, tags: ["plants", "branches", "leaves", "pine", "conifer", "green", "environmental"], codepoint: 59100, published_in: 1.3, updated_in: 1.3 }, { name: "tree-palm", pascal_name: "TreePalm", categories: [e.NATURE], figma_category: a.GAMES, tags: ["tropical", "beach", "plants", "branches", "leaves", "green", "environmental"], codepoint: 59674, published_in: 2, updated_in: 2 }, { name: "tree-structure", pascal_name: "TreeStructure", categories: [e.DEVELOPMENT, e.OFFICE], figma_category: a.DEVELOPMENT, tags: ["data structures", "family tree", "genealogy", "hierarchy", "taxonomy", "charts", "flowchart"], codepoint: 59004, published_in: 1.2, updated_in: 1.2 }, { name: "tree-view", pascal_name: "TreeView", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["*new*", "hierarchy"], codepoint: 61e3, published_in: 2.1, updated_in: 2.1 }, { name: "trend-down", pascal_name: "TrendDown", categories: [e.FINANCE, e.OFFICE], figma_category: a.FINANCE, tags: ["graphs", "graphing", "charts", "statistics", "analyze", "analysis", "decrease", "arrows"], codepoint: 58540, published_in: 1, updated_in: 1 }, { name: "trend-up", pascal_name: "TrendUp", categories: [e.FINANCE, e.OFFICE], figma_category: a.FINANCE, tags: ["graphs", "graphing", "charts", "statistics", "analyze", "analysis", "increase", "arrows"], codepoint: 58542, published_in: 1, updated_in: 1 }, { name: "triangle", pascal_name: "Triangle", categories: [e.DESIGN], figma_category: a.DESIGN, tags: ["3", "shapes", "polygons"], codepoint: 58544, published_in: 1, updated_in: 1 }, { name: "triangle-dashed", pascal_name: "TriangleDashed", categories: [e.DESIGN], figma_category: a.DESIGN, tags: ["*new*", "3", "shapes", "polygons", "missing"], codepoint: 58546, published_in: 2.1, updated_in: 2.1 }, { name: "trolley", pascal_name: "Trolley", categories: [e.OFFICE, e.OBJECTS], figma_category: a.MAP, tags: ["*new*", "airport", "briefcase", "valise", "baggage"], codepoint: 58802, published_in: 2.1, updated_in: 2.1 }, { name: "trolley-suitcase", pascal_name: "TrolleySuitcase", categories: [e.OFFICE, e.OBJECTS], figma_category: a.MAP, tags: ["*new*", "airport", "briefcase", "valise", "baggage"], codepoint: 58804, published_in: 2.1, updated_in: 2.1 }, { name: "trophy", pascal_name: "Trophy", categories: [e.GAMES, e.OBJECTS], figma_category: a.GAMES, tags: ["ribbons", "medals", "winning", "victory", "awards", "prize"], codepoint: 59006, published_in: 1.2, updated_in: 1.2 }, { name: "truck", pascal_name: "Truck", categories: [e.COMMERCE, e.MAP, e.OBJECTS], figma_category: a.MAP, tags: ["trucks", "cars", "vehicles", "automobile", "shipping", "delivery"], codepoint: 58548, published_in: 1, updated_in: 1 }, { name: "truck-trailer", pascal_name: "TruckTrailer", categories: [e.COMMERCE, e.MAP, e.OBJECTS], figma_category: a.COMMERCE, tags: ["*new*", "vehicles", "automobile", "shipping", "tractor", "semi"], codepoint: 58550, published_in: 2.1, updated_in: 2.1 }, { name: "tumblr-logo", pascal_name: "TumblrLogo", categories: [e.BRAND, e.COMMUNICATION], figma_category: a.BRAND, tags: ["*new*", "social media", "logos"], codepoint: 59604, published_in: 2.1, updated_in: 2.1 }, { name: "twitch-logo", pascal_name: "TwitchLogo", categories: [e.BRAND, e.COMMUNICATION, e.GAMES], figma_category: a.BRAND, tags: ["logos", "streaming", "livestream", "gaming", "video games", "social media"], codepoint: 58830, published_in: 1.1, updated_in: 1.1 }, { name: "twitter-logo", pascal_name: "TwitterLogo", categories: [e.BRAND, e.COMMUNICATION], figma_category: a.BRAND, tags: ["logos", "social media", "tweets", "birds"], codepoint: 58554, published_in: 1, updated_in: 1 }, { name: "umbrella", pascal_name: "Umbrella", categories: [e.OBJECTS, e.WEATHER], figma_category: a.WEATHER, tags: ["raining", "rainy", "insurance"], codepoint: 59012, published_in: 1.2, updated_in: 1.2 }, { name: "umbrella-simple", pascal_name: "UmbrellaSimple", categories: [e.OBJECTS, e.WEATHER], figma_category: a.WEATHER, tags: ["raining", "rainy", "insurance"], codepoint: 59014, published_in: 1.2, updated_in: 1.2 }, { name: "union", pascal_name: "Union", categories: [e.FINANCE, e.DEVELOPMENT], figma_category: a.FINANCE, tags: ["*new*", "\u222A", "union", "set", "member", "mathematics", "arithmetic", "calculator"], codepoint: 60862, published_in: 2.1, updated_in: 2.1 }, { name: "unite", pascal_name: "Unite", categories: [e.DESIGN, e.EDITOR], figma_category: a.DESIGN, tags: ["*updated*", "round", "join", "union", "merge", "combine", "intersecting", "intersection"], codepoint: 59518, published_in: 2, updated_in: 2.1 }, { name: "unite-square", pascal_name: "UniteSquare", categories: [e.DESIGN, e.EDITOR], figma_category: a.DESIGN, tags: ["join", "union", "merge", "combine", "intersecting", "intersection"], codepoint: 59512, published_in: 2, updated_in: 2 }, { name: "upload", pascal_name: "Upload", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["saved", "saving", "archived", "archiving", "archival", "uploaded", "uploading", "hard drive", "disk"], codepoint: 58558, published_in: 1, updated_in: 1.4 }, { name: "upload-simple", pascal_name: "UploadSimple", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["*updated*", "saved", "saving", "archived", "archiving", "archival", "uploaded", "uploading", "hard drive", "disk"], codepoint: 58560, published_in: 1, updated_in: 2.1 }, { name: "usb", pascal_name: "Usb", categories: [e.OBJECTS, e.SYSTEM], figma_category: a.SYSTEM, tags: ["serial", "port", "plug", "peripheral", "device"], codepoint: 59734, published_in: 2, updated_in: 2 }, { name: "user", pascal_name: "User", categories: [e.PEOPLE], figma_category: a.PEOPLE, tags: ["person", "users", "profile", "account", "contact", "login"], codepoint: 58562, published_in: 1, updated_in: 1 }, { name: "user-check", pascal_name: "UserCheck", categories: [e.PEOPLE], figma_category: a.PEOPLE, tags: ["*new*", "person", "users", "profile", "account", "contact", "login", "verified"], codepoint: 60154, published_in: 2.1, updated_in: 2.1 }, { name: "user-circle", pascal_name: "UserCircle", categories: [e.PEOPLE], figma_category: a.PEOPLE, tags: ["person", "users", "profile", "account", "contact", "login"], codepoint: 58564, published_in: 1, updated_in: 1 }, { name: "user-circle-check", pascal_name: "UserCircleCheck", categories: [e.PEOPLE], figma_category: a.PEOPLE, tags: ["*new*", "person", "users", "profile", "account", "contact", "login", "verified"], codepoint: 60472, published_in: 2.1, updated_in: 2.1 }, { name: "user-circle-dashed", pascal_name: "UserCircleDashed", categories: [e.PEOPLE], figma_category: a.PEOPLE, tags: ["*new*", "person", "users", "profile", "account", "contact", "login", "pending", "missing", "removed"], codepoint: 60470, published_in: 2.1, updated_in: 2.1 }, { name: "user-circle-gear", pascal_name: "UserCircleGear", categories: [e.PEOPLE], figma_category: a.PEOPLE, tags: ["person", "users", "profile", "account", "contact", "settings", "preferences"], codepoint: 58566, published_in: 1, updated_in: 1 }, { name: "user-circle-minus", pascal_name: "UserCircleMinus", categories: [e.PEOPLE], figma_category: a.PEOPLE, tags: ["person", "users", "profile", "account", "contact", "delete", "remove", "-"], codepoint: 58568, published_in: 1, updated_in: 1 }, { name: "user-circle-plus", pascal_name: "UserCirclePlus", categories: [e.PEOPLE], figma_category: a.PEOPLE, tags: ["person", "users", "profile", "account", "contact", "add", "create", "+"], codepoint: 58570, published_in: 1, updated_in: 1 }, { name: "user-focus", pascal_name: "UserFocus", categories: [e.PEOPLE], figma_category: a.PEOPLE, tags: ["identification", "biometrics", "facial recognition", "profile", "person", "account", "autofocus"], codepoint: 59132, published_in: 1.3, updated_in: 1.3 }, { name: "user-gear", pascal_name: "UserGear", categories: [e.PEOPLE], figma_category: a.PEOPLE, tags: ["person", "users", "profile", "account", "contact", "settings", "preferences"], codepoint: 58572, published_in: 1, updated_in: 1 }, { name: "user-list", pascal_name: "UserList", categories: [e.PEOPLE], figma_category: a.PEOPLE, tags: ["person", "users", "profiles", "accounts", "members", "address book"], codepoint: 59196, published_in: 1.3, updated_in: 1.3 }, { name: "user-minus", pascal_name: "UserMinus", categories: [e.PEOPLE], figma_category: a.PEOPLE, tags: ["person", "users", "profile", "account", "contact", "delete", "remove", "-"], codepoint: 58574, published_in: 1, updated_in: 1 }, { name: "user-plus", pascal_name: "UserPlus", categories: [e.PEOPLE], figma_category: a.PEOPLE, tags: ["person", "users", "profile", "account", "contact", "add", "create", "+"], codepoint: 58576, published_in: 1, updated_in: 1 }, { name: "user-rectangle", pascal_name: "UserRectangle", categories: [e.PEOPLE], figma_category: a.PEOPLE, tags: ["person", "users", "profile", "account", "contact", "login"], codepoint: 58578, published_in: 1, updated_in: 1 }, { name: "user-sound", pascal_name: "UserSound", categories: [e.PEOPLE], figma_category: a.PEOPLE, tags: ["*new*", "person", "users", "profile", "speech", "speaking", "voice"], codepoint: 60584, published_in: 2.1, updated_in: 2.1 }, { name: "user-square", pascal_name: "UserSquare", categories: [e.PEOPLE], figma_category: a.PEOPLE, tags: ["person", "users", "profile", "account", "contact", "login"], codepoint: 58580, published_in: 1, updated_in: 1 }, { name: "user-switch", pascal_name: "UserSwitch", categories: [e.PEOPLE], figma_category: a.PEOPLE, tags: ["person", "users", "profile", "account", "login", "logout", "signin", "signout", "settings", "preferences"], codepoint: 59222, published_in: 1.4, updated_in: 1.4 }, { name: "users", pascal_name: "Users", categories: [e.PEOPLE], figma_category: a.PEOPLE, tags: ["user", "group", "team", "people", "profiles", "accounts", "contacts"], codepoint: 58582, published_in: 1, updated_in: 1 }, { name: "users-four", pascal_name: "UsersFour", categories: [e.PEOPLE], figma_category: a.PEOPLE, tags: ["user", "group", "team", "department", "community", "people", "profiles", "accounts", "contacts"], codepoint: 59020, published_in: 1.3, updated_in: 1.3 }, { name: "users-three", pascal_name: "UsersThree", categories: [e.PEOPLE], figma_category: a.PEOPLE, tags: ["user", "group", "team", "community", "people", "profiles", "accounts", "contacts"], codepoint: 59022, published_in: 1.3, updated_in: 1.3 }, { name: "van", pascal_name: "Van", categories: [e.MAP, e.OBJECTS], figma_category: a.MAP, tags: ["westfalia", "microbus", "vanagon", "cars", "vehicles", "automobile", "transit", "transportation", "traveling"], codepoint: 59430, published_in: 2, updated_in: 2 }, { name: "vault", pascal_name: "Vault", categories: [e.OBJECTS, e.SYSTEM, e.FINANCE], figma_category: a.SECURITY, tags: ["safe", "bank", "security", "secured", "authentication", "authenticated", "locked", "encrypted", "encryption"], codepoint: 59246, published_in: 1.4, updated_in: 1.4 }, { name: "vector-three", pascal_name: "VectorThree", categories: [e.ARROWS, e.DEVELOPMENT, e.DESIGN], figma_category: a.ARROWS, tags: ["*new*", "3d", "xyz", "cartesian", "coordinates", "plane", "volume", "dimensions", "mathematics"], codepoint: 61026, published_in: 2.1, updated_in: 2.1 }, { name: "vector-two", pascal_name: "VectorTwo", categories: [e.ARROWS, e.DEVELOPMENT, e.DESIGN], figma_category: a.ARROWS, tags: ["*new*", "2d", "xy", "cartesian", "coordinates", "plane", "dimensions", "mathematics"], codepoint: 61028, published_in: 2.1, updated_in: 2.1 }, { name: "vibrate", pascal_name: "Vibrate", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["audio", "volume", "viration", "ringer", "calls", "silent", "silenced"], codepoint: 58584, published_in: 1, updated_in: 1 }, { name: "video", pascal_name: "Video", categories: [e.PEOPLE], figma_category: a.EDUCATION, tags: ["training", "course", "education", "tutorial"], codepoint: 59200, published_in: 2, updated_in: 2 }, { name: "video-camera", pascal_name: "VideoCamera", categories: [e.MEDIA, e.SYSTEM, e.OBJECTS], figma_category: a.MEDIA, tags: ["videography", "films", "movies", "recording"], codepoint: 58586, published_in: 1, updated_in: 1 }, { name: "video-camera-slash", pascal_name: "VideoCameraSlash", categories: [e.MEDIA, e.SYSTEM], figma_category: a.MEDIA, tags: ["videography", "films", "movies", "recording", "disabled"], codepoint: 58588, published_in: 1, updated_in: 1 }, { name: "video-conference", pascal_name: "VideoConference", categories: [e.MEDIA, e.SYSTEM, e.COMMUNICATION], figma_category: a.MEDIA, tags: ["*new*", "video call", "zoom", "skype", "discord", "facetime", "meeting"], codepoint: 60878, published_in: 2.1, updated_in: 2.1 }, { name: "vignette", pascal_name: "Vignette", categories: [e.DESIGN], figma_category: a.DESIGN, tags: ["photography", "darkroom", "movie", "analog"], codepoint: 60322, published_in: 1.4, updated_in: 1.4 }, { name: "vinyl-record", pascal_name: "VinylRecord", categories: [e.MEDIA, e.OFFICE], figma_category: a.MEDIA, tags: ["recording", "audio", "album", "music", "ep", "lp"], codepoint: 60588, published_in: 2, updated_in: 2 }, { name: "virtual-reality", pascal_name: "VirtualReality", categories: [e.GAMES, e.MEDIA], figma_category: a.GAMES, tags: ["virtual reality", "vr", "headset", "metaverse"], codepoint: 59320, published_in: 2, updated_in: 2 }, { name: "virus", pascal_name: "Virus", categories: [e.HEALTH], figma_category: a.HEALTH, tags: ["germs", "disease", "illness"], codepoint: 59350, published_in: 2, updated_in: 2 }, { name: "visor", pascal_name: "Visor", categories: [e.DEVELOPMENT, e.MEDIA, e.OBJECTS], figma_category: a.MEDIA, tags: ["*new*", "goggles", "vision"], codepoint: 60970, published_in: 2.1, updated_in: 2.1 }, { name: "voicemail", pascal_name: "Voicemail", categories: [e.SYSTEM], figma_category: a.COMMUNICATION, tags: ["phonecalls", "missed", "recording", "telephone", "landline"], codepoint: 58590, published_in: 1, updated_in: 1 }, { name: "volleyball", pascal_name: "Volleyball", categories: [e.GAMES, e.HEALTH, e.OBJECTS], figma_category: a.GAMES, tags: ["sports"], codepoint: 59174, published_in: 1.3, updated_in: 1.3 }, { name: "wall", pascal_name: "Wall", categories: [e.OBJECTS, e.SYSTEM], figma_category: a.SECURITY, tags: ["firewall", "security", "secured", "blocks", "bricks"], codepoint: 59016, published_in: 1.2, updated_in: 1.4 }, { name: "wallet", pascal_name: "Wallet", categories: [e.COMMERCE, e.FINANCE, e.OBJECTS], figma_category: a.COMMERCE, tags: ["money", "payment", "paying", "purchase"], codepoint: 59018, published_in: 1.2, updated_in: 1.2 }, { name: "warehouse", pascal_name: "Warehouse", categories: [e.COMMERCE, e.MAP], figma_category: a.COMMERCE, tags: ["storage", "industry", "manufacture", "buildings", "places", "locations"], codepoint: 60628, published_in: 2, updated_in: 2 }, { name: "warning", pascal_name: "Warning", categories: [e.SYSTEM], figma_category: a.SECURITY, tags: ["alert", "danger", "dangerous", "caution", "errors"], codepoint: 58592, published_in: 1, updated_in: 1 }, { name: "warning-circle", pascal_name: "WarningCircle", categories: [e.SYSTEM], figma_category: a.SECURITY, tags: ["alert", "danger", "dangerous", "caution", "errors", "round"], codepoint: 58594, published_in: 1, updated_in: 1 }, { name: "warning-diamond", pascal_name: "WarningDiamond", categories: [e.SYSTEM], figma_category: a.SECURITY, tags: ["alert", "danger", "dangerous", "caution", "errors"], codepoint: 59388, published_in: 2, updated_in: 2 }, { name: "warning-octagon", pascal_name: "WarningOctagon", categories: [e.SYSTEM], figma_category: a.SECURITY, tags: ["alert", "danger", "dangerous", "caution", "errors", "8", "eight"], codepoint: 58596, published_in: 1, updated_in: 1 }, { name: "washing-machine", pascal_name: "WashingMachine", categories: [e.COMMERCE, e.MAP, e.OBJECTS], figma_category: a.COMMERCE, tags: ["*new*", "clothing", "laundry", "cleaning"], codepoint: 60904, published_in: 2.1, updated_in: 2.1 }, { name: "watch", pascal_name: "Watch", categories: [e.SYSTEM, e.OBJECTS], figma_category: a.TIME, tags: ["times", "timer", "alarm", "schedule", "events", "clock", "wristwatch", "wearable"], codepoint: 58598, published_in: 1, updated_in: 1 }, { name: "wave-sawtooth", pascal_name: "WaveSawtooth", categories: [e.MEDIA], figma_category: a.MEDIA, tags: ["synth", "synthesizer", "sound", "audio", "music", "waveform"], codepoint: 60060, published_in: 1.4, updated_in: 1.4 }, { name: "wave-sine", pascal_name: "WaveSine", categories: [e.MEDIA], figma_category: a.MEDIA, tags: ["synth", "synthesizer", "sound", "audio", "music", "waveform"], codepoint: 60058, published_in: 1.4, updated_in: 1.4 }, { name: "wave-square", pascal_name: "WaveSquare", categories: [e.MEDIA], figma_category: a.MEDIA, tags: ["synth", "synthesizer", "sound", "audio", "music", "waveform"], codepoint: 60062, published_in: 1.4, updated_in: 1.4 }, { name: "wave-triangle", pascal_name: "WaveTriangle", categories: [e.MEDIA], figma_category: a.MEDIA, tags: ["synth", "synthesizer", "sound", "audio", "music", "waveform"], codepoint: 60064, published_in: 1.4, updated_in: 1.4 }, { name: "waveform", pascal_name: "Waveform", categories: [e.MEDIA], figma_category: a.MEDIA, tags: ["*updated*", "audio", "sound", "spectrum", "spectrograph", "music"], codepoint: 59394, published_in: 2, updated_in: 2.1 }, { name: "waveform-slash", pascal_name: "WaveformSlash", categories: [e.MEDIA], figma_category: a.MEDIA, tags: ["*new*", "audio", "sound", "spectrum", "spectrograph", "music"], codepoint: 59392, published_in: 2.1, updated_in: 2.1 }, { name: "waves", pascal_name: "Waves", categories: [e.NATURE, e.WEATHER], figma_category: a.WEATHER, tags: ["ocean", "tides", "surf"], codepoint: 59102, published_in: 1.3, updated_in: 1.3 }, { name: "webcam", pascal_name: "Webcam", categories: [e.OBJECTS, e.SYSTEM, e.COMMUNICATION], figma_category: a.MEDIA, tags: ["camera", "video conference"], codepoint: 59826, published_in: 1.4, updated_in: 1.4 }, { name: "webcam-slash", pascal_name: "WebcamSlash", categories: [e.COMMUNICATION, e.OBJECTS, e.SYSTEM], figma_category: a.MEDIA, tags: ["camera", "video conference"], codepoint: 60636, published_in: 2, updated_in: 2 }, { name: "webhooks-logo", pascal_name: "WebhooksLogo", categories: [e.DEVELOPMENT, e.BRAND], figma_category: a.DEVELOPMENT, tags: ["api"], codepoint: 60590, published_in: 2, updated_in: 2 }, { name: "wechat-logo", pascal_name: "WechatLogo", categories: [e.BRAND], figma_category: a.BRAND, tags: ["weixin", "logos"], codepoint: 59602, published_in: 2, updated_in: 2 }, { name: "whatsapp-logo", pascal_name: "WhatsappLogo", categories: [e.BRAND, e.COMMUNICATION], figma_category: a.BRAND, tags: ["logos", "messages", "messaging"], codepoint: 58832, published_in: 1.1, updated_in: 1.1 }, { name: "wheelchair", pascal_name: "Wheelchair", categories: [e.HEALTH, e.MAP, e.PEOPLE], figma_category: a.PEOPLE, tags: ["handicapped", "medical", "disabled", "differently abled", "accessible", "accessibility", "a11y"], codepoint: 58600, published_in: 1, updated_in: 1 }, { name: "wheelchair-motion", pascal_name: "WheelchairMotion", categories: [e.HEALTH, e.MAP, e.PEOPLE], figma_category: a.PEOPLE, tags: ["handicapped", "medical", "disabled", "differently abled", "accessible", "accessibility", "a11y"], codepoint: 59546, published_in: 2, updated_in: 2 }, { name: "wifi-high", pascal_name: "WifiHigh", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["wireless", "internet", "network", "connection", "connectivity"], codepoint: 58602, published_in: 1, updated_in: 1 }, { name: "wifi-low", pascal_name: "WifiLow", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["wireless", "internet", "network", "connection", "connectivity"], codepoint: 58604, published_in: 1, updated_in: 1 }, { name: "wifi-medium", pascal_name: "WifiMedium", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["wireless", "internet", "network", "connection", "connectivity"], codepoint: 58606, published_in: 1, updated_in: 1 }, { name: "wifi-none", pascal_name: "WifiNone", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["wireless", "internet", "network", "connection", "connectivity"], codepoint: 58608, published_in: 1, updated_in: 1 }, { name: "wifi-slash", pascal_name: "WifiSlash", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["wireless", "internet", "network", "connection", "connectivity", "disabled", "disconnected"], codepoint: 58610, published_in: 1, updated_in: 1 }, { name: "wifi-x", pascal_name: "WifiX", categories: [e.SYSTEM], figma_category: a.SYSTEM, tags: ["wireless", "internet", "network", "connection", "connectivity", "disconnected", "errors"], codepoint: 58612, published_in: 1, updated_in: 1.4 }, { name: "wind", pascal_name: "Wind", categories: [e.WEATHER], figma_category: a.WEATHER, tags: ["meteorology", "windy", "stormy", "blustery", "gusty", "air"], codepoint: 58834, published_in: 1.1, updated_in: 1.1 }, { name: "windmill", pascal_name: "Windmill", categories: [e.COMMERCE], figma_category: a.COMMERCE, tags: ["*new*", "turbine", "energy", "renewable", "sustainability", "countryside", "landscape", "green", "power", "buildings"], codepoint: 59896, published_in: 2.1, updated_in: 2.1 }, { name: "windows-logo", pascal_name: "WindowsLogo", categories: [e.BRAND, e.DEVELOPMENT], figma_category: a.BRAND, tags: ["microsoft", "computers"], codepoint: 59026, published_in: 1.3, updated_in: 1.3 }, { name: "wine", pascal_name: "Wine", categories: [e.COMMERCE, e.MAP, e.OBJECTS], figma_category: a.COMMERCE, tags: ["drinks", "beverages", "vineyard", "places", "locations", "bars", "restaurants", "food", "dining"], codepoint: 59058, published_in: 1.3, updated_in: 1.3 }, { name: "wrench", pascal_name: "Wrench", categories: [e.SYSTEM, e.OBJECTS, e.COMMERCE], figma_category: a.COMMERCE, tags: ["settings", "setup", "preferences", "tools", "machinery", "mechanical", "repairs"], codepoint: 58836, published_in: 1.1, updated_in: 1.1 }, { name: "x", pascal_name: "X", categories: [e.DEVELOPMENT, e.FINANCE, e.SYSTEM], figma_category: a.FINANCE, tags: ["\xD7", "closed", "cancelled", "dismissed", "times", "multiply", "mulitplication", "product", "mathematics", "arithmetic", "calculator"], codepoint: 58614, published_in: 1, updated_in: 1 }, { name: "x-circle", pascal_name: "XCircle", categories: [e.SYSTEM], figma_category: a.FINANCE, tags: ["closed", "cancelled", "dismissed", "round"], codepoint: 58616, published_in: 1, updated_in: 1 }, { name: "x-logo", pascal_name: "XLogo", categories: [e.BRAND, e.COMMUNICATION], figma_category: a.BRAND, tags: ["*new*", "twitter", "logos", "social media", "tweets"], codepoint: 58556, published_in: 2.1, updated_in: 2.1 }, { name: "x-square", pascal_name: "XSquare", categories: [e.SYSTEM], figma_category: a.FINANCE, tags: ["closed", "cancelled", "dismissed"], codepoint: 58618, published_in: 1, updated_in: 1 }, { name: "yarn", pascal_name: "Yarn", categories: [e.GAMES, e.COMMERCE], figma_category: a.COMMERCE, tags: ["*new*", "knitting", "sewing"], codepoint: 60826, published_in: 2.1, updated_in: 2.1 }, { name: "yin-yang", pascal_name: "YinYang", categories: [e.COMMUNICATION], figma_category: a.COMMUNICATION, tags: ["symbol", "good", "evil", "black", "white"], codepoint: 59690, published_in: 1.4, updated_in: 1.4 }, { name: "youtube-logo", pascal_name: "YoutubeLogo", categories: [e.BRAND, e.COMMUNICATION, e.MEDIA], figma_category: a.BRAND, tags: ["logos", "google", "videos", "movies", "social media"], codepoint: 58620, published_in: 1, updated_in: 1 }];
      t.FigmaCategory = a, t.IconCategory = e, t.IconStyle = n, t.icons = o, Object.defineProperty(t, Symbol.toStringTag, { value: "Module" });
    });
  }
});

// ../../../sonata-api/packages/compiler/dist/guards.js
var require_guards = __commonJS({
  "../../../sonata-api/packages/compiler/dist/guards.js"(exports2) {
    "use strict";
    init_importMeta();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || /* @__PURE__ */ function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isValidPropertyModifier = exports2.isNativePropertyType = void 0;
    var AST2 = __importStar(require_ast());
    var isNativePropertyType = (value) => {
      return value in AST2.PropertyType;
    };
    exports2.isNativePropertyType = isNativePropertyType;
    var isValidPropertyModifier = (value) => {
      return value in AST2.PropertyModifiers;
    };
    exports2.isValidPropertyModifier = isValidPropertyModifier;
  }
});

// ../../../sonata-api/packages/compiler/dist/parser.js
var require_parser = __commonJS({
  "../../../sonata-api/packages/compiler/dist/parser.js"(exports2) {
    "use strict";
    init_importMeta();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || /* @__PURE__ */ function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parse = exports2.memoTable = exports2.locationMap = void 0;
    var token_js_1 = require_token();
    var types_1 = require_dist();
    var core_1 = require_index_umd();
    var diagnostic_js_1 = require_diagnostic2();
    var AST2 = __importStar(require_ast());
    var guards = __importStar(require_guards());
    var lexer = __importStar(require_lexer());
    var MAX_ERROR_MESSAGE_ITEMS = 20;
    var ICON_NAMES = core_1.icons.map((icon) => icon.name);
    exports2.locationMap = /* @__PURE__ */ new WeakMap();
    exports2.memoTable = {};
    var isFileProperty = (property) => {
      return property.$ref === "File";
    };
    var checkForValidRoles = (roles, symbols) => {
      if (exports2.memoTable.roles) {
        for (const [i, role] of roles.entries()) {
          const symbol = symbols[i];
          if (!exports2.memoTable.roles.includes(role)) {
            const location = exports2.locationMap.get(symbol);
            throw new diagnostic_js_1.Diagnostic(`invalid role "${role}"`, location);
          }
        }
      }
      return roles;
    };
    var parse = (tokens) => {
      let index = 0;
      const ast = {
        kind: "program",
        collections: [],
        contracts: [],
        functionsets: []
      };
      const errors = [];
      const advance = () => index++;
      const rollback = () => index--;
      const next = () => {
        const token = tokens[index + 1];
        if (!token) {
          throw new diagnostic_js_1.Diagnostic("unexpected EOF", current().location);
        }
        return token;
      };
      const previous = () => {
        const token = tokens[index - 1];
        if (!token) {
          throw new diagnostic_js_1.Diagnostic("invalid position");
        }
        return token;
      };
      const current = () => {
        const token = tokens[index];
        if (!token) {
          throw new diagnostic_js_1.Diagnostic("unexpected EOF", previous().location);
        }
        return token;
      };
      const foldBrackets = () => {
        if (match2(token_js_1.TokenType.LeftBracket)) {
          advance();
          while (!match2(token_js_1.TokenType.RightBracket)) {
            foldBrackets();
            advance();
          }
        }
      };
      const match2 = (expected, value) => {
        const token = current();
        if (token.type === expected) {
          if (value !== void 0) {
            return Array.isArray(value) ? value.includes(token.value) : token.value === value;
          }
          return true;
        }
        return false;
      };
      const consume = (expected, value) => {
        const token = current();
        if (match2(expected, value)) {
          advance();
          return token;
        }
        let expectedValue;
        if (value) {
          expectedValue = Array.isArray(value) ? value.slice(0, MAX_ERROR_MESSAGE_ITEMS).map((elem) => `"${elem}"`).join(" | ") : `"${value}"`;
        }
        if (Array.isArray(value) && value.length > MAX_ERROR_MESSAGE_ITEMS) {
          expectedValue += " | ...";
        }
        throw new diagnostic_js_1.Diagnostic(expectedValue ? `expected ${expected} with value ${expectedValue} but found ${token.type} with value "${token.value}" instead` : `expected ${expected} but found ${token.type} instead`, token.location);
      };
      const recover = (keywords) => {
        let token;
        while (token = tokens[++index]) {
          if (token.type === token_js_1.TokenType.Keyword && keywords.includes(token.value)) {
            break;
          }
        }
      };
      const parseArray = (types2) => {
        const { location: openingLocation } = consume(token_js_1.TokenType.LeftSquareBracket);
        const array = [];
        const symbols = [];
        let type;
        for (const typeCandidate of types2) {
          if (match2(typeCandidate)) {
            type = typeCandidate;
            break;
          }
        }
        if (!type) {
          throw new diagnostic_js_1.Diagnostic(`array got an invalid type, accepted ones are: ${types2.join(" | ")}`, openingLocation);
        }
        while (!match2(token_js_1.TokenType.RightSquareBracket)) {
          const { value, location } = consume(type);
          const elemSymbol = Symbol();
          array.push(value);
          symbols.push(elemSymbol);
          exports2.locationMap.set(elemSymbol, location);
          if (match2(token_js_1.TokenType.Comma)) {
            consume(token_js_1.TokenType.Comma);
          }
        }
        consume(token_js_1.TokenType.RightSquareBracket);
        return {
          value: array,
          symbols
        };
      };
      const parseArrayBlock = (value) => {
        const array = [];
        const symbols = [];
        consume(token_js_1.TokenType.LeftBracket);
        while (!match2(token_js_1.TokenType.RightBracket)) {
          const { value: identifier, location } = consume(token_js_1.TokenType.Identifier, value);
          const elemSymbol = Symbol();
          array.push(identifier);
          symbols.push(elemSymbol);
          exports2.locationMap.set(elemSymbol, location);
          if (match2(token_js_1.TokenType.Comma)) {
            consume(token_js_1.TokenType.Comma);
          }
        }
        consume(token_js_1.TokenType.RightBracket);
        return {
          value: array,
          symbols
        };
      };
      const parseArrayBlockWithAttributes = (allowedAttributes, cb) => {
        const array = {};
        const symbols = [];
        let hasAttributes = false;
        consume(token_js_1.TokenType.LeftBracket);
        while (!match2(token_js_1.TokenType.RightBracket)) {
          const { value: identifier, location } = consume(token_js_1.TokenType.Identifier);
          array[identifier] = true;
          const elemSymbol = Symbol();
          symbols.push(elemSymbol);
          exports2.locationMap.set(elemSymbol, location);
          if (match2(token_js_1.TokenType.AttributeName)) {
            hasAttributes = true;
          }
          while (match2(token_js_1.TokenType.AttributeName)) {
            array[identifier] = {};
            const { value: attributeName } = consume(token_js_1.TokenType.AttributeName, allowedAttributes);
            cb(attributeName, array, identifier);
          }
        }
        consume(token_js_1.TokenType.RightBracket);
        const value = hasAttributes ? array : Object.keys(array);
        return {
          value,
          symbols
        };
      };
      const parsePropertyAttributeValue = (attributeName, property, location) => {
        const consumeBoolean = () => {
          if (match2(token_js_1.TokenType.Boolean)) {
            const { value } = consume(token_js_1.TokenType.Boolean);
            return value;
          }
          return true;
        };
        if ("enum" in property && attributeName === "values") {
          property.enum = parseArray([
            token_js_1.TokenType.QuotedString,
            token_js_1.TokenType.Number
          ]).value;
          return;
        }
        if ("const" in property && attributeName === "value") {
          const token = current();
          advance();
          switch (token.type) {
            case token_js_1.TokenType.Number:
            case token_js_1.TokenType.Boolean:
            case token_js_1.TokenType.Null:
            case token_js_1.TokenType.QuotedString: {
              property.const = token.value;
              return;
            }
            default: {
              throw new diagnostic_js_1.Diagnostic(`const received invalid value: "${token.value}"`, location);
            }
          }
        }
        switch (attributeName) {
          case "icon": {
            const { value } = consume(token_js_1.TokenType.QuotedString, ICON_NAMES);
            property[attributeName] = value;
            return;
          }
          case "hint":
          case "description": {
            const { value } = consume(token_js_1.TokenType.QuotedString);
            property[attributeName] = value;
            return;
          }
          case "translate": {
            property[attributeName] = consumeBoolean();
            return;
          }
        }
        if ("$ref" in property) {
          switch (attributeName) {
            case "purge":
            case "inline": {
              property[attributeName] = consumeBoolean();
              return;
            }
            case "select":
            case "form":
            case "populate":
            case "indexes": {
              property[attributeName] = parseArray([token_js_1.TokenType.Identifier]).value;
              return;
            }
            case "populateDepth": {
              const { value } = consume(token_js_1.TokenType.Number);
              property[attributeName] = value;
              return;
            }
            case "constraints": {
              const constraintTerms = [];
              rollback();
              property[attributeName] = parseCondition(constraintTerms);
              property[AST2.LOCATION_SYMBOL].contraintTerms = constraintTerms;
              rollback();
              return;
            }
          }
          if (isFileProperty(property)) {
            switch (attributeName) {
              case "extensions":
              case "accept": {
                property[attributeName] = parseArray([token_js_1.TokenType.QuotedString]).value;
                return;
              }
            }
          }
        }
        if ("type" in property) {
          switch (property.type) {
            case "string": {
              switch (attributeName) {
                case "format": {
                  const { value } = consume(token_js_1.TokenType.QuotedString, types_1.PROPERTY_FORMATS);
                  property[attributeName] = value;
                  return;
                }
                case "mask": {
                  if (match2(token_js_1.TokenType.LeftSquareBracket)) {
                    property[attributeName] = parseArray([token_js_1.TokenType.QuotedString]).value;
                    return;
                  } else {
                    const { value } = consume(token_js_1.TokenType.QuotedString);
                    property[attributeName] = value;
                    return;
                  }
                }
                case "maskedValue": {
                  const { value } = consume(token_js_1.TokenType.Boolean);
                  property[attributeName] = value;
                  return;
                }
                case "minLength":
                case "maxLength": {
                  const { value } = consume(token_js_1.TokenType.Number);
                  property[attributeName] = value;
                  return;
                }
                case "inputType": {
                  const { value } = consume(token_js_1.TokenType.QuotedString, types_1.PROPERTY_INPUT_TYPES);
                  property[attributeName] = value;
                  return;
                }
                case "element": {
                  const { value } = consume(token_js_1.TokenType.QuotedString, types_1.PROPERTY_INPUT_ELEMENTS);
                  property[attributeName] = value;
                  return;
                }
                case "placeholder": {
                  const { value } = consume(token_js_1.TokenType.QuotedString);
                  property[attributeName] = value;
                  return;
                }
              }
              break;
            }
            case "integer":
            case "number": {
              switch (attributeName) {
                case "exclusiveMinimum":
                case "exclusiveMaximum":
                case "minimum":
                case "maximum": {
                  const { value } = consume(token_js_1.TokenType.Number);
                  property[attributeName] = value;
                  return;
                }
                case "placeholder": {
                  const { value } = consume(token_js_1.TokenType.QuotedString);
                  property[attributeName] = value;
                  return;
                }
              }
              break;
            }
            case "array": {
              switch (attributeName) {
                case "uniqueItems": {
                  const { value } = consume(token_js_1.TokenType.Boolean);
                  property[attributeName] = value;
                  return;
                }
                case "element": {
                  const { value } = consume(token_js_1.TokenType.QuotedString, types_1.PROPERTY_ARRAY_ELEMENTS);
                  property[attributeName] = value;
                  return;
                }
              }
            }
          }
        }
        throw new diagnostic_js_1.Diagnostic(`invalid attribute name "${attributeName}"`, location);
      };
      const parsePropertyType = (options = {
        allowModifiers: false
      }) => {
        let property;
        let nestedProperties;
        let nestedAdditionalProperties;
        let modifierToken;
        const typeSymbol = Symbol();
        if (options.allowModifiers) {
          const nextToken = next();
          const currentTokenValue = current().value;
          if (match2(token_js_1.TokenType.Identifier) && typeof currentTokenValue === "string" && guards.isValidPropertyModifier(currentTokenValue) && (nextToken.type === token_js_1.TokenType.LeftBracket || nextToken.type === token_js_1.TokenType.LeftSquareBracket || nextToken.type === token_js_1.TokenType.Identifier)) {
            modifierToken = consume(token_js_1.TokenType.Identifier);
          }
        }
        if (match2(token_js_1.TokenType.LeftSquareBracket)) {
          consume(token_js_1.TokenType.LeftSquareBracket);
          const arrayProperty = {
            type: "array"
          };
          while (!match2(token_js_1.TokenType.RightSquareBracket)) {
            const attributeSymbol = Symbol();
            arrayProperty[AST2.LOCATION_SYMBOL] ??= {
              type: typeSymbol,
              attributes: {},
              arrays: {}
            };
            if (match2(token_js_1.TokenType.Range)) {
              const { value: rangeSeparator } = consume(token_js_1.TokenType.Range);
              let attributeName2;
              const minItems = rangeSeparator[0];
              if (!isNaN(minItems)) {
                attributeName2 = "minItems";
                arrayProperty[attributeName2] = minItems, arrayProperty[AST2.LOCATION_SYMBOL].attributes[attributeName2] = attributeSymbol;
              }
              const maxItems = rangeSeparator[1];
              if (!isNaN(maxItems)) {
                attributeName2 = "maxItems";
                arrayProperty[attributeName2] = maxItems;
                arrayProperty[AST2.LOCATION_SYMBOL].attributes[attributeName2] = attributeSymbol;
              }
              continue;
            }
            const { value: attributeName, location } = consume(token_js_1.TokenType.AttributeName);
            if (match2(token_js_1.TokenType.LeftParens)) {
              consume(token_js_1.TokenType.LeftParens);
              exports2.locationMap.set(attributeSymbol, next().location);
              arrayProperty[AST2.LOCATION_SYMBOL].attributes[attributeName] = attributeSymbol;
              parsePropertyAttributeValue(attributeName, arrayProperty, location);
              consume(token_js_1.TokenType.RightParens);
            } else {
              parsePropertyAttributeValue(attributeName, arrayProperty, location);
            }
          }
          consume(token_js_1.TokenType.RightSquareBracket);
          const { property: items, nestedProperties: nestedProperties2 } = parsePropertyType(options);
          property = {
            ...arrayProperty,
            items
          };
          exports2.locationMap.set(typeSymbol, current().location);
          return {
            kind: "property",
            property,
            nestedProperties: nestedProperties2
          };
        }
        exports2.locationMap.set(typeSymbol, current().location);
        if (match2(token_js_1.TokenType.LeftBracket)) {
          consume(token_js_1.TokenType.LeftBracket);
          property = {
            type: "object",
            properties: {},
            [AST2.LOCATION_SYMBOL]: {
              type: typeSymbol,
              attributes: {},
              arrays: {}
            }
          };
          while (!match2(token_js_1.TokenType.RightBracket)) {
            const { value: keyword, location } = current();
            switch (keyword) {
              case "writable":
              case "required": {
                consume(token_js_1.TokenType.Keyword);
                const { value, symbols } = parseArrayBlock();
                property[keyword] = value;
                property[AST2.LOCATION_SYMBOL].arrays[keyword] = symbols;
                break;
              }
              case "properties": {
                consume(token_js_1.TokenType.Keyword);
                nestedProperties = parsePropertiesBlock(options);
                break;
              }
              case "additionalProperties": {
                consume(token_js_1.TokenType.Keyword);
                if (match2(token_js_1.TokenType.Boolean)) {
                  nestedAdditionalProperties = consume(token_js_1.TokenType.Boolean).value;
                } else {
                  nestedAdditionalProperties = parsePropertyType();
                }
                break;
              }
              default:
                throw new diagnostic_js_1.Diagnostic(`invalid keyword "${keyword}"`, location);
            }
          }
          consume(token_js_1.TokenType.RightBracket);
        } else {
          const { value: identifier } = consume(token_js_1.TokenType.Identifier);
          if (guards.isNativePropertyType(identifier)) {
            switch (identifier) {
              case "enum": {
                property = {
                  enum: []
                };
                break;
              }
              case "const": {
                property = {
                  const: null
                };
                break;
              }
              case "date": {
                property = {
                  type: "string",
                  format: "date"
                };
                break;
              }
              case "datetime": {
                property = {
                  type: "string",
                  format: "date-time"
                };
                break;
              }
              default:
                property = {
                  type: AST2.PropertyType[identifier]
                };
            }
          } else {
            property = {
              $ref: identifier,
              [AST2.LOCATION_SYMBOL]: {
                type: typeSymbol,
                attributes: {},
                arrays: {}
              }
            };
          }
        }
        while (match2(token_js_1.TokenType.AttributeName)) {
          const { value: attributeName, location } = consume(token_js_1.TokenType.AttributeName);
          if (match2(token_js_1.TokenType.LeftParens)) {
            consume(token_js_1.TokenType.LeftParens);
            const attributeSymbol = Symbol();
            exports2.locationMap.set(attributeSymbol, next().location);
            property[AST2.LOCATION_SYMBOL] ??= {
              type: typeSymbol,
              attributes: {},
              arrays: {}
            };
            property[AST2.LOCATION_SYMBOL].attributes[attributeName] = attributeSymbol;
            parsePropertyAttributeValue(attributeName, property, location);
            consume(token_js_1.TokenType.RightParens);
          } else {
            parsePropertyAttributeValue(attributeName, property, location);
          }
        }
        const node = {
          kind: "property",
          property,
          nestedProperties,
          nestedAdditionalProperties
        };
        if (modifierToken) {
          node.modifier = modifierToken.value;
        }
        return node;
      };
      const parsePropertiesBlock = (options = {
        allowModifiers: false
      }) => {
        consume(token_js_1.TokenType.LeftBracket);
        const properties = {};
        while (!match2(token_js_1.TokenType.RightBracket)) {
          try {
            const { value: propName } = consume(token_js_1.TokenType.Identifier);
            properties[propName] = parsePropertyType(options);
            if (match2(token_js_1.TokenType.Comma)) {
              consume(token_js_1.TokenType.Comma);
            }
          } catch (err) {
            if (err instanceof diagnostic_js_1.Diagnostic) {
              errors.push(err);
              recoverLoop: for (; ; ) {
                switch (current().type) {
                  case token_js_1.TokenType.RightBracket:
                  case token_js_1.TokenType.Identifier: {
                    break recoverLoop;
                  }
                }
                while (match2(token_js_1.TokenType.AttributeName)) {
                  advance();
                  if (match2(token_js_1.TokenType.LeftParens)) {
                    advance();
                    while (!match2(token_js_1.TokenType.RightParens)) {
                      advance();
                    }
                  }
                }
                advance();
                foldBrackets();
              }
              continue;
            }
            throw err;
          }
        }
        consume(token_js_1.TokenType.RightBracket);
        return properties;
      };
      const parseMultiplePropertyTypes = (options = {
        allowModifiers: false
      }) => {
        if (match2(token_js_1.TokenType.Pipe)) {
          consume(token_js_1.TokenType.Pipe);
          const properties = [];
          while (index < tokens.length) {
            properties.push(parsePropertyType(options));
            if (match2(token_js_1.TokenType.Pipe)) {
              consume(token_js_1.TokenType.Pipe);
            } else {
              break;
            }
          }
          return properties;
        }
        return parsePropertyType(options);
      };
      const parseAccessCondition = (options = {
        arrayBlock: false
      }) => {
        if (match2(token_js_1.TokenType.Boolean)) {
          const { value } = consume(token_js_1.TokenType.Boolean);
          return value;
        } else if (match2(token_js_1.TokenType.QuotedString, [
          "unauthenticated",
          "unauthenticated-only"
        ])) {
          const { value } = consume(token_js_1.TokenType.QuotedString, [
            "unauthenticated",
            "unauthenticated-only"
          ]);
          return value;
        } else {
          const { value, symbols } = options.arrayBlock ? parseArrayBlock() : parseArray([token_js_1.TokenType.QuotedString]);
          return checkForValidRoles(value, symbols);
        }
      };
      const parseCollection = () => {
        consume(token_js_1.TokenType.Keyword, "collection");
        const { value: name } = consume(token_js_1.TokenType.Identifier);
        const node = {
          kind: "collection",
          name,
          properties: {},
          [AST2.LOCATION_SYMBOL]: {
            arrays: {}
          }
        };
        if (match2(token_js_1.TokenType.Keyword, "extends")) {
          consume(token_js_1.TokenType.Keyword);
          const { value: packageName } = consume(token_js_1.TokenType.Identifier);
          consume(token_js_1.TokenType.Dot);
          const { value: symbolName } = consume(token_js_1.TokenType.Identifier);
          node.extends = {
            packageName,
            symbolName: symbolName[0].toLowerCase() + symbolName.slice(1)
          };
        }
        consume(token_js_1.TokenType.LeftBracket);
        while (!match2(token_js_1.TokenType.RightBracket)) {
          const { value: keyword } = consume(token_js_1.TokenType.Keyword, lexer.COLLECTION_KEYWORDS);
          try {
            switch (keyword) {
              case "middlewares": {
                node.middlewares = parseArrayBlock().value;
                break;
              }
              case "owned": {
                if (match2(token_js_1.TokenType.Boolean)) {
                  node.owned = consume(token_js_1.TokenType.Boolean).value;
                } else {
                  node.owned = consume(token_js_1.TokenType.QuotedString, [
                    "always",
                    "on-write"
                  ]).value;
                }
                break;
              }
              case "icon": {
                const { value } = consume(token_js_1.TokenType.QuotedString, ICON_NAMES);
                node[keyword] = value;
                break;
              }
              case "properties": {
                node[keyword] = parsePropertiesBlock();
                break;
              }
              case "functions": {
                const { functions, functionSets } = parseFunctionsBlock();
                node.functions = functions;
                node.functionSets = functionSets;
                break;
              }
              case "individualActions":
              case "actions": {
                node[keyword] = parseActionsBlock();
                break;
              }
              case "required": {
                const { value, symbols } = parseArrayBlockWithAttributes(["if"], (attributeName, array, identifier) => {
                  switch (attributeName) {
                    case "if": {
                      const ifTerms = [];
                      array[identifier] = parseCondition(ifTerms);
                      node[AST2.LOCATION_SYMBOL].requiredTerms = ifTerms;
                      break;
                    }
                  }
                });
                node.required = value;
                node[AST2.LOCATION_SYMBOL].required = symbols;
                break;
              }
              case "presets": {
                const { value, symbols } = parseArrayBlock(types_1.DESCRIPTION_PRESETS);
                node[keyword] = value;
                node[AST2.LOCATION_SYMBOL].arrays[keyword] = symbols;
                break;
              }
              case "indexes":
              case "form":
              case "table":
              case "tableMeta":
              case "filters": {
                const { value, symbols } = parseArrayBlock();
                node[keyword] = value;
                node[AST2.LOCATION_SYMBOL].arrays[keyword] = symbols;
                break;
              }
              case "search": {
                node[keyword] = parseSearchBlock();
                break;
              }
              case "layout": {
                node[keyword] = parseLayoutBlock();
                break;
              }
              case "formLayout": {
                node[keyword] = parseFormLayoutBlock();
                break;
              }
            }
          } catch (err) {
            if (err instanceof diagnostic_js_1.Diagnostic) {
              errors.push(err);
              recover(lexer.COLLECTION_KEYWORDS);
              continue;
            }
            throw err;
          }
        }
        consume(token_js_1.TokenType.RightBracket);
        return node;
      };
      const parseContract = () => {
        consume(token_js_1.TokenType.Keyword, "contract");
        const { value: name } = consume(token_js_1.TokenType.Identifier);
        consume(token_js_1.TokenType.LeftBracket);
        const node = {
          kind: "contract",
          name
        };
        while (!match2(token_js_1.TokenType.RightBracket)) {
          const { value: keyword } = consume(token_js_1.TokenType.Keyword, lexer.CONTRACT_KEYWORDS);
          switch (keyword) {
            case "roles": {
              node.roles = parseAccessCondition({
                arrayBlock: true
              });
              break;
            }
            case "payload": {
              node.payload = parsePropertyType({
                allowModifiers: true
              });
              break;
            }
            case "query": {
              node.query = parsePropertyType({
                allowModifiers: true
              });
              break;
            }
            case "response": {
              node.response = parseMultiplePropertyTypes({
                allowModifiers: true
              });
              break;
            }
          }
        }
        consume(token_js_1.TokenType.RightBracket);
        return node;
      };
      const parseFunctionsBlock = () => {
        consume(token_js_1.TokenType.LeftBracket);
        const functions = {};
        const functionSets = [];
        while (!match2(token_js_1.TokenType.RightBracket)) {
          try {
            if (match2(token_js_1.TokenType.MacroName)) {
              const { value: macroName } = consume(token_js_1.TokenType.MacroName, ["include"]);
              switch (macroName) {
                case "include": {
                  const { value: functionSetName, location } = consume(token_js_1.TokenType.Identifier);
                  const functionSetSymbol = Symbol();
                  exports2.locationMap.set(functionSetSymbol, location);
                  functionSets.push([
                    functionSetName,
                    functionSetSymbol
                  ]);
                  consume(token_js_1.TokenType.RightParens);
                  break;
                }
              }
              continue;
            }
            const { value: functionName } = consume(token_js_1.TokenType.Identifier);
            functions[functionName] = {
              accessCondition: false
            };
            while (match2(token_js_1.TokenType.AttributeName, "expose")) {
              consume(token_js_1.TokenType.AttributeName, "expose");
              if (match2(token_js_1.TokenType.LeftParens)) {
                consume(token_js_1.TokenType.LeftParens);
                functions[functionName] = {
                  accessCondition: parseAccessCondition()
                };
                consume(token_js_1.TokenType.RightParens);
              } else {
                functions[functionName] = {
                  accessCondition: true
                };
              }
            }
          } catch (err) {
            if (err instanceof diagnostic_js_1.Diagnostic) {
              let token;
              while (token = tokens[++index]) {
                if (token.type === token_js_1.TokenType.Identifier || token.type === token_js_1.TokenType.RightBracket) {
                  break;
                }
              }
              errors.push(err);
              continue;
            }
            throw err;
          }
        }
        consume(token_js_1.TokenType.RightBracket);
        return {
          functions,
          functionSets
        };
      };
      const parseFunctionSet = () => {
        consume(token_js_1.TokenType.Keyword, "functionset");
        const { value: name } = consume(token_js_1.TokenType.Identifier);
        const { functions, functionSets } = parseFunctionsBlock();
        const node = {
          kind: "functionset",
          name,
          functions,
          functionSets
        };
        return node;
      };
      const parseActionsBlock = () => {
        const actions = {};
        consume(token_js_1.TokenType.LeftBracket);
        while (!match2(token_js_1.TokenType.RightBracket)) {
          const { value: actionName } = consume(token_js_1.TokenType.Identifier);
          consume(token_js_1.TokenType.LeftBracket);
          const baseSlots = {};
          const slots = {
            route: {
              route: {
                name: ""
              }
            },
            function: {},
            event: {}
          };
          let actionType;
          while (!match2(token_js_1.TokenType.RightBracket)) {
            const { value: keyword } = consume(token_js_1.TokenType.Keyword, lexer.COLLECTION_ACTIONS_KEYWORDS);
            switch (keyword) {
              case "icon": {
                const { value } = consume(token_js_1.TokenType.QuotedString, ICON_NAMES);
                baseSlots[keyword] = value;
                break;
              }
              case "label": {
                const { value } = consume(token_js_1.TokenType.QuotedString);
                baseSlots[keyword] = value;
                break;
              }
              case "ask":
              case "button":
              case "translate": {
                const { value } = consume(token_js_1.TokenType.Boolean);
                baseSlots[keyword] = value;
                break;
              }
              case "roles": {
                const { value, symbols } = parseArray([token_js_1.TokenType.Identifier]);
                const roles = checkForValidRoles(value, symbols);
                baseSlots[keyword] = roles;
                break;
              }
              case "requires": {
                const { value } = parseArray([token_js_1.TokenType.Identifier]);
                baseSlots[keyword] = value;
                break;
              }
              case "route": {
                const { value } = consume(token_js_1.TokenType.QuotedString);
                actionType = "route";
                slots.route.route.name = value;
                break;
              }
              case "setItem":
              case "fetchItem":
              case "clearItem": {
                const { value } = consume(token_js_1.TokenType.Boolean);
                slots.route.route[keyword] = value;
                break;
              }
              case "function": {
                const { value } = consume(token_js_1.TokenType.QuotedString);
                actionType = "function";
                slots.function.function = value;
                break;
              }
              case "effect": {
                const { value } = consume(token_js_1.TokenType.QuotedString);
                slots.function.effect = value;
                break;
              }
              case "selection": {
                const { value } = consume(token_js_1.TokenType.Boolean);
                slots.function.selection = value;
                break;
              }
              case "event": {
                const { value } = consume(token_js_1.TokenType.QuotedString);
                actionType = "event";
                slots.event.event = value;
                break;
              }
            }
          }
          if (actionType) {
            actions[actionName] = {
              ...baseSlots,
              ...slots[actionType]
            };
          } else {
            actions[actionName] = baseSlots;
          }
          consume(token_js_1.TokenType.RightBracket);
        }
        consume(token_js_1.TokenType.RightBracket);
        return actions;
      };
      const parseSearchBlock = () => {
        const searchSlots = {};
        const { location } = consume(token_js_1.TokenType.LeftBracket);
        while (!match2(token_js_1.TokenType.RightBracket)) {
          const { value: keyword } = consume(token_js_1.TokenType.Keyword, lexer.COLLECTION_SEARCH_KEYWORDS);
          switch (keyword) {
            case "placeholder": {
              const { value } = consume(token_js_1.TokenType.QuotedString);
              searchSlots[keyword] = value;
              break;
            }
            case "exactMatches": {
              const { value } = consume(token_js_1.TokenType.Boolean);
              searchSlots[keyword] = value;
              break;
            }
            case "indexes": {
              const { value } = parseArrayBlock();
              searchSlots[keyword] = value;
              break;
            }
          }
        }
        const { indexes } = searchSlots;
        if (!indexes) {
          throw new diagnostic_js_1.Diagnostic('"indexes" option is required', location);
        }
        consume(token_js_1.TokenType.RightBracket);
        return {
          ...searchSlots,
          indexes
        };
      };
      const parseLayoutBlock = () => {
        let name;
        const options = {};
        const optionsSymbols = {};
        const { location } = consume(token_js_1.TokenType.LeftBracket);
        while (!match2(token_js_1.TokenType.RightBracket)) {
          const { value: keyword } = consume(token_js_1.TokenType.Keyword, lexer.COLLECTION_LAYOUT_KEYWORDS);
          switch (keyword) {
            case "name": {
              name = consume(token_js_1.TokenType.QuotedString, types_1.LAYOUT_NAMES).value;
              break;
            }
            case "options":
              {
                consume(token_js_1.TokenType.LeftBracket);
                while (!match2(token_js_1.TokenType.RightBracket)) {
                  const { value: optionsKeyword } = consume(token_js_1.TokenType.Keyword, lexer.COLLECTION_LAYOUT_OPTIONS_KEYWORDS);
                  switch (optionsKeyword) {
                    case "active":
                    case "title":
                    case "picture":
                    case "badge": {
                      const { value, location: location2 } = consume(token_js_1.TokenType.Identifier);
                      const symbol = Symbol();
                      options[optionsKeyword] = value;
                      optionsSymbols[optionsKeyword] = symbol;
                      exports2.locationMap.set(symbol, location2);
                      break;
                    }
                    case "information": {
                      if (match2(token_js_1.TokenType.LeftBracket)) {
                        const { value, symbols } = parseArrayBlock();
                        options[optionsKeyword] = value;
                        optionsSymbols[optionsKeyword] = symbols;
                      } else {
                        const { value, location: location2 } = consume(token_js_1.TokenType.Identifier);
                        const symbol = Symbol();
                        options[optionsKeyword] = value;
                        optionsSymbols[optionsKeyword] = symbol;
                        exports2.locationMap.set(symbol, location2);
                      }
                      break;
                    }
                    case "translateBadge": {
                      const { value } = consume(token_js_1.TokenType.Boolean);
                      options[optionsKeyword] = value;
                      break;
                    }
                  }
                }
              }
              consume(token_js_1.TokenType.RightBracket);
              break;
          }
        }
        if (!name) {
          throw new diagnostic_js_1.Diagnostic('layout must have a "name" property', location);
        }
        consume(token_js_1.TokenType.RightBracket);
        return {
          kind: "layout",
          name,
          options,
          [AST2.LOCATION_SYMBOL]: {
            options: optionsSymbols
          }
        };
      };
      const parseFormLayoutBlock = () => {
        const fields = {};
        const node = {
          kind: "formLayout",
          fields,
          [AST2.LOCATION_SYMBOL]: {
            fields: {}
          }
        };
        consume(token_js_1.TokenType.LeftBracket);
        while (!match2(token_js_1.TokenType.RightBracket)) {
          const { value: keyword, location: keywordLocation } = consume(token_js_1.TokenType.Keyword, lexer.COLLECTION_FORM_LAYOUT_KEYWORDS);
          switch (keyword) {
            case "fields": {
              consume(token_js_1.TokenType.LeftBracket);
              while (!match2(token_js_1.TokenType.RightBracket)) {
                const { value: identifier, location: identifierLocation } = consume(token_js_1.TokenType.Identifier);
                const identifierSymbol = Symbol();
                exports2.locationMap.set(identifierSymbol, identifierLocation);
                fields[identifier] ??= {};
                node[AST2.LOCATION_SYMBOL].fields[identifier] = {
                  name: identifierSymbol,
                  field: {}
                };
                consume(token_js_1.TokenType.LeftBracket);
                while (!match2(token_js_1.TokenType.RightBracket)) {
                  const { value: keyword2, location: keywordLocation2 } = consume(token_js_1.TokenType.Keyword, lexer.COLLECTION_FORM_LAYOUT_KEYWORDS);
                  switch (keyword2) {
                    case "if": {
                      const ifTerms = [];
                      fields[identifier].if = parseCondition(ifTerms);
                      node[AST2.LOCATION_SYMBOL].terms = ifTerms;
                      break;
                    }
                    case "span":
                    case "verticalSpacing": {
                      fields[identifier].span = consume(token_js_1.TokenType.Number).value;
                      break;
                    }
                    case "separator": {
                      fields[identifier].separator = match2(token_js_1.TokenType.Boolean) ? consume(token_js_1.TokenType.Boolean).value : consume(token_js_1.TokenType.QuotedString, [
                        "top",
                        "bottom"
                      ]).value;
                      break;
                    }
                    default: {
                      throw new diagnostic_js_1.Diagnostic(`invalid keyword "${keyword2}"`, keywordLocation2);
                    }
                  }
                }
                consume(token_js_1.TokenType.RightBracket);
              }
              consume(token_js_1.TokenType.RightBracket);
              break;
            }
            default: {
              throw new diagnostic_js_1.Diagnostic(`invalid keyword "${keyword}"`, keywordLocation);
            }
          }
        }
        consume(token_js_1.TokenType.RightBracket);
        return node;
      };
      const parseCondition = (symbols = []) => {
        if (match2(token_js_1.TokenType.LeftParens)) {
          consume(token_js_1.TokenType.LeftParens);
          let operatorType, newOp = operatorType;
          const conditions = [];
          while (!match2(token_js_1.TokenType.RightParens)) {
            conditions.push(parseCondition(symbols));
            if (match2(token_js_1.TokenType.RightParens)) {
              break;
            }
            const { value: operatorSymbol2, location: location2 } = consume(token_js_1.TokenType.Operator);
            switch (operatorSymbol2) {
              case "&&":
                newOp = "and";
                break;
              case "||":
                newOp = "or";
                break;
              default: {
                throw new diagnostic_js_1.Diagnostic(`unsupported operator: "${operatorSymbol2}"`, location2);
              }
            }
            if (operatorType && operatorType !== newOp) {
              throw new diagnostic_js_1.Diagnostic('having "and" or "or" in the same expression is not supported, please use parenthesis', location2);
            }
            operatorType = newOp;
          }
          consume(token_js_1.TokenType.RightParens);
          switch (operatorType) {
            case "and": {
              return {
                and: conditions
              };
            }
            case "or": {
              return {
                or: conditions
              };
            }
            default: {
              return conditions[0];
            }
          }
        }
        if (match2(token_js_1.TokenType.Operator, "!")) {
          consume(token_js_1.TokenType.Operator);
          return {
            not: parseCondition(symbols)
          };
        }
        const { value: term1, location: term1Location } = consume(token_js_1.TokenType.Identifier);
        const term1Symbol = Symbol();
        exports2.locationMap.set(term1Symbol, term1Location);
        symbols.push([
          term1,
          term1Symbol
        ]);
        if (!match2(token_js_1.TokenType.Operator, lexer.FINAL_OPERATORS)) {
          return {
            operator: "truthy",
            term1
          };
        }
        const { value: operatorSymbol, location } = consume(token_js_1.TokenType.Operator);
        let term2;
        if (match2(token_js_1.TokenType.LeftParens)) {
          term2 = parseCondition(symbols);
        } else if (match2(token_js_1.TokenType.LeftSquareBracket)) {
          term2 = parseArray([
            token_js_1.TokenType.QuotedString,
            token_js_1.TokenType.Number
          ]).value;
        } else {
          term2 = current().value;
          advance();
        }
        let operator;
        switch (operatorSymbol) {
          case "==":
            operator = "equal";
            break;
          case "in":
            operator = "in";
            break;
          case ">=":
            operator = "gte";
            break;
          case "<=":
            operator = "lte";
            break;
          case ">":
            operator = "gt";
            break;
          case "<":
            operator = "lt";
            break;
          default: {
            throw new diagnostic_js_1.Diagnostic(`unsupported operator: "${operatorSymbol}"`, location);
          }
        }
        return {
          operator,
          term1,
          term2
        };
      };
      while (index < tokens.length) {
        const { value: declType, location } = current();
        try {
          switch (declType) {
            case "collection": {
              const collection = parseCollection();
              if (collection.name === "User") {
                const { properties } = collection;
                if ("roles" in properties && "items" in properties.roles.property && "enum" in properties.roles.property.items) {
                  exports2.memoTable.roles = properties.roles.property.items.enum;
                }
              }
              ast.collections.push(collection);
              break;
            }
            case "contract": {
              ast.contracts.push(parseContract());
              break;
            }
            case "functionset": {
              ast.functionsets.push(parseFunctionSet());
              break;
            }
            default:
              throw new diagnostic_js_1.Diagnostic(`invalid declaration type: "${declType}"`, location);
          }
        } catch (err) {
          if (err instanceof diagnostic_js_1.Diagnostic) {
            errors.push(err);
            recover(lexer.TOPLEVEL_KEYWORDS);
            continue;
          }
          throw err;
        }
      }
      return {
        ast,
        errors
      };
    };
    exports2.parse = parse;
  }
});

// ../../../sonata-api/packages/common/dist/arraysIntersect.js
var require_arraysIntersect = __commonJS({
  "../../../sonata-api/packages/common/dist/arraysIntersect.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.arraysIntersect = void 0;
    var arraysIntersect = (subject, arr) => {
      if (!arr) {
        return false;
      }
      return Array.isArray(subject) ? subject.some((e) => arr.includes(e)) : arr.includes(subject);
    };
    exports2.arraysIntersect = arraysIntersect;
  }
});

// ../../../sonata-api/packages/common/dist/checkForEmptiness.js
var require_checkForEmptiness = __commonJS({
  "../../../sonata-api/packages/common/dist/checkForEmptiness.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.checkForEmptiness = void 0;
    var checkForEmptiness = (property, propName, what) => {
      if (property.readOnly || property.isTimestamp) {
        return false;
      }
      return what[propName] === null || what[propName] === void 0 || what[propName] === "";
    };
    exports2.checkForEmptiness = checkForEmptiness;
  }
});

// ../../../sonata-api/packages/common/dist/deepClone.js
var require_deepClone = __commonJS({
  "../../../sonata-api/packages/common/dist/deepClone.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.deepClone = void 0;
    var deepClone = (obj) => {
      return typeof structuredClone === "function" && typeof window === "undefined" ? structuredClone(obj) : JSON.parse(JSON.stringify(obj));
    };
    exports2.deepClone = deepClone;
  }
});

// ../../../sonata-api/packages/common/dist/deepMerge.js
var require_deepMerge = __commonJS({
  "../../../sonata-api/packages/common/dist/deepMerge.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.deepMerge = void 0;
    var deepMerge = (left, right, options) => {
      const result = Object.assign({}, left);
      const { arrays = true } = options || {};
      for (const key in right) {
        const leftVal = result[key];
        const rightVal = right[key];
        if (options?.callback) {
          const res = options.callback(key, leftVal, rightVal);
          if (res !== void 0) {
            result[key] = res;
            continue;
          }
        }
        if (Array.isArray(result[key]) && Array.isArray(rightVal)) {
          result[key] = arrays ? result[key].concat(...rightVal) : rightVal;
          continue;
        }
        if (rightVal instanceof Function) {
          result[key] = rightVal;
          continue;
        }
        if (leftVal instanceof Object && rightVal instanceof Object) {
          if (rightVal.constructor !== Object) {
            result[key] = rightVal;
            continue;
          }
          result[key] = (0, exports2.deepMerge)(leftVal, rightVal, options);
          continue;
        }
        result[key] = rightVal;
      }
      return result;
    };
    exports2.deepMerge = deepMerge;
  }
});

// ../../../sonata-api/packages/common/dist/dynamicImport.js
var require_dynamicImport = __commonJS({
  "../../../sonata-api/packages/common/dist/dynamicImport.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.dynamicImport = void 0;
    var dynamicImport = async (path2) => {
      try {
        return require(path2);
      } catch (err) {
      }
      const fn = new Function(`return (async () => {
      const { pathToFileURL } = await import('url')
      return import(pathToFileURL('${path2.replace(/\\/g, "\\\\")}'))
    })()`);
      return fn();
    };
    exports2.dynamicImport = dynamicImport;
  }
});

// ../../../sonata-api/packages/common/dist/result.js
var require_result2 = __commonJS({
  "../../../sonata-api/packages/common/dist/result.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.throwIfError = exports2.isError = exports2.isResult = exports2.isEither = void 0;
    var isEither = (value) => {
      return !!(value && typeof value === "object" && "_tag" in value && (value._tag === "Error" || value._tag === "Result"));
    };
    exports2.isEither = isEither;
    var isResult = (value) => {
      return !!((0, exports2.isEither)(value) && value.result);
    };
    exports2.isResult = isResult;
    var isError = (value) => {
      return !!((0, exports2.isEither)(value) && value.error);
    };
    exports2.isError = isError;
    var throwIfError = (either, message) => {
      if (either.error) {
        if (process.env.NODE_ENV !== "production") {
          console.trace(JSON.stringify(either.error, null, 2));
        }
        throw new Error(`throwIfError threw: ${either.error} ${message ? `(${message})` : ""}`);
      }
      return either.result;
    };
    exports2.throwIfError = throwIfError;
  }
});

// ../../../sonata-api/packages/common/dist/endpointError.js
var require_endpointError2 = __commonJS({
  "../../../sonata-api/packages/common/dist/endpointError.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isEndpointError = exports2.endpointError = void 0;
    var types_1 = require_dist();
    var result_js_1 = require_result2();
    var endpointError = (value) => {
      return types_1.Result.error(Object.assign({
        [types_1.ERROR_SYMBOL]: true
      }, value));
    };
    exports2.endpointError = endpointError;
    var isEndpointError = (object) => {
      return !!((0, result_js_1.isError)(object) && object.error && typeof object.error === "object" && (types_1.ERROR_SYMBOL in object.error || types_1.ERROR_SYMBOL_DESCRIPTION in object.error));
    };
    exports2.isEndpointError = isEndpointError;
  }
});

// ../../../sonata-api/packages/common/dist/evaluateCondition.js
var require_evaluateCondition = __commonJS({
  "../../../sonata-api/packages/common/dist/evaluateCondition.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.evaluateCondition = void 0;
    var arraysIntersect_js_1 = require_arraysIntersect();
    var isCondition = (subject) => {
      if (!subject || typeof subject !== "object") {
        return false;
      }
      return "and" in subject || "or" in subject || "not" in subject || "operator" in subject && "term1" in subject;
    };
    var equalOrContains = (term1, term2) => {
      if (Array.isArray(term1) && Array.isArray(term2)) {
        return (0, arraysIntersect_js_1.arraysIntersect)(term1, term2);
      }
      if (Array.isArray(term1)) {
        return term1.includes(term2);
      }
      if (Array.isArray(term2)) {
        return term2.includes(term1);
      }
    };
    var evaluateExpression = (subject, expression) => {
      if (!isCondition(expression)) {
        return expression;
      }
      if ("term1" in expression) {
        if (!subject || typeof subject !== "object") {
          return false;
        }
        const term1 = subject[expression.term1];
        if (expression.operator === "truthy") {
          return !!term1;
        }
        const { operator, term2 } = expression;
        const right = evaluateExpression(subject, term2);
        switch (operator) {
          case "equal":
            return term1 === right;
          case "in":
            return !!equalOrContains(term1, right);
          case "gt":
            return term1 > Number(right);
          case "lt":
            return term1 < Number(right);
          case "gte":
            return term1 >= Number(right);
          case "lte":
            return term1 <= Number(right);
          case "regex":
            return new RegExp(right).test(term1);
        }
      }
      if ("and" in expression) {
        return expression.and.every((expression2) => evaluateExpression(subject, expression2));
      }
      if ("or" in expression) {
        return expression.or.some((expression2) => evaluateExpression(subject, expression2));
      }
      if ("not" in expression) {
        return !evaluateExpression(subject, expression.not);
      }
      return false;
    };
    var evaluateCondition = (subject, condition) => {
      const result = {
        satisfied: false,
        else: null
      };
      const satisfied = result.satisfied = !!evaluateExpression(subject, condition);
      if (!satisfied && "else" in condition) {
        result.else = condition.else;
      }
      return result;
    };
    exports2.evaluateCondition = evaluateCondition;
  }
});

// ../../../sonata-api/packages/common/dist/freshItem.js
var require_freshItem = __commonJS({
  "../../../sonata-api/packages/common/dist/freshItem.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.freshItem = exports2.freshProperty = void 0;
    var freshProperty = (property) => {
      const value = (() => {
        if ("$ref" in property && property.inline) {
          return {};
        }
        if ("properties" in property) {
          const obj = {};
          for (const propName in property.properties) {
            obj[propName] = (0, exports2.freshProperty)(property.properties[propName]);
          }
          return obj;
        }
        if ("type" in property) {
          switch (property.type) {
            case "boolean":
              return false;
            case "array":
              return [];
            case "object":
              return {};
          }
        }
        return null;
      })();
      return value;
    };
    exports2.freshProperty = freshProperty;
    var freshItem = (description) => {
      const item = {};
      for (const propName in description.properties) {
        const value = (0, exports2.freshProperty)(description.properties[propName]);
        if (value !== null) {
          item[propName] = value;
        }
      }
      if (description.freshItem) {
        Object.assign(item, description.freshItem);
      }
      return item;
    };
    exports2.freshItem = freshItem;
  }
});

// ../../../sonata-api/packages/common/dist/getMissingProperties.js
var require_getMissingProperties = __commonJS({
  "../../../sonata-api/packages/common/dist/getMissingProperties.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getMissingProperties = void 0;
    var checkForEmptiness_js_1 = require_checkForEmptiness();
    var evaluateCondition_js_1 = require_evaluateCondition();
    var getMissingProperties = (what, schema, required) => {
      const missingProps = [];
      if (Array.isArray(required)) {
        for (const propName of required) {
          const isMissing = (0, checkForEmptiness_js_1.checkForEmptiness)(schema.properties[propName], propName, what);
          if (isMissing) {
            missingProps.push(propName);
          }
        }
      } else {
        for (const propName in required) {
          const requiredProp = required[propName];
          if (typeof requiredProp === "boolean") {
            if (!requiredProp) {
              continue;
            }
          }
          if (typeof requiredProp === "object") {
            const result = (0, evaluateCondition_js_1.evaluateCondition)(what, requiredProp);
            if (!result.satisfied) {
              continue;
            }
          }
          const isMissing = (0, checkForEmptiness_js_1.checkForEmptiness)(schema.properties[propName], propName, what);
          if (isMissing) {
            missingProps.push(propName);
          }
        }
      }
      return missingProps;
    };
    exports2.getMissingProperties = getMissingProperties;
  }
});

// ../../../sonata-api/packages/common/dist/getReferenceProperty.js
var require_getReferenceProperty = __commonJS({
  "../../../sonata-api/packages/common/dist/getReferenceProperty.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getReferenceProperty = void 0;
    var getReferenceProperty = (property) => {
      const search = [
        "items" in property ? property.items : null,
        "additionalProperties" in property && typeof property.additionalProperties === "object" ? property.additionalProperties : null,
        property
      ];
      const reference = search.find((_) => !!_);
      return reference && "$ref" in reference ? reference : null;
    };
    exports2.getReferenceProperty = getReferenceProperty;
  }
});

// ../../../sonata-api/packages/common/dist/getValueFromPath.js
var require_getValueFromPath = __commonJS({
  "../../../sonata-api/packages/common/dist/getValueFromPath.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getValueFromPath = void 0;
    var getValueFromPath = (object, path2) => {
      const fragments = path2.split(".");
      return fragments.reduce((a, fragment) => {
        return a && a[fragment];
      }, object);
    };
    exports2.getValueFromPath = getValueFromPath;
  }
});

// ../../../sonata-api/packages/common/dist/http.js
var require_http2 = __commonJS({
  "../../../sonata-api/packages/common/dist/http.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.request = exports2.defaultResponseTransformer = exports2.defaultRequestTransformer = void 0;
    var defaultRequestTransformer = async (context) => {
      if (context.payload) {
        if (context.params.method === "GET" || context.params.method === "HEAD") {
          context.url += `?${new URLSearchParams(context.payload)}`;
        } else {
          context.params.body = context.params.headers?.["content-type"]?.startsWith("application/json") ? JSON.stringify(context.payload) : context.payload;
        }
      }
      return context;
    };
    exports2.defaultRequestTransformer = defaultRequestTransformer;
    var defaultResponseTransformer = async (context) => {
      const result = context.response;
      result.data = await context.response.text();
      if (context.response.headers.get("content-type")?.startsWith("application/json")) {
        result.data = JSON.parse(String(result.data));
      }
      context.response = result;
      return context;
    };
    exports2.defaultResponseTransformer = defaultResponseTransformer;
    var request = async (url, payload, config = {}) => {
      const { requestTransformer, responseTransformer } = config;
      let params;
      if (config.params) {
        params = config.params;
      } else {
        if (payload) {
          params = {
            method: "POST",
            headers: {
              "content-type": "application/json"
            }
          };
        } else {
          params = {
            method: "GET"
          };
        }
      }
      let transformedRequest = {
        url,
        payload,
        params
      };
      if (requestTransformer) {
        transformedRequest = await requestTransformer(transformedRequest, exports2.defaultRequestTransformer);
      } else {
        transformedRequest = await (0, exports2.defaultRequestTransformer)(transformedRequest);
      }
      const response = await fetch(transformedRequest.url, transformedRequest.params);
      let transformedResponse = {
        response
      };
      if (responseTransformer) {
        transformedResponse = await responseTransformer(transformedResponse, exports2.defaultResponseTransformer);
      } else {
        transformedResponse = await (0, exports2.defaultResponseTransformer)(transformedResponse);
      }
      return transformedResponse.response;
    };
    exports2.request = request;
  }
});

// ../../../sonata-api/packages/common/dist/isGranted.js
var require_isGranted = __commonJS({
  "../../../sonata-api/packages/common/dist/isGranted.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isGranted = void 0;
    var arraysIntersect_js_1 = require_arraysIntersect();
    var isGranted = (condition, token) => {
      if (Array.isArray(condition)) {
        return token.authenticated ? (0, arraysIntersect_js_1.arraysIntersect)(token.roles, condition) : condition.includes("unauthenticated");
      }
      switch (condition) {
        case false:
        case void 0:
          return false;
        case true:
          return token.authenticated;
        case "unauthenticated":
          return true;
        case "unauthenticated-only":
          return !token.authenticated;
      }
    };
    exports2.isGranted = isGranted;
  }
});

// ../../../sonata-api/packages/common/dist/isReference.js
var require_isReference = __commonJS({
  "../../../sonata-api/packages/common/dist/isReference.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isReference = void 0;
    var isReference = (property) => {
      return "items" in property ? "$ref" in property.items : "$ref" in property;
    };
    exports2.isReference = isReference;
  }
});

// ../../../sonata-api/packages/common/dist/isRequired.js
var require_isRequired = __commonJS({
  "../../../sonata-api/packages/common/dist/isRequired.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isRequired = void 0;
    var evaluateCondition_js_1 = require_evaluateCondition();
    var isRequired = (propName, required, subject) => {
      if (Array.isArray(required)) {
        return required.includes(propName);
      }
      if (!(propName in required)) {
        return false;
      }
      const requiredProp = required[propName];
      if (typeof requiredProp !== "object") {
        return requiredProp;
      }
      return (0, evaluateCondition_js_1.evaluateCondition)(subject, requiredProp).satisfied;
    };
    exports2.isRequired = isRequired;
  }
});

// ../../../sonata-api/packages/common/dist/isValidCollection.js
var require_isValidCollection = __commonJS({
  "../../../sonata-api/packages/common/dist/isValidCollection.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isValidCollection = exports2.isValidDescription = void 0;
    var isValidDescription = (value) => {
      return !!(value && typeof value === "object" && "$id" in value && "properties" in value && value.properties && typeof value.$id === "string" && typeof value.properties === "object");
    };
    exports2.isValidDescription = isValidDescription;
    var isValidCollection = (value) => {
      return !!(value && typeof value === "object" && "description" in value && (0, exports2.isValidDescription)(value.description));
    };
    exports2.isValidCollection = isValidCollection;
  }
});

// ../../../sonata-api/packages/common/dist/convertConditionToQuery.js
var require_convertConditionToQuery = __commonJS({
  "../../../sonata-api/packages/common/dist/convertConditionToQuery.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.convertConditionToQuery = void 0;
    var getValueFromPath_js_1 = require_getValueFromPath();
    var convertExpression = (condition, subject) => {
      let term2 = null;
      if ("term2" in condition) {
        if (condition.fromState) {
          term2 = subject && typeof condition.term2 === "string" ? (0, getValueFromPath_js_1.getValueFromPath)(subject, condition.term2) : null;
        } else {
          term2 = condition.term2;
        }
      }
      switch (condition.operator) {
        case "truthy":
          return {
            $ne: [
              null,
              void 0
            ]
          };
        case "equal":
          return term2;
        case "gt":
          return {
            $gt: term2
          };
        case "lt":
          return {
            $lt: term2
          };
        case "gte":
          return {
            $gte: term2
          };
        case "lte":
          return {
            $lte: term2
          };
        case "regex":
          return {
            $regex: term2,
            $options: condition.regexOptions
          };
        case "in": {
          return Array.isArray(term2) ? {
            $in: term2
          } : term2;
        }
      }
    };
    var convertConditionToQuery = (condition, subject) => {
      if ("or" in condition) {
        return {
          $or: condition.or.map((sub) => (0, exports2.convertConditionToQuery)(sub, subject))
        };
      }
      if ("and" in condition) {
        return {
          $and: condition.and.map((sub) => (0, exports2.convertConditionToQuery)(sub, subject))
        };
      }
      if ("not" in condition) {
        return {
          $not: (0, exports2.convertConditionToQuery)(condition.not, subject)
        };
      }
      return {
        [condition.term1]: convertExpression(condition, subject)
      };
    };
    exports2.convertConditionToQuery = convertConditionToQuery;
  }
});

// ../../../sonata-api/packages/common/dist/pipe.js
var require_pipe = __commonJS({
  "../../../sonata-api/packages/common/dist/pipe.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.pipe = void 0;
    var pipe = (functions, options) => {
      const { returnFirst } = options || {};
      return async (value, ...args) => {
        let ret = value;
        for (const fn of functions) {
          ret = await fn(ret, ...args);
          if (returnFirst && ret !== void 0) {
            switch (typeof returnFirst) {
              case "function": {
                const result = returnFirst(ret);
                if (result !== void 0) {
                  return result;
                }
                break;
              }
              default: {
                return ret;
              }
            }
          }
        }
        return ret;
      };
    };
    exports2.pipe = pipe;
  }
});

// ../../../sonata-api/node_modules/.pnpm/bson@6.10.3/node_modules/bson/lib/bson.cjs
var require_bson = __commonJS({
  "../../../sonata-api/node_modules/.pnpm/bson@6.10.3/node_modules/bson/lib/bson.cjs"(exports2) {
    "use strict";
    init_importMeta();
    var TypedArrayPrototypeGetSymbolToStringTag = (() => {
      const g = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Uint8Array.prototype), Symbol.toStringTag).get;
      return (value) => g.call(value);
    })();
    function isUint8Array(value) {
      return TypedArrayPrototypeGetSymbolToStringTag(value) === "Uint8Array";
    }
    function isAnyArrayBuffer(value) {
      return typeof value === "object" && value != null && Symbol.toStringTag in value && (value[Symbol.toStringTag] === "ArrayBuffer" || value[Symbol.toStringTag] === "SharedArrayBuffer");
    }
    function isRegExp(regexp2) {
      return regexp2 instanceof RegExp || Object.prototype.toString.call(regexp2) === "[object RegExp]";
    }
    function isMap(value) {
      return typeof value === "object" && value != null && Symbol.toStringTag in value && value[Symbol.toStringTag] === "Map";
    }
    function isDate(date) {
      return date instanceof Date || Object.prototype.toString.call(date) === "[object Date]";
    }
    function defaultInspect(x, _options) {
      return JSON.stringify(x, (k, v) => {
        if (typeof v === "bigint") {
          return { $numberLong: `${v}` };
        } else if (isMap(v)) {
          return Object.fromEntries(v);
        }
        return v;
      });
    }
    function getStylizeFunction(options) {
      const stylizeExists = options != null && typeof options === "object" && "stylize" in options && typeof options.stylize === "function";
      if (stylizeExists) {
        return options.stylize;
      }
    }
    var BSON_MAJOR_VERSION = 6;
    var BSON_VERSION_SYMBOL = Symbol.for("@@mdb.bson.version");
    var BSON_INT32_MAX = 2147483647;
    var BSON_INT32_MIN = -2147483648;
    var BSON_INT64_MAX = Math.pow(2, 63) - 1;
    var BSON_INT64_MIN = -Math.pow(2, 63);
    var JS_INT_MAX = Math.pow(2, 53);
    var JS_INT_MIN = -Math.pow(2, 53);
    var BSON_DATA_NUMBER = 1;
    var BSON_DATA_STRING = 2;
    var BSON_DATA_OBJECT = 3;
    var BSON_DATA_ARRAY = 4;
    var BSON_DATA_BINARY = 5;
    var BSON_DATA_UNDEFINED = 6;
    var BSON_DATA_OID = 7;
    var BSON_DATA_BOOLEAN = 8;
    var BSON_DATA_DATE = 9;
    var BSON_DATA_NULL = 10;
    var BSON_DATA_REGEXP = 11;
    var BSON_DATA_DBPOINTER = 12;
    var BSON_DATA_CODE = 13;
    var BSON_DATA_SYMBOL = 14;
    var BSON_DATA_CODE_W_SCOPE = 15;
    var BSON_DATA_INT = 16;
    var BSON_DATA_TIMESTAMP = 17;
    var BSON_DATA_LONG = 18;
    var BSON_DATA_DECIMAL128 = 19;
    var BSON_DATA_MIN_KEY = 255;
    var BSON_DATA_MAX_KEY = 127;
    var BSON_BINARY_SUBTYPE_DEFAULT = 0;
    var BSON_BINARY_SUBTYPE_UUID_NEW = 4;
    var BSONType = Object.freeze({
      double: 1,
      string: 2,
      object: 3,
      array: 4,
      binData: 5,
      undefined: 6,
      objectId: 7,
      bool: 8,
      date: 9,
      null: 10,
      regex: 11,
      dbPointer: 12,
      javascript: 13,
      symbol: 14,
      javascriptWithScope: 15,
      int: 16,
      timestamp: 17,
      long: 18,
      decimal: 19,
      minKey: -1,
      maxKey: 127
    });
    var BSONError = class extends Error {
      get bsonError() {
        return true;
      }
      get name() {
        return "BSONError";
      }
      constructor(message, options) {
        super(message, options);
      }
      static isBSONError(value) {
        return value != null && typeof value === "object" && "bsonError" in value && value.bsonError === true && "name" in value && "message" in value && "stack" in value;
      }
    };
    var BSONVersionError = class extends BSONError {
      get name() {
        return "BSONVersionError";
      }
      constructor() {
        super(`Unsupported BSON version, bson types must be from bson ${BSON_MAJOR_VERSION}.x.x`);
      }
    };
    var BSONRuntimeError = class extends BSONError {
      get name() {
        return "BSONRuntimeError";
      }
      constructor(message) {
        super(message);
      }
    };
    var BSONOffsetError = class extends BSONError {
      get name() {
        return "BSONOffsetError";
      }
      constructor(message, offset, options) {
        super(`${message}. offset: ${offset}`, options);
        this.offset = offset;
      }
    };
    var TextDecoderFatal;
    var TextDecoderNonFatal;
    function parseUtf8(buffer2, start, end, fatal) {
      if (fatal) {
        TextDecoderFatal ??= new TextDecoder("utf8", { fatal: true });
        try {
          return TextDecoderFatal.decode(buffer2.subarray(start, end));
        } catch (cause) {
          throw new BSONError("Invalid UTF-8 string in BSON document", { cause });
        }
      }
      TextDecoderNonFatal ??= new TextDecoder("utf8", { fatal: false });
      return TextDecoderNonFatal.decode(buffer2.subarray(start, end));
    }
    function tryReadBasicLatin(uint8array, start, end) {
      if (uint8array.length === 0) {
        return "";
      }
      const stringByteLength = end - start;
      if (stringByteLength === 0) {
        return "";
      }
      if (stringByteLength > 20) {
        return null;
      }
      if (stringByteLength === 1 && uint8array[start] < 128) {
        return String.fromCharCode(uint8array[start]);
      }
      if (stringByteLength === 2 && uint8array[start] < 128 && uint8array[start + 1] < 128) {
        return String.fromCharCode(uint8array[start]) + String.fromCharCode(uint8array[start + 1]);
      }
      if (stringByteLength === 3 && uint8array[start] < 128 && uint8array[start + 1] < 128 && uint8array[start + 2] < 128) {
        return String.fromCharCode(uint8array[start]) + String.fromCharCode(uint8array[start + 1]) + String.fromCharCode(uint8array[start + 2]);
      }
      const latinBytes = [];
      for (let i = start; i < end; i++) {
        const byte = uint8array[i];
        if (byte > 127) {
          return null;
        }
        latinBytes.push(byte);
      }
      return String.fromCharCode(...latinBytes);
    }
    function tryWriteBasicLatin(destination, source, offset) {
      if (source.length === 0)
        return 0;
      if (source.length > 25)
        return null;
      if (destination.length - offset < source.length)
        return null;
      for (let charOffset = 0, destinationOffset = offset; charOffset < source.length; charOffset++, destinationOffset++) {
        const char = source.charCodeAt(charOffset);
        if (char > 127)
          return null;
        destination[destinationOffset] = char;
      }
      return source.length;
    }
    function nodejsMathRandomBytes(byteLength) {
      return nodeJsByteUtils.fromNumberArray(Array.from({ length: byteLength }, () => Math.floor(Math.random() * 256)));
    }
    var nodejsRandomBytes = (() => {
      try {
        return require("crypto").randomBytes;
      } catch {
        return nodejsMathRandomBytes;
      }
    })();
    var nodeJsByteUtils = {
      toLocalBufferType(potentialBuffer) {
        if (Buffer.isBuffer(potentialBuffer)) {
          return potentialBuffer;
        }
        if (ArrayBuffer.isView(potentialBuffer)) {
          return Buffer.from(potentialBuffer.buffer, potentialBuffer.byteOffset, potentialBuffer.byteLength);
        }
        const stringTag = potentialBuffer?.[Symbol.toStringTag] ?? Object.prototype.toString.call(potentialBuffer);
        if (stringTag === "ArrayBuffer" || stringTag === "SharedArrayBuffer" || stringTag === "[object ArrayBuffer]" || stringTag === "[object SharedArrayBuffer]") {
          return Buffer.from(potentialBuffer);
        }
        throw new BSONError(`Cannot create Buffer from the passed potentialBuffer.`);
      },
      allocate(size) {
        return Buffer.alloc(size);
      },
      allocateUnsafe(size) {
        return Buffer.allocUnsafe(size);
      },
      equals(a, b) {
        return nodeJsByteUtils.toLocalBufferType(a).equals(b);
      },
      fromNumberArray(array) {
        return Buffer.from(array);
      },
      fromBase64(base64) {
        return Buffer.from(base64, "base64");
      },
      toBase64(buffer2) {
        return nodeJsByteUtils.toLocalBufferType(buffer2).toString("base64");
      },
      fromISO88591(codePoints) {
        return Buffer.from(codePoints, "binary");
      },
      toISO88591(buffer2) {
        return nodeJsByteUtils.toLocalBufferType(buffer2).toString("binary");
      },
      fromHex(hex) {
        return Buffer.from(hex, "hex");
      },
      toHex(buffer2) {
        return nodeJsByteUtils.toLocalBufferType(buffer2).toString("hex");
      },
      toUTF8(buffer2, start, end, fatal) {
        const basicLatin = end - start <= 20 ? tryReadBasicLatin(buffer2, start, end) : null;
        if (basicLatin != null) {
          return basicLatin;
        }
        const string = nodeJsByteUtils.toLocalBufferType(buffer2).toString("utf8", start, end);
        if (fatal) {
          for (let i = 0; i < string.length; i++) {
            if (string.charCodeAt(i) === 65533) {
              parseUtf8(buffer2, start, end, true);
              break;
            }
          }
        }
        return string;
      },
      utf8ByteLength(input) {
        return Buffer.byteLength(input, "utf8");
      },
      encodeUTF8Into(buffer2, source, byteOffset) {
        const latinBytesWritten = tryWriteBasicLatin(buffer2, source, byteOffset);
        if (latinBytesWritten != null) {
          return latinBytesWritten;
        }
        return nodeJsByteUtils.toLocalBufferType(buffer2).write(source, byteOffset, void 0, "utf8");
      },
      randomBytes: nodejsRandomBytes,
      swap32(buffer2) {
        return nodeJsByteUtils.toLocalBufferType(buffer2).swap32();
      }
    };
    function isReactNative() {
      const { navigator } = globalThis;
      return typeof navigator === "object" && navigator.product === "ReactNative";
    }
    function webMathRandomBytes(byteLength) {
      if (byteLength < 0) {
        throw new RangeError(`The argument 'byteLength' is invalid. Received ${byteLength}`);
      }
      return webByteUtils.fromNumberArray(Array.from({ length: byteLength }, () => Math.floor(Math.random() * 256)));
    }
    var webRandomBytes = (() => {
      const { crypto } = globalThis;
      if (crypto != null && typeof crypto.getRandomValues === "function") {
        return (byteLength) => {
          return crypto.getRandomValues(webByteUtils.allocate(byteLength));
        };
      } else {
        if (isReactNative()) {
          const { console: console2 } = globalThis;
          console2?.warn?.("BSON: For React Native please polyfill crypto.getRandomValues, e.g. using: https://www.npmjs.com/package/react-native-get-random-values.");
        }
        return webMathRandomBytes;
      }
    })();
    var HEX_DIGIT = /(\d|[a-f])/i;
    var webByteUtils = {
      toLocalBufferType(potentialUint8array) {
        const stringTag = potentialUint8array?.[Symbol.toStringTag] ?? Object.prototype.toString.call(potentialUint8array);
        if (stringTag === "Uint8Array") {
          return potentialUint8array;
        }
        if (ArrayBuffer.isView(potentialUint8array)) {
          return new Uint8Array(potentialUint8array.buffer.slice(potentialUint8array.byteOffset, potentialUint8array.byteOffset + potentialUint8array.byteLength));
        }
        if (stringTag === "ArrayBuffer" || stringTag === "SharedArrayBuffer" || stringTag === "[object ArrayBuffer]" || stringTag === "[object SharedArrayBuffer]") {
          return new Uint8Array(potentialUint8array);
        }
        throw new BSONError(`Cannot make a Uint8Array from passed potentialBuffer.`);
      },
      allocate(size) {
        if (typeof size !== "number") {
          throw new TypeError(`The "size" argument must be of type number. Received ${String(size)}`);
        }
        return new Uint8Array(size);
      },
      allocateUnsafe(size) {
        return webByteUtils.allocate(size);
      },
      equals(a, b) {
        if (a.byteLength !== b.byteLength) {
          return false;
        }
        for (let i = 0; i < a.byteLength; i++) {
          if (a[i] !== b[i]) {
            return false;
          }
        }
        return true;
      },
      fromNumberArray(array) {
        return Uint8Array.from(array);
      },
      fromBase64(base64) {
        return Uint8Array.from(atob(base64), (c) => c.charCodeAt(0));
      },
      toBase64(uint8array) {
        return btoa(webByteUtils.toISO88591(uint8array));
      },
      fromISO88591(codePoints) {
        return Uint8Array.from(codePoints, (c) => c.charCodeAt(0) & 255);
      },
      toISO88591(uint8array) {
        return Array.from(Uint16Array.from(uint8array), (b) => String.fromCharCode(b)).join("");
      },
      fromHex(hex) {
        const evenLengthHex = hex.length % 2 === 0 ? hex : hex.slice(0, hex.length - 1);
        const buffer2 = [];
        for (let i = 0; i < evenLengthHex.length; i += 2) {
          const firstDigit = evenLengthHex[i];
          const secondDigit = evenLengthHex[i + 1];
          if (!HEX_DIGIT.test(firstDigit)) {
            break;
          }
          if (!HEX_DIGIT.test(secondDigit)) {
            break;
          }
          const hexDigit = Number.parseInt(`${firstDigit}${secondDigit}`, 16);
          buffer2.push(hexDigit);
        }
        return Uint8Array.from(buffer2);
      },
      toHex(uint8array) {
        return Array.from(uint8array, (byte) => byte.toString(16).padStart(2, "0")).join("");
      },
      toUTF8(uint8array, start, end, fatal) {
        const basicLatin = end - start <= 20 ? tryReadBasicLatin(uint8array, start, end) : null;
        if (basicLatin != null) {
          return basicLatin;
        }
        return parseUtf8(uint8array, start, end, fatal);
      },
      utf8ByteLength(input) {
        return new TextEncoder().encode(input).byteLength;
      },
      encodeUTF8Into(uint8array, source, byteOffset) {
        const bytes = new TextEncoder().encode(source);
        uint8array.set(bytes, byteOffset);
        return bytes.byteLength;
      },
      randomBytes: webRandomBytes,
      swap32(buffer2) {
        if (buffer2.length % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (let i = 0; i < buffer2.length; i += 4) {
          const byte0 = buffer2[i];
          const byte1 = buffer2[i + 1];
          const byte2 = buffer2[i + 2];
          const byte3 = buffer2[i + 3];
          buffer2[i] = byte3;
          buffer2[i + 1] = byte2;
          buffer2[i + 2] = byte1;
          buffer2[i + 3] = byte0;
        }
        return buffer2;
      }
    };
    var hasGlobalBuffer = typeof Buffer === "function" && Buffer.prototype?._isBuffer !== true;
    var ByteUtils = hasGlobalBuffer ? nodeJsByteUtils : webByteUtils;
    var BSONValue = class {
      get [BSON_VERSION_SYMBOL]() {
        return BSON_MAJOR_VERSION;
      }
      [Symbol.for("nodejs.util.inspect.custom")](depth, options, inspect) {
        return this.inspect(depth, options, inspect);
      }
    };
    var FLOAT = new Float64Array(1);
    var FLOAT_BYTES = new Uint8Array(FLOAT.buffer, 0, 8);
    FLOAT[0] = -1;
    var isBigEndian = FLOAT_BYTES[7] === 0;
    var NumberUtils = {
      isBigEndian,
      getNonnegativeInt32LE(source, offset) {
        if (source[offset + 3] > 127) {
          throw new RangeError(`Size cannot be negative at offset: ${offset}`);
        }
        return source[offset] | source[offset + 1] << 8 | source[offset + 2] << 16 | source[offset + 3] << 24;
      },
      getInt32LE(source, offset) {
        return source[offset] | source[offset + 1] << 8 | source[offset + 2] << 16 | source[offset + 3] << 24;
      },
      getUint32LE(source, offset) {
        return source[offset] + source[offset + 1] * 256 + source[offset + 2] * 65536 + source[offset + 3] * 16777216;
      },
      getUint32BE(source, offset) {
        return source[offset + 3] + source[offset + 2] * 256 + source[offset + 1] * 65536 + source[offset] * 16777216;
      },
      getBigInt64LE(source, offset) {
        const hi = BigInt(source[offset + 4] + source[offset + 5] * 256 + source[offset + 6] * 65536 + (source[offset + 7] << 24));
        const lo = BigInt(source[offset] + source[offset + 1] * 256 + source[offset + 2] * 65536 + source[offset + 3] * 16777216);
        return (hi << BigInt(32)) + lo;
      },
      getFloat64LE: isBigEndian ? (source, offset) => {
        FLOAT_BYTES[7] = source[offset];
        FLOAT_BYTES[6] = source[offset + 1];
        FLOAT_BYTES[5] = source[offset + 2];
        FLOAT_BYTES[4] = source[offset + 3];
        FLOAT_BYTES[3] = source[offset + 4];
        FLOAT_BYTES[2] = source[offset + 5];
        FLOAT_BYTES[1] = source[offset + 6];
        FLOAT_BYTES[0] = source[offset + 7];
        return FLOAT[0];
      } : (source, offset) => {
        FLOAT_BYTES[0] = source[offset];
        FLOAT_BYTES[1] = source[offset + 1];
        FLOAT_BYTES[2] = source[offset + 2];
        FLOAT_BYTES[3] = source[offset + 3];
        FLOAT_BYTES[4] = source[offset + 4];
        FLOAT_BYTES[5] = source[offset + 5];
        FLOAT_BYTES[6] = source[offset + 6];
        FLOAT_BYTES[7] = source[offset + 7];
        return FLOAT[0];
      },
      setInt32BE(destination, offset, value) {
        destination[offset + 3] = value;
        value >>>= 8;
        destination[offset + 2] = value;
        value >>>= 8;
        destination[offset + 1] = value;
        value >>>= 8;
        destination[offset] = value;
        return 4;
      },
      setInt32LE(destination, offset, value) {
        destination[offset] = value;
        value >>>= 8;
        destination[offset + 1] = value;
        value >>>= 8;
        destination[offset + 2] = value;
        value >>>= 8;
        destination[offset + 3] = value;
        return 4;
      },
      setBigInt64LE(destination, offset, value) {
        const mask32bits = BigInt(4294967295);
        let lo = Number(value & mask32bits);
        destination[offset] = lo;
        lo >>= 8;
        destination[offset + 1] = lo;
        lo >>= 8;
        destination[offset + 2] = lo;
        lo >>= 8;
        destination[offset + 3] = lo;
        let hi = Number(value >> BigInt(32) & mask32bits);
        destination[offset + 4] = hi;
        hi >>= 8;
        destination[offset + 5] = hi;
        hi >>= 8;
        destination[offset + 6] = hi;
        hi >>= 8;
        destination[offset + 7] = hi;
        return 8;
      },
      setFloat64LE: isBigEndian ? (destination, offset, value) => {
        FLOAT[0] = value;
        destination[offset] = FLOAT_BYTES[7];
        destination[offset + 1] = FLOAT_BYTES[6];
        destination[offset + 2] = FLOAT_BYTES[5];
        destination[offset + 3] = FLOAT_BYTES[4];
        destination[offset + 4] = FLOAT_BYTES[3];
        destination[offset + 5] = FLOAT_BYTES[2];
        destination[offset + 6] = FLOAT_BYTES[1];
        destination[offset + 7] = FLOAT_BYTES[0];
        return 8;
      } : (destination, offset, value) => {
        FLOAT[0] = value;
        destination[offset] = FLOAT_BYTES[0];
        destination[offset + 1] = FLOAT_BYTES[1];
        destination[offset + 2] = FLOAT_BYTES[2];
        destination[offset + 3] = FLOAT_BYTES[3];
        destination[offset + 4] = FLOAT_BYTES[4];
        destination[offset + 5] = FLOAT_BYTES[5];
        destination[offset + 6] = FLOAT_BYTES[6];
        destination[offset + 7] = FLOAT_BYTES[7];
        return 8;
      }
    };
    var Binary = class _Binary extends BSONValue {
      get _bsontype() {
        return "Binary";
      }
      constructor(buffer2, subType) {
        super();
        if (!(buffer2 == null) && typeof buffer2 === "string" && !ArrayBuffer.isView(buffer2) && !isAnyArrayBuffer(buffer2) && !Array.isArray(buffer2)) {
          throw new BSONError("Binary can only be constructed from Uint8Array or number[]");
        }
        this.sub_type = subType ?? _Binary.BSON_BINARY_SUBTYPE_DEFAULT;
        if (buffer2 == null) {
          this.buffer = ByteUtils.allocate(_Binary.BUFFER_SIZE);
          this.position = 0;
        } else {
          this.buffer = Array.isArray(buffer2) ? ByteUtils.fromNumberArray(buffer2) : ByteUtils.toLocalBufferType(buffer2);
          this.position = this.buffer.byteLength;
        }
      }
      put(byteValue) {
        if (typeof byteValue === "string" && byteValue.length !== 1) {
          throw new BSONError("only accepts single character String");
        } else if (typeof byteValue !== "number" && byteValue.length !== 1)
          throw new BSONError("only accepts single character Uint8Array or Array");
        let decodedByte;
        if (typeof byteValue === "string") {
          decodedByte = byteValue.charCodeAt(0);
        } else if (typeof byteValue === "number") {
          decodedByte = byteValue;
        } else {
          decodedByte = byteValue[0];
        }
        if (decodedByte < 0 || decodedByte > 255) {
          throw new BSONError("only accepts number in a valid unsigned byte range 0-255");
        }
        if (this.buffer.byteLength > this.position) {
          this.buffer[this.position++] = decodedByte;
        } else {
          const newSpace = ByteUtils.allocate(_Binary.BUFFER_SIZE + this.buffer.length);
          newSpace.set(this.buffer, 0);
          this.buffer = newSpace;
          this.buffer[this.position++] = decodedByte;
        }
      }
      write(sequence, offset) {
        offset = typeof offset === "number" ? offset : this.position;
        if (this.buffer.byteLength < offset + sequence.length) {
          const newSpace = ByteUtils.allocate(this.buffer.byteLength + sequence.length);
          newSpace.set(this.buffer, 0);
          this.buffer = newSpace;
        }
        if (ArrayBuffer.isView(sequence)) {
          this.buffer.set(ByteUtils.toLocalBufferType(sequence), offset);
          this.position = offset + sequence.byteLength > this.position ? offset + sequence.length : this.position;
        } else if (typeof sequence === "string") {
          throw new BSONError("input cannot be string");
        }
      }
      read(position, length) {
        length = length && length > 0 ? length : this.position;
        const end = position + length;
        return this.buffer.subarray(position, end > this.position ? this.position : end);
      }
      value() {
        return this.buffer.length === this.position ? this.buffer : this.buffer.subarray(0, this.position);
      }
      length() {
        return this.position;
      }
      toJSON() {
        return ByteUtils.toBase64(this.buffer.subarray(0, this.position));
      }
      toString(encoding) {
        if (encoding === "hex")
          return ByteUtils.toHex(this.buffer.subarray(0, this.position));
        if (encoding === "base64")
          return ByteUtils.toBase64(this.buffer.subarray(0, this.position));
        if (encoding === "utf8" || encoding === "utf-8")
          return ByteUtils.toUTF8(this.buffer, 0, this.position, false);
        return ByteUtils.toUTF8(this.buffer, 0, this.position, false);
      }
      toExtendedJSON(options) {
        options = options || {};
        if (this.sub_type === _Binary.SUBTYPE_VECTOR) {
          validateBinaryVector(this);
        }
        const base64String = ByteUtils.toBase64(this.buffer);
        const subType = Number(this.sub_type).toString(16);
        if (options.legacy) {
          return {
            $binary: base64String,
            $type: subType.length === 1 ? "0" + subType : subType
          };
        }
        return {
          $binary: {
            base64: base64String,
            subType: subType.length === 1 ? "0" + subType : subType
          }
        };
      }
      toUUID() {
        if (this.sub_type === _Binary.SUBTYPE_UUID) {
          return new UUID(this.buffer.subarray(0, this.position));
        }
        throw new BSONError(`Binary sub_type "${this.sub_type}" is not supported for converting to UUID. Only "${_Binary.SUBTYPE_UUID}" is currently supported.`);
      }
      static createFromHexString(hex, subType) {
        return new _Binary(ByteUtils.fromHex(hex), subType);
      }
      static createFromBase64(base64, subType) {
        return new _Binary(ByteUtils.fromBase64(base64), subType);
      }
      static fromExtendedJSON(doc, options) {
        options = options || {};
        let data;
        let type;
        if ("$binary" in doc) {
          if (options.legacy && typeof doc.$binary === "string" && "$type" in doc) {
            type = doc.$type ? parseInt(doc.$type, 16) : 0;
            data = ByteUtils.fromBase64(doc.$binary);
          } else {
            if (typeof doc.$binary !== "string") {
              type = doc.$binary.subType ? parseInt(doc.$binary.subType, 16) : 0;
              data = ByteUtils.fromBase64(doc.$binary.base64);
            }
          }
        } else if ("$uuid" in doc) {
          type = 4;
          data = UUID.bytesFromString(doc.$uuid);
        }
        if (!data) {
          throw new BSONError(`Unexpected Binary Extended JSON format ${JSON.stringify(doc)}`);
        }
        return type === BSON_BINARY_SUBTYPE_UUID_NEW ? new UUID(data) : new _Binary(data, type);
      }
      inspect(depth, options, inspect) {
        inspect ??= defaultInspect;
        const base64 = ByteUtils.toBase64(this.buffer.subarray(0, this.position));
        const base64Arg = inspect(base64, options);
        const subTypeArg = inspect(this.sub_type, options);
        return `Binary.createFromBase64(${base64Arg}, ${subTypeArg})`;
      }
      toInt8Array() {
        if (this.sub_type !== _Binary.SUBTYPE_VECTOR) {
          throw new BSONError("Binary sub_type is not Vector");
        }
        if (this.buffer[0] !== _Binary.VECTOR_TYPE.Int8) {
          throw new BSONError("Binary datatype field is not Int8");
        }
        return new Int8Array(this.buffer.buffer.slice(this.buffer.byteOffset + 2, this.buffer.byteOffset + this.position));
      }
      toFloat32Array() {
        if (this.sub_type !== _Binary.SUBTYPE_VECTOR) {
          throw new BSONError("Binary sub_type is not Vector");
        }
        if (this.buffer[0] !== _Binary.VECTOR_TYPE.Float32) {
          throw new BSONError("Binary datatype field is not Float32");
        }
        const floatBytes = new Uint8Array(this.buffer.buffer.slice(this.buffer.byteOffset + 2, this.buffer.byteOffset + this.position));
        if (NumberUtils.isBigEndian)
          ByteUtils.swap32(floatBytes);
        return new Float32Array(floatBytes.buffer);
      }
      toPackedBits() {
        if (this.sub_type !== _Binary.SUBTYPE_VECTOR) {
          throw new BSONError("Binary sub_type is not Vector");
        }
        if (this.buffer[0] !== _Binary.VECTOR_TYPE.PackedBit) {
          throw new BSONError("Binary datatype field is not packed bit");
        }
        return new Uint8Array(this.buffer.buffer.slice(this.buffer.byteOffset + 2, this.buffer.byteOffset + this.position));
      }
      toBits() {
        if (this.sub_type !== _Binary.SUBTYPE_VECTOR) {
          throw new BSONError("Binary sub_type is not Vector");
        }
        if (this.buffer[0] !== _Binary.VECTOR_TYPE.PackedBit) {
          throw new BSONError("Binary datatype field is not packed bit");
        }
        const byteCount = this.length() - 2;
        const bitCount = byteCount * 8 - this.buffer[1];
        const bits = new Int8Array(bitCount);
        for (let bitOffset = 0; bitOffset < bits.length; bitOffset++) {
          const byteOffset = bitOffset / 8 | 0;
          const byte = this.buffer[byteOffset + 2];
          const shift = 7 - bitOffset % 8;
          const bit = byte >> shift & 1;
          bits[bitOffset] = bit;
        }
        return bits;
      }
      static fromInt8Array(array) {
        const buffer2 = ByteUtils.allocate(array.byteLength + 2);
        buffer2[0] = _Binary.VECTOR_TYPE.Int8;
        buffer2[1] = 0;
        const intBytes = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);
        buffer2.set(intBytes, 2);
        return new this(buffer2, this.SUBTYPE_VECTOR);
      }
      static fromFloat32Array(array) {
        const binaryBytes = ByteUtils.allocate(array.byteLength + 2);
        binaryBytes[0] = _Binary.VECTOR_TYPE.Float32;
        binaryBytes[1] = 0;
        const floatBytes = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);
        binaryBytes.set(floatBytes, 2);
        if (NumberUtils.isBigEndian)
          ByteUtils.swap32(new Uint8Array(binaryBytes.buffer, 2));
        return new this(binaryBytes, this.SUBTYPE_VECTOR);
      }
      static fromPackedBits(array, padding = 0) {
        const buffer2 = ByteUtils.allocate(array.byteLength + 2);
        buffer2[0] = _Binary.VECTOR_TYPE.PackedBit;
        buffer2[1] = padding;
        buffer2.set(array, 2);
        return new this(buffer2, this.SUBTYPE_VECTOR);
      }
      static fromBits(bits) {
        const byteLength = bits.length + 7 >>> 3;
        const bytes = new Uint8Array(byteLength + 2);
        bytes[0] = _Binary.VECTOR_TYPE.PackedBit;
        const remainder = bits.length % 8;
        bytes[1] = remainder === 0 ? 0 : 8 - remainder;
        for (let bitOffset = 0; bitOffset < bits.length; bitOffset++) {
          const byteOffset = bitOffset >>> 3;
          const bit = bits[bitOffset];
          if (bit !== 0 && bit !== 1) {
            throw new BSONError(`Invalid bit value at ${bitOffset}: must be 0 or 1, found ${bits[bitOffset]}`);
          }
          if (bit === 0)
            continue;
          const shift = 7 - bitOffset % 8;
          bytes[byteOffset + 2] |= bit << shift;
        }
        return new this(bytes, _Binary.SUBTYPE_VECTOR);
      }
    };
    Binary.BSON_BINARY_SUBTYPE_DEFAULT = 0;
    Binary.BUFFER_SIZE = 256;
    Binary.SUBTYPE_DEFAULT = 0;
    Binary.SUBTYPE_FUNCTION = 1;
    Binary.SUBTYPE_BYTE_ARRAY = 2;
    Binary.SUBTYPE_UUID_OLD = 3;
    Binary.SUBTYPE_UUID = 4;
    Binary.SUBTYPE_MD5 = 5;
    Binary.SUBTYPE_ENCRYPTED = 6;
    Binary.SUBTYPE_COLUMN = 7;
    Binary.SUBTYPE_SENSITIVE = 8;
    Binary.SUBTYPE_VECTOR = 9;
    Binary.SUBTYPE_USER_DEFINED = 128;
    Binary.VECTOR_TYPE = Object.freeze({
      Int8: 3,
      Float32: 39,
      PackedBit: 16
    });
    function validateBinaryVector(vector) {
      if (vector.sub_type !== Binary.SUBTYPE_VECTOR)
        return;
      const size = vector.position;
      const datatype = vector.buffer[0];
      const padding = vector.buffer[1];
      if ((datatype === Binary.VECTOR_TYPE.Float32 || datatype === Binary.VECTOR_TYPE.Int8) && padding !== 0) {
        throw new BSONError("Invalid Vector: padding must be zero for int8 and float32 vectors");
      }
      if (datatype === Binary.VECTOR_TYPE.PackedBit && padding !== 0 && size === 2) {
        throw new BSONError("Invalid Vector: padding must be zero for packed bit vectors that are empty");
      }
      if (datatype === Binary.VECTOR_TYPE.PackedBit && padding > 7) {
        throw new BSONError(`Invalid Vector: padding must be a value between 0 and 7. found: ${padding}`);
      }
    }
    var UUID_BYTE_LENGTH = 16;
    var UUID_WITHOUT_DASHES = /^[0-9A-F]{32}$/i;
    var UUID_WITH_DASHES = /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i;
    var UUID = class _UUID extends Binary {
      constructor(input) {
        let bytes;
        if (input == null) {
          bytes = _UUID.generate();
        } else if (input instanceof _UUID) {
          bytes = ByteUtils.toLocalBufferType(new Uint8Array(input.buffer));
        } else if (ArrayBuffer.isView(input) && input.byteLength === UUID_BYTE_LENGTH) {
          bytes = ByteUtils.toLocalBufferType(input);
        } else if (typeof input === "string") {
          bytes = _UUID.bytesFromString(input);
        } else {
          throw new BSONError("Argument passed in UUID constructor must be a UUID, a 16 byte Buffer or a 32/36 character hex string (dashes excluded/included, format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx).");
        }
        super(bytes, BSON_BINARY_SUBTYPE_UUID_NEW);
      }
      get id() {
        return this.buffer;
      }
      set id(value) {
        this.buffer = value;
      }
      toHexString(includeDashes = true) {
        if (includeDashes) {
          return [
            ByteUtils.toHex(this.buffer.subarray(0, 4)),
            ByteUtils.toHex(this.buffer.subarray(4, 6)),
            ByteUtils.toHex(this.buffer.subarray(6, 8)),
            ByteUtils.toHex(this.buffer.subarray(8, 10)),
            ByteUtils.toHex(this.buffer.subarray(10, 16))
          ].join("-");
        }
        return ByteUtils.toHex(this.buffer);
      }
      toString(encoding) {
        if (encoding === "hex")
          return ByteUtils.toHex(this.id);
        if (encoding === "base64")
          return ByteUtils.toBase64(this.id);
        return this.toHexString();
      }
      toJSON() {
        return this.toHexString();
      }
      equals(otherId) {
        if (!otherId) {
          return false;
        }
        if (otherId instanceof _UUID) {
          return ByteUtils.equals(otherId.id, this.id);
        }
        try {
          return ByteUtils.equals(new _UUID(otherId).id, this.id);
        } catch {
          return false;
        }
      }
      toBinary() {
        return new Binary(this.id, Binary.SUBTYPE_UUID);
      }
      static generate() {
        const bytes = ByteUtils.randomBytes(UUID_BYTE_LENGTH);
        bytes[6] = bytes[6] & 15 | 64;
        bytes[8] = bytes[8] & 63 | 128;
        return bytes;
      }
      static isValid(input) {
        if (!input) {
          return false;
        }
        if (typeof input === "string") {
          return _UUID.isValidUUIDString(input);
        }
        if (isUint8Array(input)) {
          return input.byteLength === UUID_BYTE_LENGTH;
        }
        return input._bsontype === "Binary" && input.sub_type === this.SUBTYPE_UUID && input.buffer.byteLength === 16;
      }
      static createFromHexString(hexString) {
        const buffer2 = _UUID.bytesFromString(hexString);
        return new _UUID(buffer2);
      }
      static createFromBase64(base64) {
        return new _UUID(ByteUtils.fromBase64(base64));
      }
      static bytesFromString(representation) {
        if (!_UUID.isValidUUIDString(representation)) {
          throw new BSONError("UUID string representation must be 32 hex digits or canonical hyphenated representation");
        }
        return ByteUtils.fromHex(representation.replace(/-/g, ""));
      }
      static isValidUUIDString(representation) {
        return UUID_WITHOUT_DASHES.test(representation) || UUID_WITH_DASHES.test(representation);
      }
      inspect(depth, options, inspect) {
        inspect ??= defaultInspect;
        return `new UUID(${inspect(this.toHexString(), options)})`;
      }
    };
    var Code = class _Code extends BSONValue {
      get _bsontype() {
        return "Code";
      }
      constructor(code, scope) {
        super();
        this.code = code.toString();
        this.scope = scope ?? null;
      }
      toJSON() {
        if (this.scope != null) {
          return { code: this.code, scope: this.scope };
        }
        return { code: this.code };
      }
      toExtendedJSON() {
        if (this.scope) {
          return { $code: this.code, $scope: this.scope };
        }
        return { $code: this.code };
      }
      static fromExtendedJSON(doc) {
        return new _Code(doc.$code, doc.$scope);
      }
      inspect(depth, options, inspect) {
        inspect ??= defaultInspect;
        let parametersString = inspect(this.code, options);
        const multiLineFn = parametersString.includes("\n");
        if (this.scope != null) {
          parametersString += `,${multiLineFn ? "\n" : " "}${inspect(this.scope, options)}`;
        }
        const endingNewline = multiLineFn && this.scope === null;
        return `new Code(${multiLineFn ? "\n" : ""}${parametersString}${endingNewline ? "\n" : ""})`;
      }
    };
    function isDBRefLike(value) {
      return value != null && typeof value === "object" && "$id" in value && value.$id != null && "$ref" in value && typeof value.$ref === "string" && (!("$db" in value) || "$db" in value && typeof value.$db === "string");
    }
    var DBRef = class _DBRef extends BSONValue {
      get _bsontype() {
        return "DBRef";
      }
      constructor(collection, oid, db, fields) {
        super();
        const parts = collection.split(".");
        if (parts.length === 2) {
          db = parts.shift();
          collection = parts.shift();
        }
        this.collection = collection;
        this.oid = oid;
        this.db = db;
        this.fields = fields || {};
      }
      get namespace() {
        return this.collection;
      }
      set namespace(value) {
        this.collection = value;
      }
      toJSON() {
        const o = Object.assign({
          $ref: this.collection,
          $id: this.oid
        }, this.fields);
        if (this.db != null)
          o.$db = this.db;
        return o;
      }
      toExtendedJSON(options) {
        options = options || {};
        let o = {
          $ref: this.collection,
          $id: this.oid
        };
        if (options.legacy) {
          return o;
        }
        if (this.db)
          o.$db = this.db;
        o = Object.assign(o, this.fields);
        return o;
      }
      static fromExtendedJSON(doc) {
        const copy = Object.assign({}, doc);
        delete copy.$ref;
        delete copy.$id;
        delete copy.$db;
        return new _DBRef(doc.$ref, doc.$id, doc.$db, copy);
      }
      inspect(depth, options, inspect) {
        inspect ??= defaultInspect;
        const args = [
          inspect(this.namespace, options),
          inspect(this.oid, options),
          ...this.db ? [inspect(this.db, options)] : [],
          ...Object.keys(this.fields).length > 0 ? [inspect(this.fields, options)] : []
        ];
        args[1] = inspect === defaultInspect ? `new ObjectId(${args[1]})` : args[1];
        return `new DBRef(${args.join(", ")})`;
      }
    };
    function removeLeadingZerosAndExplicitPlus(str) {
      if (str === "") {
        return str;
      }
      let startIndex = 0;
      const isNegative = str[startIndex] === "-";
      const isExplicitlyPositive = str[startIndex] === "+";
      if (isExplicitlyPositive || isNegative) {
        startIndex += 1;
      }
      let foundInsignificantZero = false;
      for (; startIndex < str.length && str[startIndex] === "0"; ++startIndex) {
        foundInsignificantZero = true;
      }
      if (!foundInsignificantZero) {
        return isExplicitlyPositive ? str.slice(1) : str;
      }
      return `${isNegative ? "-" : ""}${str.length === startIndex ? "0" : str.slice(startIndex)}`;
    }
    function validateStringCharacters(str, radix) {
      radix = radix ?? 10;
      const validCharacters = "0123456789abcdefghijklmnopqrstuvwxyz".slice(0, radix);
      const regex = new RegExp(`[^-+${validCharacters}]`, "i");
      return regex.test(str) ? false : str;
    }
    var wasm = void 0;
    try {
      wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
    } catch {
    }
    var TWO_PWR_16_DBL = 1 << 16;
    var TWO_PWR_24_DBL = 1 << 24;
    var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
    var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
    var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
    var INT_CACHE = {};
    var UINT_CACHE = {};
    var MAX_INT64_STRING_LENGTH = 20;
    var DECIMAL_REG_EX = /^(\+?0|(\+|-)?[1-9][0-9]*)$/;
    var Long = class _Long extends BSONValue {
      get _bsontype() {
        return "Long";
      }
      get __isLong__() {
        return true;
      }
      constructor(lowOrValue = 0, highOrUnsigned, unsigned) {
        super();
        const unsignedBool = typeof highOrUnsigned === "boolean" ? highOrUnsigned : Boolean(unsigned);
        const high = typeof highOrUnsigned === "number" ? highOrUnsigned : 0;
        const res = typeof lowOrValue === "string" ? _Long.fromString(lowOrValue, unsignedBool) : typeof lowOrValue === "bigint" ? _Long.fromBigInt(lowOrValue, unsignedBool) : { low: lowOrValue | 0, high: high | 0, unsigned: unsignedBool };
        this.low = res.low;
        this.high = res.high;
        this.unsigned = res.unsigned;
      }
      static fromBits(lowBits, highBits, unsigned) {
        return new _Long(lowBits, highBits, unsigned);
      }
      static fromInt(value, unsigned) {
        let obj, cachedObj, cache;
        if (unsigned) {
          value >>>= 0;
          if (cache = 0 <= value && value < 256) {
            cachedObj = UINT_CACHE[value];
            if (cachedObj)
              return cachedObj;
          }
          obj = _Long.fromBits(value, (value | 0) < 0 ? -1 : 0, true);
          if (cache)
            UINT_CACHE[value] = obj;
          return obj;
        } else {
          value |= 0;
          if (cache = -128 <= value && value < 128) {
            cachedObj = INT_CACHE[value];
            if (cachedObj)
              return cachedObj;
          }
          obj = _Long.fromBits(value, value < 0 ? -1 : 0, false);
          if (cache)
            INT_CACHE[value] = obj;
          return obj;
        }
      }
      static fromNumber(value, unsigned) {
        if (isNaN(value))
          return unsigned ? _Long.UZERO : _Long.ZERO;
        if (unsigned) {
          if (value < 0)
            return _Long.UZERO;
          if (value >= TWO_PWR_64_DBL)
            return _Long.MAX_UNSIGNED_VALUE;
        } else {
          if (value <= -9223372036854776e3)
            return _Long.MIN_VALUE;
          if (value + 1 >= TWO_PWR_63_DBL)
            return _Long.MAX_VALUE;
        }
        if (value < 0)
          return _Long.fromNumber(-value, unsigned).neg();
        return _Long.fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
      }
      static fromBigInt(value, unsigned) {
        const FROM_BIGINT_BIT_MASK = BigInt(4294967295);
        const FROM_BIGINT_BIT_SHIFT = BigInt(32);
        return new _Long(Number(value & FROM_BIGINT_BIT_MASK), Number(value >> FROM_BIGINT_BIT_SHIFT & FROM_BIGINT_BIT_MASK), unsigned);
      }
      static _fromString(str, unsigned, radix) {
        if (str.length === 0)
          throw new BSONError("empty string");
        if (radix < 2 || 36 < radix)
          throw new BSONError("radix");
        let p;
        if ((p = str.indexOf("-")) > 0)
          throw new BSONError("interior hyphen");
        else if (p === 0) {
          return _Long._fromString(str.substring(1), unsigned, radix).neg();
        }
        const radixToPower = _Long.fromNumber(Math.pow(radix, 8));
        let result = _Long.ZERO;
        for (let i = 0; i < str.length; i += 8) {
          const size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
          if (size < 8) {
            const power = _Long.fromNumber(Math.pow(radix, size));
            result = result.mul(power).add(_Long.fromNumber(value));
          } else {
            result = result.mul(radixToPower);
            result = result.add(_Long.fromNumber(value));
          }
        }
        result.unsigned = unsigned;
        return result;
      }
      static fromStringStrict(str, unsignedOrRadix, radix) {
        let unsigned = false;
        if (typeof unsignedOrRadix === "number") {
          radix = unsignedOrRadix, unsignedOrRadix = false;
        } else {
          unsigned = !!unsignedOrRadix;
        }
        radix ??= 10;
        if (str.trim() !== str) {
          throw new BSONError(`Input: '${str}' contains leading and/or trailing whitespace`);
        }
        if (!validateStringCharacters(str, radix)) {
          throw new BSONError(`Input: '${str}' contains invalid characters for radix: ${radix}`);
        }
        const cleanedStr = removeLeadingZerosAndExplicitPlus(str);
        const result = _Long._fromString(cleanedStr, unsigned, radix);
        if (result.toString(radix).toLowerCase() !== cleanedStr.toLowerCase()) {
          throw new BSONError(`Input: ${str} is not representable as ${result.unsigned ? "an unsigned" : "a signed"} 64-bit Long ${radix != null ? `with radix: ${radix}` : ""}`);
        }
        return result;
      }
      static fromString(str, unsignedOrRadix, radix) {
        let unsigned = false;
        if (typeof unsignedOrRadix === "number") {
          radix = unsignedOrRadix, unsignedOrRadix = false;
        } else {
          unsigned = !!unsignedOrRadix;
        }
        radix ??= 10;
        if (str === "NaN" && radix < 24) {
          return _Long.ZERO;
        } else if ((str === "Infinity" || str === "+Infinity" || str === "-Infinity") && radix < 35) {
          return _Long.ZERO;
        }
        return _Long._fromString(str, unsigned, radix);
      }
      static fromBytes(bytes, unsigned, le) {
        return le ? _Long.fromBytesLE(bytes, unsigned) : _Long.fromBytesBE(bytes, unsigned);
      }
      static fromBytesLE(bytes, unsigned) {
        return new _Long(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);
      }
      static fromBytesBE(bytes, unsigned) {
        return new _Long(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);
      }
      static isLong(value) {
        return value != null && typeof value === "object" && "__isLong__" in value && value.__isLong__ === true;
      }
      static fromValue(val, unsigned) {
        if (typeof val === "number")
          return _Long.fromNumber(val, unsigned);
        if (typeof val === "string")
          return _Long.fromString(val, unsigned);
        return _Long.fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
      }
      add(addend) {
        if (!_Long.isLong(addend))
          addend = _Long.fromValue(addend);
        const a48 = this.high >>> 16;
        const a32 = this.high & 65535;
        const a16 = this.low >>> 16;
        const a00 = this.low & 65535;
        const b48 = addend.high >>> 16;
        const b32 = addend.high & 65535;
        const b16 = addend.low >>> 16;
        const b00 = addend.low & 65535;
        let c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 + b00;
        c16 += c00 >>> 16;
        c00 &= 65535;
        c16 += a16 + b16;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c32 += a32 + b32;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c48 += a48 + b48;
        c48 &= 65535;
        return _Long.fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
      }
      and(other) {
        if (!_Long.isLong(other))
          other = _Long.fromValue(other);
        return _Long.fromBits(this.low & other.low, this.high & other.high, this.unsigned);
      }
      compare(other) {
        if (!_Long.isLong(other))
          other = _Long.fromValue(other);
        if (this.eq(other))
          return 0;
        const thisNeg = this.isNegative(), otherNeg = other.isNegative();
        if (thisNeg && !otherNeg)
          return -1;
        if (!thisNeg && otherNeg)
          return 1;
        if (!this.unsigned)
          return this.sub(other).isNegative() ? -1 : 1;
        return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
      }
      comp(other) {
        return this.compare(other);
      }
      divide(divisor) {
        if (!_Long.isLong(divisor))
          divisor = _Long.fromValue(divisor);
        if (divisor.isZero())
          throw new BSONError("division by zero");
        if (wasm) {
          if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
            return this;
          }
          const low = (this.unsigned ? wasm.div_u : wasm.div_s)(this.low, this.high, divisor.low, divisor.high);
          return _Long.fromBits(low, wasm.get_high(), this.unsigned);
        }
        if (this.isZero())
          return this.unsigned ? _Long.UZERO : _Long.ZERO;
        let approx, rem, res;
        if (!this.unsigned) {
          if (this.eq(_Long.MIN_VALUE)) {
            if (divisor.eq(_Long.ONE) || divisor.eq(_Long.NEG_ONE))
              return _Long.MIN_VALUE;
            else if (divisor.eq(_Long.MIN_VALUE))
              return _Long.ONE;
            else {
              const halfThis = this.shr(1);
              approx = halfThis.div(divisor).shl(1);
              if (approx.eq(_Long.ZERO)) {
                return divisor.isNegative() ? _Long.ONE : _Long.NEG_ONE;
              } else {
                rem = this.sub(divisor.mul(approx));
                res = approx.add(rem.div(divisor));
                return res;
              }
            }
          } else if (divisor.eq(_Long.MIN_VALUE))
            return this.unsigned ? _Long.UZERO : _Long.ZERO;
          if (this.isNegative()) {
            if (divisor.isNegative())
              return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
          } else if (divisor.isNegative())
            return this.div(divisor.neg()).neg();
          res = _Long.ZERO;
        } else {
          if (!divisor.unsigned)
            divisor = divisor.toUnsigned();
          if (divisor.gt(this))
            return _Long.UZERO;
          if (divisor.gt(this.shru(1)))
            return _Long.UONE;
          res = _Long.UZERO;
        }
        rem = this;
        while (rem.gte(divisor)) {
          approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
          const log2 = Math.ceil(Math.log(approx) / Math.LN2);
          const delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);
          let approxRes = _Long.fromNumber(approx);
          let approxRem = approxRes.mul(divisor);
          while (approxRem.isNegative() || approxRem.gt(rem)) {
            approx -= delta;
            approxRes = _Long.fromNumber(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
          }
          if (approxRes.isZero())
            approxRes = _Long.ONE;
          res = res.add(approxRes);
          rem = rem.sub(approxRem);
        }
        return res;
      }
      div(divisor) {
        return this.divide(divisor);
      }
      equals(other) {
        if (!_Long.isLong(other))
          other = _Long.fromValue(other);
        if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
          return false;
        return this.high === other.high && this.low === other.low;
      }
      eq(other) {
        return this.equals(other);
      }
      getHighBits() {
        return this.high;
      }
      getHighBitsUnsigned() {
        return this.high >>> 0;
      }
      getLowBits() {
        return this.low;
      }
      getLowBitsUnsigned() {
        return this.low >>> 0;
      }
      getNumBitsAbs() {
        if (this.isNegative()) {
          return this.eq(_Long.MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
        }
        const val = this.high !== 0 ? this.high : this.low;
        let bit;
        for (bit = 31; bit > 0; bit--)
          if ((val & 1 << bit) !== 0)
            break;
        return this.high !== 0 ? bit + 33 : bit + 1;
      }
      greaterThan(other) {
        return this.comp(other) > 0;
      }
      gt(other) {
        return this.greaterThan(other);
      }
      greaterThanOrEqual(other) {
        return this.comp(other) >= 0;
      }
      gte(other) {
        return this.greaterThanOrEqual(other);
      }
      ge(other) {
        return this.greaterThanOrEqual(other);
      }
      isEven() {
        return (this.low & 1) === 0;
      }
      isNegative() {
        return !this.unsigned && this.high < 0;
      }
      isOdd() {
        return (this.low & 1) === 1;
      }
      isPositive() {
        return this.unsigned || this.high >= 0;
      }
      isZero() {
        return this.high === 0 && this.low === 0;
      }
      lessThan(other) {
        return this.comp(other) < 0;
      }
      lt(other) {
        return this.lessThan(other);
      }
      lessThanOrEqual(other) {
        return this.comp(other) <= 0;
      }
      lte(other) {
        return this.lessThanOrEqual(other);
      }
      modulo(divisor) {
        if (!_Long.isLong(divisor))
          divisor = _Long.fromValue(divisor);
        if (wasm) {
          const low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(this.low, this.high, divisor.low, divisor.high);
          return _Long.fromBits(low, wasm.get_high(), this.unsigned);
        }
        return this.sub(this.div(divisor).mul(divisor));
      }
      mod(divisor) {
        return this.modulo(divisor);
      }
      rem(divisor) {
        return this.modulo(divisor);
      }
      multiply(multiplier) {
        if (this.isZero())
          return _Long.ZERO;
        if (!_Long.isLong(multiplier))
          multiplier = _Long.fromValue(multiplier);
        if (wasm) {
          const low = wasm.mul(this.low, this.high, multiplier.low, multiplier.high);
          return _Long.fromBits(low, wasm.get_high(), this.unsigned);
        }
        if (multiplier.isZero())
          return _Long.ZERO;
        if (this.eq(_Long.MIN_VALUE))
          return multiplier.isOdd() ? _Long.MIN_VALUE : _Long.ZERO;
        if (multiplier.eq(_Long.MIN_VALUE))
          return this.isOdd() ? _Long.MIN_VALUE : _Long.ZERO;
        if (this.isNegative()) {
          if (multiplier.isNegative())
            return this.neg().mul(multiplier.neg());
          else
            return this.neg().mul(multiplier).neg();
        } else if (multiplier.isNegative())
          return this.mul(multiplier.neg()).neg();
        if (this.lt(_Long.TWO_PWR_24) && multiplier.lt(_Long.TWO_PWR_24))
          return _Long.fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
        const a48 = this.high >>> 16;
        const a32 = this.high & 65535;
        const a16 = this.low >>> 16;
        const a00 = this.low & 65535;
        const b48 = multiplier.high >>> 16;
        const b32 = multiplier.high & 65535;
        const b16 = multiplier.low >>> 16;
        const b00 = multiplier.low & 65535;
        let c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 * b00;
        c16 += c00 >>> 16;
        c00 &= 65535;
        c16 += a16 * b00;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c16 += a00 * b16;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c32 += a32 * b00;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c32 += a16 * b16;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c32 += a00 * b32;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
        c48 &= 65535;
        return _Long.fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
      }
      mul(multiplier) {
        return this.multiply(multiplier);
      }
      negate() {
        if (!this.unsigned && this.eq(_Long.MIN_VALUE))
          return _Long.MIN_VALUE;
        return this.not().add(_Long.ONE);
      }
      neg() {
        return this.negate();
      }
      not() {
        return _Long.fromBits(~this.low, ~this.high, this.unsigned);
      }
      notEquals(other) {
        return !this.equals(other);
      }
      neq(other) {
        return this.notEquals(other);
      }
      ne(other) {
        return this.notEquals(other);
      }
      or(other) {
        if (!_Long.isLong(other))
          other = _Long.fromValue(other);
        return _Long.fromBits(this.low | other.low, this.high | other.high, this.unsigned);
      }
      shiftLeft(numBits) {
        if (_Long.isLong(numBits))
          numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
          return this;
        else if (numBits < 32)
          return _Long.fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
        else
          return _Long.fromBits(0, this.low << numBits - 32, this.unsigned);
      }
      shl(numBits) {
        return this.shiftLeft(numBits);
      }
      shiftRight(numBits) {
        if (_Long.isLong(numBits))
          numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
          return this;
        else if (numBits < 32)
          return _Long.fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
        else
          return _Long.fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
      }
      shr(numBits) {
        return this.shiftRight(numBits);
      }
      shiftRightUnsigned(numBits) {
        if (_Long.isLong(numBits))
          numBits = numBits.toInt();
        numBits &= 63;
        if (numBits === 0)
          return this;
        else {
          const high = this.high;
          if (numBits < 32) {
            const low = this.low;
            return _Long.fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
          } else if (numBits === 32)
            return _Long.fromBits(high, 0, this.unsigned);
          else
            return _Long.fromBits(high >>> numBits - 32, 0, this.unsigned);
        }
      }
      shr_u(numBits) {
        return this.shiftRightUnsigned(numBits);
      }
      shru(numBits) {
        return this.shiftRightUnsigned(numBits);
      }
      subtract(subtrahend) {
        if (!_Long.isLong(subtrahend))
          subtrahend = _Long.fromValue(subtrahend);
        return this.add(subtrahend.neg());
      }
      sub(subtrahend) {
        return this.subtract(subtrahend);
      }
      toInt() {
        return this.unsigned ? this.low >>> 0 : this.low;
      }
      toNumber() {
        if (this.unsigned)
          return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
      }
      toBigInt() {
        return BigInt(this.toString());
      }
      toBytes(le) {
        return le ? this.toBytesLE() : this.toBytesBE();
      }
      toBytesLE() {
        const hi = this.high, lo = this.low;
        return [
          lo & 255,
          lo >>> 8 & 255,
          lo >>> 16 & 255,
          lo >>> 24,
          hi & 255,
          hi >>> 8 & 255,
          hi >>> 16 & 255,
          hi >>> 24
        ];
      }
      toBytesBE() {
        const hi = this.high, lo = this.low;
        return [
          hi >>> 24,
          hi >>> 16 & 255,
          hi >>> 8 & 255,
          hi & 255,
          lo >>> 24,
          lo >>> 16 & 255,
          lo >>> 8 & 255,
          lo & 255
        ];
      }
      toSigned() {
        if (!this.unsigned)
          return this;
        return _Long.fromBits(this.low, this.high, false);
      }
      toString(radix) {
        radix = radix || 10;
        if (radix < 2 || 36 < radix)
          throw new BSONError("radix");
        if (this.isZero())
          return "0";
        if (this.isNegative()) {
          if (this.eq(_Long.MIN_VALUE)) {
            const radixLong = _Long.fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
            return div.toString(radix) + rem1.toInt().toString(radix);
          } else
            return "-" + this.neg().toString(radix);
        }
        const radixToPower = _Long.fromNumber(Math.pow(radix, 6), this.unsigned);
        let rem = this;
        let result = "";
        while (true) {
          const remDiv = rem.div(radixToPower);
          const intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0;
          let digits = intval.toString(radix);
          rem = remDiv;
          if (rem.isZero()) {
            return digits + result;
          } else {
            while (digits.length < 6)
              digits = "0" + digits;
            result = "" + digits + result;
          }
        }
      }
      toUnsigned() {
        if (this.unsigned)
          return this;
        return _Long.fromBits(this.low, this.high, true);
      }
      xor(other) {
        if (!_Long.isLong(other))
          other = _Long.fromValue(other);
        return _Long.fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
      }
      eqz() {
        return this.isZero();
      }
      le(other) {
        return this.lessThanOrEqual(other);
      }
      toExtendedJSON(options) {
        if (options && options.relaxed)
          return this.toNumber();
        return { $numberLong: this.toString() };
      }
      static fromExtendedJSON(doc, options) {
        const { useBigInt64 = false, relaxed = true } = { ...options };
        if (doc.$numberLong.length > MAX_INT64_STRING_LENGTH) {
          throw new BSONError("$numberLong string is too long");
        }
        if (!DECIMAL_REG_EX.test(doc.$numberLong)) {
          throw new BSONError(`$numberLong string "${doc.$numberLong}" is in an invalid format`);
        }
        if (useBigInt64) {
          const bigIntResult = BigInt(doc.$numberLong);
          return BigInt.asIntN(64, bigIntResult);
        }
        const longResult = _Long.fromString(doc.$numberLong);
        if (relaxed) {
          return longResult.toNumber();
        }
        return longResult;
      }
      inspect(depth, options, inspect) {
        inspect ??= defaultInspect;
        const longVal = inspect(this.toString(), options);
        const unsignedVal = this.unsigned ? `, ${inspect(this.unsigned, options)}` : "";
        return `new Long(${longVal}${unsignedVal})`;
      }
    };
    Long.TWO_PWR_24 = Long.fromInt(TWO_PWR_24_DBL);
    Long.MAX_UNSIGNED_VALUE = Long.fromBits(4294967295 | 0, 4294967295 | 0, true);
    Long.ZERO = Long.fromInt(0);
    Long.UZERO = Long.fromInt(0, true);
    Long.ONE = Long.fromInt(1);
    Long.UONE = Long.fromInt(1, true);
    Long.NEG_ONE = Long.fromInt(-1);
    Long.MAX_VALUE = Long.fromBits(4294967295 | 0, 2147483647 | 0, false);
    Long.MIN_VALUE = Long.fromBits(0, 2147483648 | 0, false);
    var PARSE_STRING_REGEXP = /^(\+|-)?(\d+|(\d*\.\d*))?(E|e)?([-+])?(\d+)?$/;
    var PARSE_INF_REGEXP = /^(\+|-)?(Infinity|inf)$/i;
    var PARSE_NAN_REGEXP = /^(\+|-)?NaN$/i;
    var EXPONENT_MAX = 6111;
    var EXPONENT_MIN = -6176;
    var EXPONENT_BIAS = 6176;
    var MAX_DIGITS = 34;
    var NAN_BUFFER = ByteUtils.fromNumberArray([
      124,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ].reverse());
    var INF_NEGATIVE_BUFFER = ByteUtils.fromNumberArray([
      248,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ].reverse());
    var INF_POSITIVE_BUFFER = ByteUtils.fromNumberArray([
      120,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ].reverse());
    var EXPONENT_REGEX = /^([-+])?(\d+)?$/;
    var COMBINATION_MASK = 31;
    var EXPONENT_MASK = 16383;
    var COMBINATION_INFINITY = 30;
    var COMBINATION_NAN = 31;
    function isDigit(value) {
      return !isNaN(parseInt(value, 10));
    }
    function divideu128(value) {
      const DIVISOR = Long.fromNumber(1e3 * 1e3 * 1e3);
      let _rem = Long.fromNumber(0);
      if (!value.parts[0] && !value.parts[1] && !value.parts[2] && !value.parts[3]) {
        return { quotient: value, rem: _rem };
      }
      for (let i = 0; i <= 3; i++) {
        _rem = _rem.shiftLeft(32);
        _rem = _rem.add(new Long(value.parts[i], 0));
        value.parts[i] = _rem.div(DIVISOR).low;
        _rem = _rem.modulo(DIVISOR);
      }
      return { quotient: value, rem: _rem };
    }
    function multiply64x2(left, right) {
      if (!left && !right) {
        return { high: Long.fromNumber(0), low: Long.fromNumber(0) };
      }
      const leftHigh = left.shiftRightUnsigned(32);
      const leftLow = new Long(left.getLowBits(), 0);
      const rightHigh = right.shiftRightUnsigned(32);
      const rightLow = new Long(right.getLowBits(), 0);
      let productHigh = leftHigh.multiply(rightHigh);
      let productMid = leftHigh.multiply(rightLow);
      const productMid2 = leftLow.multiply(rightHigh);
      let productLow = leftLow.multiply(rightLow);
      productHigh = productHigh.add(productMid.shiftRightUnsigned(32));
      productMid = new Long(productMid.getLowBits(), 0).add(productMid2).add(productLow.shiftRightUnsigned(32));
      productHigh = productHigh.add(productMid.shiftRightUnsigned(32));
      productLow = productMid.shiftLeft(32).add(new Long(productLow.getLowBits(), 0));
      return { high: productHigh, low: productLow };
    }
    function lessThan(left, right) {
      const uhleft = left.high >>> 0;
      const uhright = right.high >>> 0;
      if (uhleft < uhright) {
        return true;
      } else if (uhleft === uhright) {
        const ulleft = left.low >>> 0;
        const ulright = right.low >>> 0;
        if (ulleft < ulright)
          return true;
      }
      return false;
    }
    function invalidErr(string, message) {
      throw new BSONError(`"${string}" is not a valid Decimal128 string - ${message}`);
    }
    var Decimal128 = class _Decimal128 extends BSONValue {
      get _bsontype() {
        return "Decimal128";
      }
      constructor(bytes) {
        super();
        if (typeof bytes === "string") {
          this.bytes = _Decimal128.fromString(bytes).bytes;
        } else if (bytes instanceof Uint8Array || isUint8Array(bytes)) {
          if (bytes.byteLength !== 16) {
            throw new BSONError("Decimal128 must take a Buffer of 16 bytes");
          }
          this.bytes = bytes;
        } else {
          throw new BSONError("Decimal128 must take a Buffer or string");
        }
      }
      static fromString(representation) {
        return _Decimal128._fromString(representation, { allowRounding: false });
      }
      static fromStringWithRounding(representation) {
        return _Decimal128._fromString(representation, { allowRounding: true });
      }
      static _fromString(representation, options) {
        let isNegative = false;
        let sawSign = false;
        let sawRadix = false;
        let foundNonZero = false;
        let significantDigits = 0;
        let nDigitsRead = 0;
        let nDigits = 0;
        let radixPosition = 0;
        let firstNonZero = 0;
        const digits = [0];
        let nDigitsStored = 0;
        let digitsInsert = 0;
        let lastDigit = 0;
        let exponent = 0;
        let significandHigh = new Long(0, 0);
        let significandLow = new Long(0, 0);
        let biasedExponent = 0;
        let index = 0;
        if (representation.length >= 7e3) {
          throw new BSONError("" + representation + " not a valid Decimal128 string");
        }
        const stringMatch = representation.match(PARSE_STRING_REGEXP);
        const infMatch = representation.match(PARSE_INF_REGEXP);
        const nanMatch = representation.match(PARSE_NAN_REGEXP);
        if (!stringMatch && !infMatch && !nanMatch || representation.length === 0) {
          throw new BSONError("" + representation + " not a valid Decimal128 string");
        }
        if (stringMatch) {
          const unsignedNumber = stringMatch[2];
          const e = stringMatch[4];
          const expSign = stringMatch[5];
          const expNumber = stringMatch[6];
          if (e && expNumber === void 0)
            invalidErr(representation, "missing exponent power");
          if (e && unsignedNumber === void 0)
            invalidErr(representation, "missing exponent base");
          if (e === void 0 && (expSign || expNumber)) {
            invalidErr(representation, "missing e before exponent");
          }
        }
        if (representation[index] === "+" || representation[index] === "-") {
          sawSign = true;
          isNegative = representation[index++] === "-";
        }
        if (!isDigit(representation[index]) && representation[index] !== ".") {
          if (representation[index] === "i" || representation[index] === "I") {
            return new _Decimal128(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER);
          } else if (representation[index] === "N") {
            return new _Decimal128(NAN_BUFFER);
          }
        }
        while (isDigit(representation[index]) || representation[index] === ".") {
          if (representation[index] === ".") {
            if (sawRadix)
              invalidErr(representation, "contains multiple periods");
            sawRadix = true;
            index = index + 1;
            continue;
          }
          if (nDigitsStored < MAX_DIGITS) {
            if (representation[index] !== "0" || foundNonZero) {
              if (!foundNonZero) {
                firstNonZero = nDigitsRead;
              }
              foundNonZero = true;
              digits[digitsInsert++] = parseInt(representation[index], 10);
              nDigitsStored = nDigitsStored + 1;
            }
          }
          if (foundNonZero)
            nDigits = nDigits + 1;
          if (sawRadix)
            radixPosition = radixPosition + 1;
          nDigitsRead = nDigitsRead + 1;
          index = index + 1;
        }
        if (sawRadix && !nDigitsRead)
          throw new BSONError("" + representation + " not a valid Decimal128 string");
        if (representation[index] === "e" || representation[index] === "E") {
          const match2 = representation.substr(++index).match(EXPONENT_REGEX);
          if (!match2 || !match2[2])
            return new _Decimal128(NAN_BUFFER);
          exponent = parseInt(match2[0], 10);
          index = index + match2[0].length;
        }
        if (representation[index])
          return new _Decimal128(NAN_BUFFER);
        if (!nDigitsStored) {
          digits[0] = 0;
          nDigits = 1;
          nDigitsStored = 1;
          significantDigits = 0;
        } else {
          lastDigit = nDigitsStored - 1;
          significantDigits = nDigits;
          if (significantDigits !== 1) {
            while (representation[firstNonZero + significantDigits - 1 + Number(sawSign) + Number(sawRadix)] === "0") {
              significantDigits = significantDigits - 1;
            }
          }
        }
        if (exponent <= radixPosition && radixPosition > exponent + (1 << 14)) {
          exponent = EXPONENT_MIN;
        } else {
          exponent = exponent - radixPosition;
        }
        while (exponent > EXPONENT_MAX) {
          lastDigit = lastDigit + 1;
          if (lastDigit >= MAX_DIGITS) {
            if (significantDigits === 0) {
              exponent = EXPONENT_MAX;
              break;
            }
            invalidErr(representation, "overflow");
          }
          exponent = exponent - 1;
        }
        if (options.allowRounding) {
          while (exponent < EXPONENT_MIN || nDigitsStored < nDigits) {
            if (lastDigit === 0 && significantDigits < nDigitsStored) {
              exponent = EXPONENT_MIN;
              significantDigits = 0;
              break;
            }
            if (nDigitsStored < nDigits) {
              nDigits = nDigits - 1;
            } else {
              lastDigit = lastDigit - 1;
            }
            if (exponent < EXPONENT_MAX) {
              exponent = exponent + 1;
            } else {
              const digitsString = digits.join("");
              if (digitsString.match(/^0+$/)) {
                exponent = EXPONENT_MAX;
                break;
              }
              invalidErr(representation, "overflow");
            }
          }
          if (lastDigit + 1 < significantDigits) {
            let endOfString = nDigitsRead;
            if (sawRadix) {
              firstNonZero = firstNonZero + 1;
              endOfString = endOfString + 1;
            }
            if (sawSign) {
              firstNonZero = firstNonZero + 1;
              endOfString = endOfString + 1;
            }
            const roundDigit = parseInt(representation[firstNonZero + lastDigit + 1], 10);
            let roundBit = 0;
            if (roundDigit >= 5) {
              roundBit = 1;
              if (roundDigit === 5) {
                roundBit = digits[lastDigit] % 2 === 1 ? 1 : 0;
                for (let i = firstNonZero + lastDigit + 2; i < endOfString; i++) {
                  if (parseInt(representation[i], 10)) {
                    roundBit = 1;
                    break;
                  }
                }
              }
            }
            if (roundBit) {
              let dIdx = lastDigit;
              for (; dIdx >= 0; dIdx--) {
                if (++digits[dIdx] > 9) {
                  digits[dIdx] = 0;
                  if (dIdx === 0) {
                    if (exponent < EXPONENT_MAX) {
                      exponent = exponent + 1;
                      digits[dIdx] = 1;
                    } else {
                      return new _Decimal128(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER);
                    }
                  }
                } else {
                  break;
                }
              }
            }
          }
        } else {
          while (exponent < EXPONENT_MIN || nDigitsStored < nDigits) {
            if (lastDigit === 0) {
              if (significantDigits === 0) {
                exponent = EXPONENT_MIN;
                break;
              }
              invalidErr(representation, "exponent underflow");
            }
            if (nDigitsStored < nDigits) {
              if (representation[nDigits - 1 + Number(sawSign) + Number(sawRadix)] !== "0" && significantDigits !== 0) {
                invalidErr(representation, "inexact rounding");
              }
              nDigits = nDigits - 1;
            } else {
              if (digits[lastDigit] !== 0) {
                invalidErr(representation, "inexact rounding");
              }
              lastDigit = lastDigit - 1;
            }
            if (exponent < EXPONENT_MAX) {
              exponent = exponent + 1;
            } else {
              invalidErr(representation, "overflow");
            }
          }
          if (lastDigit + 1 < significantDigits) {
            if (sawRadix) {
              firstNonZero = firstNonZero + 1;
            }
            if (sawSign) {
              firstNonZero = firstNonZero + 1;
            }
            const roundDigit = parseInt(representation[firstNonZero + lastDigit + 1], 10);
            if (roundDigit !== 0) {
              invalidErr(representation, "inexact rounding");
            }
          }
        }
        significandHigh = Long.fromNumber(0);
        significandLow = Long.fromNumber(0);
        if (significantDigits === 0) {
          significandHigh = Long.fromNumber(0);
          significandLow = Long.fromNumber(0);
        } else if (lastDigit < 17) {
          let dIdx = 0;
          significandLow = Long.fromNumber(digits[dIdx++]);
          significandHigh = new Long(0, 0);
          for (; dIdx <= lastDigit; dIdx++) {
            significandLow = significandLow.multiply(Long.fromNumber(10));
            significandLow = significandLow.add(Long.fromNumber(digits[dIdx]));
          }
        } else {
          let dIdx = 0;
          significandHigh = Long.fromNumber(digits[dIdx++]);
          for (; dIdx <= lastDigit - 17; dIdx++) {
            significandHigh = significandHigh.multiply(Long.fromNumber(10));
            significandHigh = significandHigh.add(Long.fromNumber(digits[dIdx]));
          }
          significandLow = Long.fromNumber(digits[dIdx++]);
          for (; dIdx <= lastDigit; dIdx++) {
            significandLow = significandLow.multiply(Long.fromNumber(10));
            significandLow = significandLow.add(Long.fromNumber(digits[dIdx]));
          }
        }
        const significand = multiply64x2(significandHigh, Long.fromString("100000000000000000"));
        significand.low = significand.low.add(significandLow);
        if (lessThan(significand.low, significandLow)) {
          significand.high = significand.high.add(Long.fromNumber(1));
        }
        biasedExponent = exponent + EXPONENT_BIAS;
        const dec = { low: Long.fromNumber(0), high: Long.fromNumber(0) };
        if (significand.high.shiftRightUnsigned(49).and(Long.fromNumber(1)).equals(Long.fromNumber(1))) {
          dec.high = dec.high.or(Long.fromNumber(3).shiftLeft(61));
          dec.high = dec.high.or(Long.fromNumber(biasedExponent).and(Long.fromNumber(16383).shiftLeft(47)));
          dec.high = dec.high.or(significand.high.and(Long.fromNumber(140737488355327)));
        } else {
          dec.high = dec.high.or(Long.fromNumber(biasedExponent & 16383).shiftLeft(49));
          dec.high = dec.high.or(significand.high.and(Long.fromNumber(562949953421311)));
        }
        dec.low = significand.low;
        if (isNegative) {
          dec.high = dec.high.or(Long.fromString("9223372036854775808"));
        }
        const buffer2 = ByteUtils.allocateUnsafe(16);
        index = 0;
        buffer2[index++] = dec.low.low & 255;
        buffer2[index++] = dec.low.low >> 8 & 255;
        buffer2[index++] = dec.low.low >> 16 & 255;
        buffer2[index++] = dec.low.low >> 24 & 255;
        buffer2[index++] = dec.low.high & 255;
        buffer2[index++] = dec.low.high >> 8 & 255;
        buffer2[index++] = dec.low.high >> 16 & 255;
        buffer2[index++] = dec.low.high >> 24 & 255;
        buffer2[index++] = dec.high.low & 255;
        buffer2[index++] = dec.high.low >> 8 & 255;
        buffer2[index++] = dec.high.low >> 16 & 255;
        buffer2[index++] = dec.high.low >> 24 & 255;
        buffer2[index++] = dec.high.high & 255;
        buffer2[index++] = dec.high.high >> 8 & 255;
        buffer2[index++] = dec.high.high >> 16 & 255;
        buffer2[index++] = dec.high.high >> 24 & 255;
        return new _Decimal128(buffer2);
      }
      toString() {
        let biased_exponent;
        let significand_digits = 0;
        const significand = new Array(36);
        for (let i = 0; i < significand.length; i++)
          significand[i] = 0;
        let index = 0;
        let is_zero = false;
        let significand_msb;
        let significand128 = { parts: [0, 0, 0, 0] };
        let j, k;
        const string = [];
        index = 0;
        const buffer2 = this.bytes;
        const low = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
        const midl = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
        const midh = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
        const high = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
        index = 0;
        const dec = {
          low: new Long(low, midl),
          high: new Long(midh, high)
        };
        if (dec.high.lessThan(Long.ZERO)) {
          string.push("-");
        }
        const combination = high >> 26 & COMBINATION_MASK;
        if (combination >> 3 === 3) {
          if (combination === COMBINATION_INFINITY) {
            return string.join("") + "Infinity";
          } else if (combination === COMBINATION_NAN) {
            return "NaN";
          } else {
            biased_exponent = high >> 15 & EXPONENT_MASK;
            significand_msb = 8 + (high >> 14 & 1);
          }
        } else {
          significand_msb = high >> 14 & 7;
          biased_exponent = high >> 17 & EXPONENT_MASK;
        }
        const exponent = biased_exponent - EXPONENT_BIAS;
        significand128.parts[0] = (high & 16383) + ((significand_msb & 15) << 14);
        significand128.parts[1] = midh;
        significand128.parts[2] = midl;
        significand128.parts[3] = low;
        if (significand128.parts[0] === 0 && significand128.parts[1] === 0 && significand128.parts[2] === 0 && significand128.parts[3] === 0) {
          is_zero = true;
        } else {
          for (k = 3; k >= 0; k--) {
            let least_digits = 0;
            const result = divideu128(significand128);
            significand128 = result.quotient;
            least_digits = result.rem.low;
            if (!least_digits)
              continue;
            for (j = 8; j >= 0; j--) {
              significand[k * 9 + j] = least_digits % 10;
              least_digits = Math.floor(least_digits / 10);
            }
          }
        }
        if (is_zero) {
          significand_digits = 1;
          significand[index] = 0;
        } else {
          significand_digits = 36;
          while (!significand[index]) {
            significand_digits = significand_digits - 1;
            index = index + 1;
          }
        }
        const scientific_exponent = significand_digits - 1 + exponent;
        if (scientific_exponent >= 34 || scientific_exponent <= -7 || exponent > 0) {
          if (significand_digits > 34) {
            string.push(`${0}`);
            if (exponent > 0)
              string.push(`E+${exponent}`);
            else if (exponent < 0)
              string.push(`E${exponent}`);
            return string.join("");
          }
          string.push(`${significand[index++]}`);
          significand_digits = significand_digits - 1;
          if (significand_digits) {
            string.push(".");
          }
          for (let i = 0; i < significand_digits; i++) {
            string.push(`${significand[index++]}`);
          }
          string.push("E");
          if (scientific_exponent > 0) {
            string.push(`+${scientific_exponent}`);
          } else {
            string.push(`${scientific_exponent}`);
          }
        } else {
          if (exponent >= 0) {
            for (let i = 0; i < significand_digits; i++) {
              string.push(`${significand[index++]}`);
            }
          } else {
            let radix_position = significand_digits + exponent;
            if (radix_position > 0) {
              for (let i = 0; i < radix_position; i++) {
                string.push(`${significand[index++]}`);
              }
            } else {
              string.push("0");
            }
            string.push(".");
            while (radix_position++ < 0) {
              string.push("0");
            }
            for (let i = 0; i < significand_digits - Math.max(radix_position - 1, 0); i++) {
              string.push(`${significand[index++]}`);
            }
          }
        }
        return string.join("");
      }
      toJSON() {
        return { $numberDecimal: this.toString() };
      }
      toExtendedJSON() {
        return { $numberDecimal: this.toString() };
      }
      static fromExtendedJSON(doc) {
        return _Decimal128.fromString(doc.$numberDecimal);
      }
      inspect(depth, options, inspect) {
        inspect ??= defaultInspect;
        const d128string = inspect(this.toString(), options);
        return `new Decimal128(${d128string})`;
      }
    };
    var Double = class _Double extends BSONValue {
      get _bsontype() {
        return "Double";
      }
      constructor(value) {
        super();
        if (value instanceof Number) {
          value = value.valueOf();
        }
        this.value = +value;
      }
      static fromString(value) {
        const coercedValue = Number(value);
        if (value === "NaN")
          return new _Double(NaN);
        if (value === "Infinity")
          return new _Double(Infinity);
        if (value === "-Infinity")
          return new _Double(-Infinity);
        if (!Number.isFinite(coercedValue)) {
          throw new BSONError(`Input: ${value} is not representable as a Double`);
        }
        if (value.trim() !== value) {
          throw new BSONError(`Input: '${value}' contains whitespace`);
        }
        if (value === "") {
          throw new BSONError(`Input is an empty string`);
        }
        if (/[^-0-9.+eE]/.test(value)) {
          throw new BSONError(`Input: '${value}' is not in decimal or exponential notation`);
        }
        return new _Double(coercedValue);
      }
      valueOf() {
        return this.value;
      }
      toJSON() {
        return this.value;
      }
      toString(radix) {
        return this.value.toString(radix);
      }
      toExtendedJSON(options) {
        if (options && (options.legacy || options.relaxed && isFinite(this.value))) {
          return this.value;
        }
        if (Object.is(Math.sign(this.value), -0)) {
          return { $numberDouble: "-0.0" };
        }
        return {
          $numberDouble: Number.isInteger(this.value) ? this.value.toFixed(1) : this.value.toString()
        };
      }
      static fromExtendedJSON(doc, options) {
        const doubleValue = parseFloat(doc.$numberDouble);
        return options && options.relaxed ? doubleValue : new _Double(doubleValue);
      }
      inspect(depth, options, inspect) {
        inspect ??= defaultInspect;
        return `new Double(${inspect(this.value, options)})`;
      }
    };
    var Int32 = class _Int32 extends BSONValue {
      get _bsontype() {
        return "Int32";
      }
      constructor(value) {
        super();
        if (value instanceof Number) {
          value = value.valueOf();
        }
        this.value = +value | 0;
      }
      static fromString(value) {
        const cleanedValue = removeLeadingZerosAndExplicitPlus(value);
        const coercedValue = Number(value);
        if (BSON_INT32_MAX < coercedValue) {
          throw new BSONError(`Input: '${value}' is larger than the maximum value for Int32`);
        } else if (BSON_INT32_MIN > coercedValue) {
          throw new BSONError(`Input: '${value}' is smaller than the minimum value for Int32`);
        } else if (!Number.isSafeInteger(coercedValue)) {
          throw new BSONError(`Input: '${value}' is not a safe integer`);
        } else if (coercedValue.toString() !== cleanedValue) {
          throw new BSONError(`Input: '${value}' is not a valid Int32 string`);
        }
        return new _Int32(coercedValue);
      }
      valueOf() {
        return this.value;
      }
      toString(radix) {
        return this.value.toString(radix);
      }
      toJSON() {
        return this.value;
      }
      toExtendedJSON(options) {
        if (options && (options.relaxed || options.legacy))
          return this.value;
        return { $numberInt: this.value.toString() };
      }
      static fromExtendedJSON(doc, options) {
        return options && options.relaxed ? parseInt(doc.$numberInt, 10) : new _Int32(doc.$numberInt);
      }
      inspect(depth, options, inspect) {
        inspect ??= defaultInspect;
        return `new Int32(${inspect(this.value, options)})`;
      }
    };
    var MaxKey = class _MaxKey extends BSONValue {
      get _bsontype() {
        return "MaxKey";
      }
      toExtendedJSON() {
        return { $maxKey: 1 };
      }
      static fromExtendedJSON() {
        return new _MaxKey();
      }
      inspect() {
        return "new MaxKey()";
      }
    };
    var MinKey = class _MinKey extends BSONValue {
      get _bsontype() {
        return "MinKey";
      }
      toExtendedJSON() {
        return { $minKey: 1 };
      }
      static fromExtendedJSON() {
        return new _MinKey();
      }
      inspect() {
        return "new MinKey()";
      }
    };
    var PROCESS_UNIQUE = null;
    var __idCache = /* @__PURE__ */ new WeakMap();
    var ObjectId = class _ObjectId extends BSONValue {
      get _bsontype() {
        return "ObjectId";
      }
      constructor(inputId) {
        super();
        let workingId;
        if (typeof inputId === "object" && inputId && "id" in inputId) {
          if (typeof inputId.id !== "string" && !ArrayBuffer.isView(inputId.id)) {
            throw new BSONError("Argument passed in must have an id that is of type string or Buffer");
          }
          if ("toHexString" in inputId && typeof inputId.toHexString === "function") {
            workingId = ByteUtils.fromHex(inputId.toHexString());
          } else {
            workingId = inputId.id;
          }
        } else {
          workingId = inputId;
        }
        if (workingId == null || typeof workingId === "number") {
          this.buffer = _ObjectId.generate(typeof workingId === "number" ? workingId : void 0);
        } else if (ArrayBuffer.isView(workingId) && workingId.byteLength === 12) {
          this.buffer = ByteUtils.toLocalBufferType(workingId);
        } else if (typeof workingId === "string") {
          if (_ObjectId.validateHexString(workingId)) {
            this.buffer = ByteUtils.fromHex(workingId);
            if (_ObjectId.cacheHexString) {
              __idCache.set(this, workingId);
            }
          } else {
            throw new BSONError("input must be a 24 character hex string, 12 byte Uint8Array, or an integer");
          }
        } else {
          throw new BSONError("Argument passed in does not match the accepted types");
        }
      }
      get id() {
        return this.buffer;
      }
      set id(value) {
        this.buffer = value;
        if (_ObjectId.cacheHexString) {
          __idCache.set(this, ByteUtils.toHex(value));
        }
      }
      static validateHexString(string) {
        if (string?.length !== 24)
          return false;
        for (let i = 0; i < 24; i++) {
          const char = string.charCodeAt(i);
          if (char >= 48 && char <= 57 || char >= 97 && char <= 102 || char >= 65 && char <= 70) {
            continue;
          }
          return false;
        }
        return true;
      }
      toHexString() {
        if (_ObjectId.cacheHexString) {
          const __id = __idCache.get(this);
          if (__id)
            return __id;
        }
        const hexString = ByteUtils.toHex(this.id);
        if (_ObjectId.cacheHexString) {
          __idCache.set(this, hexString);
        }
        return hexString;
      }
      static getInc() {
        return _ObjectId.index = (_ObjectId.index + 1) % 16777215;
      }
      static generate(time) {
        if ("number" !== typeof time) {
          time = Math.floor(Date.now() / 1e3);
        }
        const inc = _ObjectId.getInc();
        const buffer2 = ByteUtils.allocateUnsafe(12);
        NumberUtils.setInt32BE(buffer2, 0, time);
        if (PROCESS_UNIQUE === null) {
          PROCESS_UNIQUE = ByteUtils.randomBytes(5);
        }
        buffer2[4] = PROCESS_UNIQUE[0];
        buffer2[5] = PROCESS_UNIQUE[1];
        buffer2[6] = PROCESS_UNIQUE[2];
        buffer2[7] = PROCESS_UNIQUE[3];
        buffer2[8] = PROCESS_UNIQUE[4];
        buffer2[11] = inc & 255;
        buffer2[10] = inc >> 8 & 255;
        buffer2[9] = inc >> 16 & 255;
        return buffer2;
      }
      toString(encoding) {
        if (encoding === "base64")
          return ByteUtils.toBase64(this.id);
        if (encoding === "hex")
          return this.toHexString();
        return this.toHexString();
      }
      toJSON() {
        return this.toHexString();
      }
      static is(variable) {
        return variable != null && typeof variable === "object" && "_bsontype" in variable && variable._bsontype === "ObjectId";
      }
      equals(otherId) {
        if (otherId === void 0 || otherId === null) {
          return false;
        }
        if (_ObjectId.is(otherId)) {
          return this.buffer[11] === otherId.buffer[11] && ByteUtils.equals(this.buffer, otherId.buffer);
        }
        if (typeof otherId === "string") {
          return otherId.toLowerCase() === this.toHexString();
        }
        if (typeof otherId === "object" && typeof otherId.toHexString === "function") {
          const otherIdString = otherId.toHexString();
          const thisIdString = this.toHexString();
          return typeof otherIdString === "string" && otherIdString.toLowerCase() === thisIdString;
        }
        return false;
      }
      getTimestamp() {
        const timestamp = /* @__PURE__ */ new Date();
        const time = NumberUtils.getUint32BE(this.buffer, 0);
        timestamp.setTime(Math.floor(time) * 1e3);
        return timestamp;
      }
      static createPk() {
        return new _ObjectId();
      }
      serializeInto(uint8array, index) {
        uint8array[index] = this.buffer[0];
        uint8array[index + 1] = this.buffer[1];
        uint8array[index + 2] = this.buffer[2];
        uint8array[index + 3] = this.buffer[3];
        uint8array[index + 4] = this.buffer[4];
        uint8array[index + 5] = this.buffer[5];
        uint8array[index + 6] = this.buffer[6];
        uint8array[index + 7] = this.buffer[7];
        uint8array[index + 8] = this.buffer[8];
        uint8array[index + 9] = this.buffer[9];
        uint8array[index + 10] = this.buffer[10];
        uint8array[index + 11] = this.buffer[11];
        return 12;
      }
      static createFromTime(time) {
        const buffer2 = ByteUtils.allocate(12);
        for (let i = 11; i >= 4; i--)
          buffer2[i] = 0;
        NumberUtils.setInt32BE(buffer2, 0, time);
        return new _ObjectId(buffer2);
      }
      static createFromHexString(hexString) {
        if (hexString?.length !== 24) {
          throw new BSONError("hex string must be 24 characters");
        }
        return new _ObjectId(ByteUtils.fromHex(hexString));
      }
      static createFromBase64(base64) {
        if (base64?.length !== 16) {
          throw new BSONError("base64 string must be 16 characters");
        }
        return new _ObjectId(ByteUtils.fromBase64(base64));
      }
      static isValid(id) {
        if (id == null)
          return false;
        if (typeof id === "string")
          return _ObjectId.validateHexString(id);
        try {
          new _ObjectId(id);
          return true;
        } catch {
          return false;
        }
      }
      toExtendedJSON() {
        if (this.toHexString)
          return { $oid: this.toHexString() };
        return { $oid: this.toString("hex") };
      }
      static fromExtendedJSON(doc) {
        return new _ObjectId(doc.$oid);
      }
      isCached() {
        return _ObjectId.cacheHexString && __idCache.has(this);
      }
      inspect(depth, options, inspect) {
        inspect ??= defaultInspect;
        return `new ObjectId(${inspect(this.toHexString(), options)})`;
      }
    };
    ObjectId.index = Math.floor(Math.random() * 16777215);
    function internalCalculateObjectSize(object, serializeFunctions, ignoreUndefined) {
      let totalLength = 4 + 1;
      if (Array.isArray(object)) {
        for (let i = 0; i < object.length; i++) {
          totalLength += calculateElement(i.toString(), object[i], serializeFunctions, true, ignoreUndefined);
        }
      } else {
        if (typeof object?.toBSON === "function") {
          object = object.toBSON();
        }
        for (const key of Object.keys(object)) {
          totalLength += calculateElement(key, object[key], serializeFunctions, false, ignoreUndefined);
        }
      }
      return totalLength;
    }
    function calculateElement(name, value, serializeFunctions = false, isArray = false, ignoreUndefined = false) {
      if (typeof value?.toBSON === "function") {
        value = value.toBSON();
      }
      switch (typeof value) {
        case "string":
          return 1 + ByteUtils.utf8ByteLength(name) + 1 + 4 + ByteUtils.utf8ByteLength(value) + 1;
        case "number":
          if (Math.floor(value) === value && value >= JS_INT_MIN && value <= JS_INT_MAX) {
            if (value >= BSON_INT32_MIN && value <= BSON_INT32_MAX) {
              return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (4 + 1);
            } else {
              return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);
            }
          } else {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);
          }
        case "undefined":
          if (isArray || !ignoreUndefined)
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1;
          return 0;
        case "boolean":
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (1 + 1);
        case "object":
          if (value != null && typeof value._bsontype === "string" && value[BSON_VERSION_SYMBOL] !== BSON_MAJOR_VERSION) {
            throw new BSONVersionError();
          } else if (value == null || value._bsontype === "MinKey" || value._bsontype === "MaxKey") {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1;
          } else if (value._bsontype === "ObjectId") {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (12 + 1);
          } else if (value instanceof Date || isDate(value)) {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);
          } else if (ArrayBuffer.isView(value) || value instanceof ArrayBuffer || isAnyArrayBuffer(value)) {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (1 + 4 + 1) + value.byteLength;
          } else if (value._bsontype === "Long" || value._bsontype === "Double" || value._bsontype === "Timestamp") {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);
          } else if (value._bsontype === "Decimal128") {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (16 + 1);
          } else if (value._bsontype === "Code") {
            if (value.scope != null && Object.keys(value.scope).length > 0) {
              return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + 4 + 4 + ByteUtils.utf8ByteLength(value.code.toString()) + 1 + internalCalculateObjectSize(value.scope, serializeFunctions, ignoreUndefined);
            } else {
              return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + 4 + ByteUtils.utf8ByteLength(value.code.toString()) + 1;
            }
          } else if (value._bsontype === "Binary") {
            const binary = value;
            if (binary.sub_type === Binary.SUBTYPE_BYTE_ARRAY) {
              return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (binary.position + 1 + 4 + 1 + 4);
            } else {
              return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (binary.position + 1 + 4 + 1);
            }
          } else if (value._bsontype === "Symbol") {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + ByteUtils.utf8ByteLength(value.value) + 4 + 1 + 1;
          } else if (value._bsontype === "DBRef") {
            const ordered_values = Object.assign({
              $ref: value.collection,
              $id: value.oid
            }, value.fields);
            if (value.db != null) {
              ordered_values["$db"] = value.db;
            }
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + internalCalculateObjectSize(ordered_values, serializeFunctions, ignoreUndefined);
          } else if (value instanceof RegExp || isRegExp(value)) {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + ByteUtils.utf8ByteLength(value.source) + 1 + (value.global ? 1 : 0) + (value.ignoreCase ? 1 : 0) + (value.multiline ? 1 : 0) + 1;
          } else if (value._bsontype === "BSONRegExp") {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + ByteUtils.utf8ByteLength(value.pattern) + 1 + ByteUtils.utf8ByteLength(value.options) + 1;
          } else {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + internalCalculateObjectSize(value, serializeFunctions, ignoreUndefined) + 1;
          }
        case "function":
          if (serializeFunctions) {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + 4 + ByteUtils.utf8ByteLength(value.toString()) + 1;
          }
          return 0;
        case "bigint":
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);
        case "symbol":
          return 0;
        default:
          throw new BSONError(`Unrecognized JS type: ${typeof value}`);
      }
    }
    function alphabetize(str) {
      return str.split("").sort().join("");
    }
    var BSONRegExp = class _BSONRegExp extends BSONValue {
      get _bsontype() {
        return "BSONRegExp";
      }
      constructor(pattern, options) {
        super();
        this.pattern = pattern;
        this.options = alphabetize(options ?? "");
        if (this.pattern.indexOf("\0") !== -1) {
          throw new BSONError(`BSON Regex patterns cannot contain null bytes, found: ${JSON.stringify(this.pattern)}`);
        }
        if (this.options.indexOf("\0") !== -1) {
          throw new BSONError(`BSON Regex options cannot contain null bytes, found: ${JSON.stringify(this.options)}`);
        }
        for (let i = 0; i < this.options.length; i++) {
          if (!(this.options[i] === "i" || this.options[i] === "m" || this.options[i] === "x" || this.options[i] === "l" || this.options[i] === "s" || this.options[i] === "u")) {
            throw new BSONError(`The regular expression option [${this.options[i]}] is not supported`);
          }
        }
      }
      static parseOptions(options) {
        return options ? options.split("").sort().join("") : "";
      }
      toExtendedJSON(options) {
        options = options || {};
        if (options.legacy) {
          return { $regex: this.pattern, $options: this.options };
        }
        return { $regularExpression: { pattern: this.pattern, options: this.options } };
      }
      static fromExtendedJSON(doc) {
        if ("$regex" in doc) {
          if (typeof doc.$regex !== "string") {
            if (doc.$regex._bsontype === "BSONRegExp") {
              return doc;
            }
          } else {
            return new _BSONRegExp(doc.$regex, _BSONRegExp.parseOptions(doc.$options));
          }
        }
        if ("$regularExpression" in doc) {
          return new _BSONRegExp(doc.$regularExpression.pattern, _BSONRegExp.parseOptions(doc.$regularExpression.options));
        }
        throw new BSONError(`Unexpected BSONRegExp EJSON object form: ${JSON.stringify(doc)}`);
      }
      inspect(depth, options, inspect) {
        const stylize = getStylizeFunction(options) ?? ((v) => v);
        inspect ??= defaultInspect;
        const pattern = stylize(inspect(this.pattern), "regexp");
        const flags = stylize(inspect(this.options), "regexp");
        return `new BSONRegExp(${pattern}, ${flags})`;
      }
    };
    var BSONSymbol = class _BSONSymbol extends BSONValue {
      get _bsontype() {
        return "BSONSymbol";
      }
      constructor(value) {
        super();
        this.value = value;
      }
      valueOf() {
        return this.value;
      }
      toString() {
        return this.value;
      }
      toJSON() {
        return this.value;
      }
      toExtendedJSON() {
        return { $symbol: this.value };
      }
      static fromExtendedJSON(doc) {
        return new _BSONSymbol(doc.$symbol);
      }
      inspect(depth, options, inspect) {
        inspect ??= defaultInspect;
        return `new BSONSymbol(${inspect(this.value, options)})`;
      }
    };
    var LongWithoutOverridesClass = Long;
    var Timestamp = class _Timestamp extends LongWithoutOverridesClass {
      get _bsontype() {
        return "Timestamp";
      }
      get i() {
        return this.low >>> 0;
      }
      get t() {
        return this.high >>> 0;
      }
      constructor(low) {
        if (low == null) {
          super(0, 0, true);
        } else if (typeof low === "bigint") {
          super(low, true);
        } else if (Long.isLong(low)) {
          super(low.low, low.high, true);
        } else if (typeof low === "object" && "t" in low && "i" in low) {
          if (typeof low.t !== "number" && (typeof low.t !== "object" || low.t._bsontype !== "Int32")) {
            throw new BSONError("Timestamp constructed from { t, i } must provide t as a number");
          }
          if (typeof low.i !== "number" && (typeof low.i !== "object" || low.i._bsontype !== "Int32")) {
            throw new BSONError("Timestamp constructed from { t, i } must provide i as a number");
          }
          const t = Number(low.t);
          const i = Number(low.i);
          if (t < 0 || Number.isNaN(t)) {
            throw new BSONError("Timestamp constructed from { t, i } must provide a positive t");
          }
          if (i < 0 || Number.isNaN(i)) {
            throw new BSONError("Timestamp constructed from { t, i } must provide a positive i");
          }
          if (t > 4294967295) {
            throw new BSONError("Timestamp constructed from { t, i } must provide t equal or less than uint32 max");
          }
          if (i > 4294967295) {
            throw new BSONError("Timestamp constructed from { t, i } must provide i equal or less than uint32 max");
          }
          super(i, t, true);
        } else {
          throw new BSONError("A Timestamp can only be constructed with: bigint, Long, or { t: number; i: number }");
        }
      }
      toJSON() {
        return {
          $timestamp: this.toString()
        };
      }
      static fromInt(value) {
        return new _Timestamp(Long.fromInt(value, true));
      }
      static fromNumber(value) {
        return new _Timestamp(Long.fromNumber(value, true));
      }
      static fromBits(lowBits, highBits) {
        return new _Timestamp({ i: lowBits, t: highBits });
      }
      static fromString(str, optRadix) {
        return new _Timestamp(Long.fromString(str, true, optRadix));
      }
      toExtendedJSON() {
        return { $timestamp: { t: this.t, i: this.i } };
      }
      static fromExtendedJSON(doc) {
        const i = Long.isLong(doc.$timestamp.i) ? doc.$timestamp.i.getLowBitsUnsigned() : doc.$timestamp.i;
        const t = Long.isLong(doc.$timestamp.t) ? doc.$timestamp.t.getLowBitsUnsigned() : doc.$timestamp.t;
        return new _Timestamp({ t, i });
      }
      inspect(depth, options, inspect) {
        inspect ??= defaultInspect;
        const t = inspect(this.t, options);
        const i = inspect(this.i, options);
        return `new Timestamp({ t: ${t}, i: ${i} })`;
      }
    };
    Timestamp.MAX_VALUE = Long.MAX_UNSIGNED_VALUE;
    var JS_INT_MAX_LONG = Long.fromNumber(JS_INT_MAX);
    var JS_INT_MIN_LONG = Long.fromNumber(JS_INT_MIN);
    function internalDeserialize(buffer2, options, isArray) {
      options = options == null ? {} : options;
      const index = options && options.index ? options.index : 0;
      const size = NumberUtils.getInt32LE(buffer2, index);
      if (size < 5) {
        throw new BSONError(`bson size must be >= 5, is ${size}`);
      }
      if (options.allowObjectSmallerThanBufferSize && buffer2.length < size) {
        throw new BSONError(`buffer length ${buffer2.length} must be >= bson size ${size}`);
      }
      if (!options.allowObjectSmallerThanBufferSize && buffer2.length !== size) {
        throw new BSONError(`buffer length ${buffer2.length} must === bson size ${size}`);
      }
      if (size + index > buffer2.byteLength) {
        throw new BSONError(`(bson size ${size} + options.index ${index} must be <= buffer length ${buffer2.byteLength})`);
      }
      if (buffer2[index + size - 1] !== 0) {
        throw new BSONError("One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00");
      }
      return deserializeObject(buffer2, index, options, isArray);
    }
    var allowedDBRefKeys = /^\$ref$|^\$id$|^\$db$/;
    function deserializeObject(buffer2, index, options, isArray = false) {
      const fieldsAsRaw = options["fieldsAsRaw"] == null ? null : options["fieldsAsRaw"];
      const raw = options["raw"] == null ? false : options["raw"];
      const bsonRegExp = typeof options["bsonRegExp"] === "boolean" ? options["bsonRegExp"] : false;
      const promoteBuffers = options.promoteBuffers ?? false;
      const promoteLongs = options.promoteLongs ?? true;
      const promoteValues = options.promoteValues ?? true;
      const useBigInt64 = options.useBigInt64 ?? false;
      if (useBigInt64 && !promoteValues) {
        throw new BSONError("Must either request bigint or Long for int64 deserialization");
      }
      if (useBigInt64 && !promoteLongs) {
        throw new BSONError("Must either request bigint or Long for int64 deserialization");
      }
      const validation = options.validation == null ? { utf8: true } : options.validation;
      let globalUTFValidation = true;
      let validationSetting;
      let utf8KeysSet;
      const utf8ValidatedKeys = validation.utf8;
      if (typeof utf8ValidatedKeys === "boolean") {
        validationSetting = utf8ValidatedKeys;
      } else {
        globalUTFValidation = false;
        const utf8ValidationValues = Object.keys(utf8ValidatedKeys).map(function(key) {
          return utf8ValidatedKeys[key];
        });
        if (utf8ValidationValues.length === 0) {
          throw new BSONError("UTF-8 validation setting cannot be empty");
        }
        if (typeof utf8ValidationValues[0] !== "boolean") {
          throw new BSONError("Invalid UTF-8 validation option, must specify boolean values");
        }
        validationSetting = utf8ValidationValues[0];
        if (!utf8ValidationValues.every((item) => item === validationSetting)) {
          throw new BSONError("Invalid UTF-8 validation option - keys must be all true or all false");
        }
      }
      if (!globalUTFValidation) {
        utf8KeysSet = /* @__PURE__ */ new Set();
        for (const key of Object.keys(utf8ValidatedKeys)) {
          utf8KeysSet.add(key);
        }
      }
      const startIndex = index;
      if (buffer2.length < 5)
        throw new BSONError("corrupt bson message < 5 bytes long");
      const size = NumberUtils.getInt32LE(buffer2, index);
      index += 4;
      if (size < 5 || size > buffer2.length)
        throw new BSONError("corrupt bson message");
      const object = isArray ? [] : {};
      let arrayIndex = 0;
      let isPossibleDBRef = isArray ? false : null;
      while (true) {
        const elementType = buffer2[index++];
        if (elementType === 0)
          break;
        let i = index;
        while (buffer2[i] !== 0 && i < buffer2.length) {
          i++;
        }
        if (i >= buffer2.byteLength)
          throw new BSONError("Bad BSON Document: illegal CString");
        const name = isArray ? arrayIndex++ : ByteUtils.toUTF8(buffer2, index, i, false);
        let shouldValidateKey = true;
        if (globalUTFValidation || utf8KeysSet?.has(name)) {
          shouldValidateKey = validationSetting;
        } else {
          shouldValidateKey = !validationSetting;
        }
        if (isPossibleDBRef !== false && name[0] === "$") {
          isPossibleDBRef = allowedDBRefKeys.test(name);
        }
        let value;
        index = i + 1;
        if (elementType === BSON_DATA_STRING) {
          const stringSize = NumberUtils.getInt32LE(buffer2, index);
          index += 4;
          if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0) {
            throw new BSONError("bad string length in bson");
          }
          value = ByteUtils.toUTF8(buffer2, index, index + stringSize - 1, shouldValidateKey);
          index = index + stringSize;
        } else if (elementType === BSON_DATA_OID) {
          const oid = ByteUtils.allocateUnsafe(12);
          for (let i2 = 0; i2 < 12; i2++)
            oid[i2] = buffer2[index + i2];
          value = new ObjectId(oid);
          index = index + 12;
        } else if (elementType === BSON_DATA_INT && promoteValues === false) {
          value = new Int32(NumberUtils.getInt32LE(buffer2, index));
          index += 4;
        } else if (elementType === BSON_DATA_INT) {
          value = NumberUtils.getInt32LE(buffer2, index);
          index += 4;
        } else if (elementType === BSON_DATA_NUMBER) {
          value = NumberUtils.getFloat64LE(buffer2, index);
          index += 8;
          if (promoteValues === false)
            value = new Double(value);
        } else if (elementType === BSON_DATA_DATE) {
          const lowBits = NumberUtils.getInt32LE(buffer2, index);
          const highBits = NumberUtils.getInt32LE(buffer2, index + 4);
          index += 8;
          value = new Date(new Long(lowBits, highBits).toNumber());
        } else if (elementType === BSON_DATA_BOOLEAN) {
          if (buffer2[index] !== 0 && buffer2[index] !== 1)
            throw new BSONError("illegal boolean type value");
          value = buffer2[index++] === 1;
        } else if (elementType === BSON_DATA_OBJECT) {
          const _index = index;
          const objectSize = NumberUtils.getInt32LE(buffer2, index);
          if (objectSize <= 0 || objectSize > buffer2.length - index)
            throw new BSONError("bad embedded document length in bson");
          if (raw) {
            value = buffer2.subarray(index, index + objectSize);
          } else {
            let objectOptions = options;
            if (!globalUTFValidation) {
              objectOptions = { ...options, validation: { utf8: shouldValidateKey } };
            }
            value = deserializeObject(buffer2, _index, objectOptions, false);
          }
          index = index + objectSize;
        } else if (elementType === BSON_DATA_ARRAY) {
          const _index = index;
          const objectSize = NumberUtils.getInt32LE(buffer2, index);
          let arrayOptions = options;
          const stopIndex = index + objectSize;
          if (fieldsAsRaw && fieldsAsRaw[name]) {
            arrayOptions = { ...options, raw: true };
          }
          if (!globalUTFValidation) {
            arrayOptions = { ...arrayOptions, validation: { utf8: shouldValidateKey } };
          }
          value = deserializeObject(buffer2, _index, arrayOptions, true);
          index = index + objectSize;
          if (buffer2[index - 1] !== 0)
            throw new BSONError("invalid array terminator byte");
          if (index !== stopIndex)
            throw new BSONError("corrupted array bson");
        } else if (elementType === BSON_DATA_UNDEFINED) {
          value = void 0;
        } else if (elementType === BSON_DATA_NULL) {
          value = null;
        } else if (elementType === BSON_DATA_LONG) {
          if (useBigInt64) {
            value = NumberUtils.getBigInt64LE(buffer2, index);
            index += 8;
          } else {
            const lowBits = NumberUtils.getInt32LE(buffer2, index);
            const highBits = NumberUtils.getInt32LE(buffer2, index + 4);
            index += 8;
            const long = new Long(lowBits, highBits);
            if (promoteLongs && promoteValues === true) {
              value = long.lessThanOrEqual(JS_INT_MAX_LONG) && long.greaterThanOrEqual(JS_INT_MIN_LONG) ? long.toNumber() : long;
            } else {
              value = long;
            }
          }
        } else if (elementType === BSON_DATA_DECIMAL128) {
          const bytes = ByteUtils.allocateUnsafe(16);
          for (let i2 = 0; i2 < 16; i2++)
            bytes[i2] = buffer2[index + i2];
          index = index + 16;
          value = new Decimal128(bytes);
        } else if (elementType === BSON_DATA_BINARY) {
          let binarySize = NumberUtils.getInt32LE(buffer2, index);
          index += 4;
          const totalBinarySize = binarySize;
          const subType = buffer2[index++];
          if (binarySize < 0)
            throw new BSONError("Negative binary type element size found");
          if (binarySize > buffer2.byteLength)
            throw new BSONError("Binary type size larger than document size");
          if (subType === Binary.SUBTYPE_BYTE_ARRAY) {
            binarySize = NumberUtils.getInt32LE(buffer2, index);
            index += 4;
            if (binarySize < 0)
              throw new BSONError("Negative binary type element size found for subtype 0x02");
            if (binarySize > totalBinarySize - 4)
              throw new BSONError("Binary type with subtype 0x02 contains too long binary size");
            if (binarySize < totalBinarySize - 4)
              throw new BSONError("Binary type with subtype 0x02 contains too short binary size");
          }
          if (promoteBuffers && promoteValues) {
            value = ByteUtils.toLocalBufferType(buffer2.subarray(index, index + binarySize));
          } else {
            value = new Binary(buffer2.subarray(index, index + binarySize), subType);
            if (subType === BSON_BINARY_SUBTYPE_UUID_NEW && UUID.isValid(value)) {
              value = value.toUUID();
            }
          }
          index = index + binarySize;
        } else if (elementType === BSON_DATA_REGEXP && bsonRegExp === false) {
          i = index;
          while (buffer2[i] !== 0 && i < buffer2.length) {
            i++;
          }
          if (i >= buffer2.length)
            throw new BSONError("Bad BSON Document: illegal CString");
          const source = ByteUtils.toUTF8(buffer2, index, i, false);
          index = i + 1;
          i = index;
          while (buffer2[i] !== 0 && i < buffer2.length) {
            i++;
          }
          if (i >= buffer2.length)
            throw new BSONError("Bad BSON Document: illegal CString");
          const regExpOptions = ByteUtils.toUTF8(buffer2, index, i, false);
          index = i + 1;
          const optionsArray = new Array(regExpOptions.length);
          for (i = 0; i < regExpOptions.length; i++) {
            switch (regExpOptions[i]) {
              case "m":
                optionsArray[i] = "m";
                break;
              case "s":
                optionsArray[i] = "g";
                break;
              case "i":
                optionsArray[i] = "i";
                break;
            }
          }
          value = new RegExp(source, optionsArray.join(""));
        } else if (elementType === BSON_DATA_REGEXP && bsonRegExp === true) {
          i = index;
          while (buffer2[i] !== 0 && i < buffer2.length) {
            i++;
          }
          if (i >= buffer2.length)
            throw new BSONError("Bad BSON Document: illegal CString");
          const source = ByteUtils.toUTF8(buffer2, index, i, false);
          index = i + 1;
          i = index;
          while (buffer2[i] !== 0 && i < buffer2.length) {
            i++;
          }
          if (i >= buffer2.length)
            throw new BSONError("Bad BSON Document: illegal CString");
          const regExpOptions = ByteUtils.toUTF8(buffer2, index, i, false);
          index = i + 1;
          value = new BSONRegExp(source, regExpOptions);
        } else if (elementType === BSON_DATA_SYMBOL) {
          const stringSize = NumberUtils.getInt32LE(buffer2, index);
          index += 4;
          if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0) {
            throw new BSONError("bad string length in bson");
          }
          const symbol = ByteUtils.toUTF8(buffer2, index, index + stringSize - 1, shouldValidateKey);
          value = promoteValues ? symbol : new BSONSymbol(symbol);
          index = index + stringSize;
        } else if (elementType === BSON_DATA_TIMESTAMP) {
          value = new Timestamp({
            i: NumberUtils.getUint32LE(buffer2, index),
            t: NumberUtils.getUint32LE(buffer2, index + 4)
          });
          index += 8;
        } else if (elementType === BSON_DATA_MIN_KEY) {
          value = new MinKey();
        } else if (elementType === BSON_DATA_MAX_KEY) {
          value = new MaxKey();
        } else if (elementType === BSON_DATA_CODE) {
          const stringSize = NumberUtils.getInt32LE(buffer2, index);
          index += 4;
          if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0) {
            throw new BSONError("bad string length in bson");
          }
          const functionString = ByteUtils.toUTF8(buffer2, index, index + stringSize - 1, shouldValidateKey);
          value = new Code(functionString);
          index = index + stringSize;
        } else if (elementType === BSON_DATA_CODE_W_SCOPE) {
          const totalSize = NumberUtils.getInt32LE(buffer2, index);
          index += 4;
          if (totalSize < 4 + 4 + 4 + 1) {
            throw new BSONError("code_w_scope total size shorter minimum expected length");
          }
          const stringSize = NumberUtils.getInt32LE(buffer2, index);
          index += 4;
          if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0) {
            throw new BSONError("bad string length in bson");
          }
          const functionString = ByteUtils.toUTF8(buffer2, index, index + stringSize - 1, shouldValidateKey);
          index = index + stringSize;
          const _index = index;
          const objectSize = NumberUtils.getInt32LE(buffer2, index);
          const scopeObject = deserializeObject(buffer2, _index, options, false);
          index = index + objectSize;
          if (totalSize < 4 + 4 + objectSize + stringSize) {
            throw new BSONError("code_w_scope total size is too short, truncating scope");
          }
          if (totalSize > 4 + 4 + objectSize + stringSize) {
            throw new BSONError("code_w_scope total size is too long, clips outer document");
          }
          value = new Code(functionString, scopeObject);
        } else if (elementType === BSON_DATA_DBPOINTER) {
          const stringSize = NumberUtils.getInt32LE(buffer2, index);
          index += 4;
          if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0)
            throw new BSONError("bad string length in bson");
          const namespace = ByteUtils.toUTF8(buffer2, index, index + stringSize - 1, shouldValidateKey);
          index = index + stringSize;
          const oidBuffer = ByteUtils.allocateUnsafe(12);
          for (let i2 = 0; i2 < 12; i2++)
            oidBuffer[i2] = buffer2[index + i2];
          const oid = new ObjectId(oidBuffer);
          index = index + 12;
          value = new DBRef(namespace, oid);
        } else {
          throw new BSONError(`Detected unknown BSON type ${elementType.toString(16)} for fieldname "${name}"`);
        }
        if (name === "__proto__") {
          Object.defineProperty(object, name, {
            value,
            writable: true,
            enumerable: true,
            configurable: true
          });
        } else {
          object[name] = value;
        }
      }
      if (size !== index - startIndex) {
        if (isArray)
          throw new BSONError("corrupt array bson");
        throw new BSONError("corrupt object bson");
      }
      if (!isPossibleDBRef)
        return object;
      if (isDBRefLike(object)) {
        const copy = Object.assign({}, object);
        delete copy.$ref;
        delete copy.$id;
        delete copy.$db;
        return new DBRef(object.$ref, object.$id, object.$db, copy);
      }
      return object;
    }
    var regexp = /\x00/;
    var ignoreKeys = /* @__PURE__ */ new Set(["$db", "$ref", "$id", "$clusterTime"]);
    function serializeString(buffer2, key, value, index) {
      buffer2[index++] = BSON_DATA_STRING;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes + 1;
      buffer2[index - 1] = 0;
      const size = ByteUtils.encodeUTF8Into(buffer2, value, index + 4);
      NumberUtils.setInt32LE(buffer2, index, size + 1);
      index = index + 4 + size;
      buffer2[index++] = 0;
      return index;
    }
    function serializeNumber(buffer2, key, value, index) {
      const isNegativeZero = Object.is(value, -0);
      const type = !isNegativeZero && Number.isSafeInteger(value) && value <= BSON_INT32_MAX && value >= BSON_INT32_MIN ? BSON_DATA_INT : BSON_DATA_NUMBER;
      buffer2[index++] = type;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      if (type === BSON_DATA_INT) {
        index += NumberUtils.setInt32LE(buffer2, index, value);
      } else {
        index += NumberUtils.setFloat64LE(buffer2, index, value);
      }
      return index;
    }
    function serializeBigInt(buffer2, key, value, index) {
      buffer2[index++] = BSON_DATA_LONG;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index += numberOfWrittenBytes;
      buffer2[index++] = 0;
      index += NumberUtils.setBigInt64LE(buffer2, index, value);
      return index;
    }
    function serializeNull(buffer2, key, _, index) {
      buffer2[index++] = BSON_DATA_NULL;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      return index;
    }
    function serializeBoolean(buffer2, key, value, index) {
      buffer2[index++] = BSON_DATA_BOOLEAN;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      buffer2[index++] = value ? 1 : 0;
      return index;
    }
    function serializeDate(buffer2, key, value, index) {
      buffer2[index++] = BSON_DATA_DATE;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      const dateInMilis = Long.fromNumber(value.getTime());
      const lowBits = dateInMilis.getLowBits();
      const highBits = dateInMilis.getHighBits();
      index += NumberUtils.setInt32LE(buffer2, index, lowBits);
      index += NumberUtils.setInt32LE(buffer2, index, highBits);
      return index;
    }
    function serializeRegExp(buffer2, key, value, index) {
      buffer2[index++] = BSON_DATA_REGEXP;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      if (value.source && value.source.match(regexp) != null) {
        throw new BSONError("value " + value.source + " must not contain null bytes");
      }
      index = index + ByteUtils.encodeUTF8Into(buffer2, value.source, index);
      buffer2[index++] = 0;
      if (value.ignoreCase)
        buffer2[index++] = 105;
      if (value.global)
        buffer2[index++] = 115;
      if (value.multiline)
        buffer2[index++] = 109;
      buffer2[index++] = 0;
      return index;
    }
    function serializeBSONRegExp(buffer2, key, value, index) {
      buffer2[index++] = BSON_DATA_REGEXP;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      if (value.pattern.match(regexp) != null) {
        throw new BSONError("pattern " + value.pattern + " must not contain null bytes");
      }
      index = index + ByteUtils.encodeUTF8Into(buffer2, value.pattern, index);
      buffer2[index++] = 0;
      const sortedOptions = value.options.split("").sort().join("");
      index = index + ByteUtils.encodeUTF8Into(buffer2, sortedOptions, index);
      buffer2[index++] = 0;
      return index;
    }
    function serializeMinMax(buffer2, key, value, index) {
      if (value === null) {
        buffer2[index++] = BSON_DATA_NULL;
      } else if (value._bsontype === "MinKey") {
        buffer2[index++] = BSON_DATA_MIN_KEY;
      } else {
        buffer2[index++] = BSON_DATA_MAX_KEY;
      }
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      return index;
    }
    function serializeObjectId(buffer2, key, value, index) {
      buffer2[index++] = BSON_DATA_OID;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      index += value.serializeInto(buffer2, index);
      return index;
    }
    function serializeBuffer(buffer2, key, value, index) {
      buffer2[index++] = BSON_DATA_BINARY;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      const size = value.length;
      index += NumberUtils.setInt32LE(buffer2, index, size);
      buffer2[index++] = BSON_BINARY_SUBTYPE_DEFAULT;
      if (size <= 16) {
        for (let i = 0; i < size; i++)
          buffer2[index + i] = value[i];
      } else {
        buffer2.set(value, index);
      }
      index = index + size;
      return index;
    }
    function serializeObject(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path2) {
      if (path2.has(value)) {
        throw new BSONError("Cannot convert circular structure to BSON");
      }
      path2.add(value);
      buffer2[index++] = Array.isArray(value) ? BSON_DATA_ARRAY : BSON_DATA_OBJECT;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      const endIndex = serializeInto(buffer2, value, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path2);
      path2.delete(value);
      return endIndex;
    }
    function serializeDecimal128(buffer2, key, value, index) {
      buffer2[index++] = BSON_DATA_DECIMAL128;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      for (let i = 0; i < 16; i++)
        buffer2[index + i] = value.bytes[i];
      return index + 16;
    }
    function serializeLong(buffer2, key, value, index) {
      buffer2[index++] = value._bsontype === "Long" ? BSON_DATA_LONG : BSON_DATA_TIMESTAMP;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      const lowBits = value.getLowBits();
      const highBits = value.getHighBits();
      index += NumberUtils.setInt32LE(buffer2, index, lowBits);
      index += NumberUtils.setInt32LE(buffer2, index, highBits);
      return index;
    }
    function serializeInt32(buffer2, key, value, index) {
      value = value.valueOf();
      buffer2[index++] = BSON_DATA_INT;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      index += NumberUtils.setInt32LE(buffer2, index, value);
      return index;
    }
    function serializeDouble(buffer2, key, value, index) {
      buffer2[index++] = BSON_DATA_NUMBER;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      index += NumberUtils.setFloat64LE(buffer2, index, value.value);
      return index;
    }
    function serializeFunction(buffer2, key, value, index) {
      buffer2[index++] = BSON_DATA_CODE;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      const functionString = value.toString();
      const size = ByteUtils.encodeUTF8Into(buffer2, functionString, index + 4) + 1;
      NumberUtils.setInt32LE(buffer2, index, size);
      index = index + 4 + size - 1;
      buffer2[index++] = 0;
      return index;
    }
    function serializeCode(buffer2, key, value, index, checkKeys = false, depth = 0, serializeFunctions = false, ignoreUndefined = true, path2) {
      if (value.scope && typeof value.scope === "object") {
        buffer2[index++] = BSON_DATA_CODE_W_SCOPE;
        const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
        index = index + numberOfWrittenBytes;
        buffer2[index++] = 0;
        let startIndex = index;
        const functionString = value.code;
        index = index + 4;
        const codeSize = ByteUtils.encodeUTF8Into(buffer2, functionString, index + 4) + 1;
        NumberUtils.setInt32LE(buffer2, index, codeSize);
        buffer2[index + 4 + codeSize - 1] = 0;
        index = index + codeSize + 4;
        const endIndex = serializeInto(buffer2, value.scope, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path2);
        index = endIndex - 1;
        const totalSize = endIndex - startIndex;
        startIndex += NumberUtils.setInt32LE(buffer2, startIndex, totalSize);
        buffer2[index++] = 0;
      } else {
        buffer2[index++] = BSON_DATA_CODE;
        const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
        index = index + numberOfWrittenBytes;
        buffer2[index++] = 0;
        const functionString = value.code.toString();
        const size = ByteUtils.encodeUTF8Into(buffer2, functionString, index + 4) + 1;
        NumberUtils.setInt32LE(buffer2, index, size);
        index = index + 4 + size - 1;
        buffer2[index++] = 0;
      }
      return index;
    }
    function serializeBinary(buffer2, key, value, index) {
      buffer2[index++] = BSON_DATA_BINARY;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      const data = value.buffer;
      let size = value.position;
      if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY)
        size = size + 4;
      index += NumberUtils.setInt32LE(buffer2, index, size);
      buffer2[index++] = value.sub_type;
      if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY) {
        size = size - 4;
        index += NumberUtils.setInt32LE(buffer2, index, size);
      }
      if (value.sub_type === Binary.SUBTYPE_VECTOR) {
        validateBinaryVector(value);
      }
      if (size <= 16) {
        for (let i = 0; i < size; i++)
          buffer2[index + i] = data[i];
      } else {
        buffer2.set(data, index);
      }
      index = index + value.position;
      return index;
    }
    function serializeSymbol(buffer2, key, value, index) {
      buffer2[index++] = BSON_DATA_SYMBOL;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      const size = ByteUtils.encodeUTF8Into(buffer2, value.value, index + 4) + 1;
      NumberUtils.setInt32LE(buffer2, index, size);
      index = index + 4 + size - 1;
      buffer2[index++] = 0;
      return index;
    }
    function serializeDBRef(buffer2, key, value, index, depth, serializeFunctions, path2) {
      buffer2[index++] = BSON_DATA_OBJECT;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      let startIndex = index;
      let output = {
        $ref: value.collection || value.namespace,
        $id: value.oid
      };
      if (value.db != null) {
        output.$db = value.db;
      }
      output = Object.assign(output, value.fields);
      const endIndex = serializeInto(buffer2, output, false, index, depth + 1, serializeFunctions, true, path2);
      const size = endIndex - startIndex;
      startIndex += NumberUtils.setInt32LE(buffer2, index, size);
      return endIndex;
    }
    function serializeInto(buffer2, object, checkKeys, startingIndex, depth, serializeFunctions, ignoreUndefined, path2) {
      if (path2 == null) {
        if (object == null) {
          buffer2[0] = 5;
          buffer2[1] = 0;
          buffer2[2] = 0;
          buffer2[3] = 0;
          buffer2[4] = 0;
          return 5;
        }
        if (Array.isArray(object)) {
          throw new BSONError("serialize does not support an array as the root input");
        }
        if (typeof object !== "object") {
          throw new BSONError("serialize does not support non-object as the root input");
        } else if ("_bsontype" in object && typeof object._bsontype === "string") {
          throw new BSONError(`BSON types cannot be serialized as a document`);
        } else if (isDate(object) || isRegExp(object) || isUint8Array(object) || isAnyArrayBuffer(object)) {
          throw new BSONError(`date, regexp, typedarray, and arraybuffer cannot be BSON documents`);
        }
        path2 = /* @__PURE__ */ new Set();
      }
      path2.add(object);
      let index = startingIndex + 4;
      if (Array.isArray(object)) {
        for (let i = 0; i < object.length; i++) {
          const key = `${i}`;
          let value = object[i];
          if (typeof value?.toBSON === "function") {
            value = value.toBSON();
          }
          const type = typeof value;
          if (value === void 0) {
            index = serializeNull(buffer2, key, value, index);
          } else if (value === null) {
            index = serializeNull(buffer2, key, value, index);
          } else if (type === "string") {
            index = serializeString(buffer2, key, value, index);
          } else if (type === "number") {
            index = serializeNumber(buffer2, key, value, index);
          } else if (type === "bigint") {
            index = serializeBigInt(buffer2, key, value, index);
          } else if (type === "boolean") {
            index = serializeBoolean(buffer2, key, value, index);
          } else if (type === "object" && value._bsontype == null) {
            if (value instanceof Date || isDate(value)) {
              index = serializeDate(buffer2, key, value, index);
            } else if (value instanceof Uint8Array || isUint8Array(value)) {
              index = serializeBuffer(buffer2, key, value, index);
            } else if (value instanceof RegExp || isRegExp(value)) {
              index = serializeRegExp(buffer2, key, value, index);
            } else {
              index = serializeObject(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path2);
            }
          } else if (type === "object") {
            if (value[BSON_VERSION_SYMBOL] !== BSON_MAJOR_VERSION) {
              throw new BSONVersionError();
            } else if (value._bsontype === "ObjectId") {
              index = serializeObjectId(buffer2, key, value, index);
            } else if (value._bsontype === "Decimal128") {
              index = serializeDecimal128(buffer2, key, value, index);
            } else if (value._bsontype === "Long" || value._bsontype === "Timestamp") {
              index = serializeLong(buffer2, key, value, index);
            } else if (value._bsontype === "Double") {
              index = serializeDouble(buffer2, key, value, index);
            } else if (value._bsontype === "Code") {
              index = serializeCode(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path2);
            } else if (value._bsontype === "Binary") {
              index = serializeBinary(buffer2, key, value, index);
            } else if (value._bsontype === "BSONSymbol") {
              index = serializeSymbol(buffer2, key, value, index);
            } else if (value._bsontype === "DBRef") {
              index = serializeDBRef(buffer2, key, value, index, depth, serializeFunctions, path2);
            } else if (value._bsontype === "BSONRegExp") {
              index = serializeBSONRegExp(buffer2, key, value, index);
            } else if (value._bsontype === "Int32") {
              index = serializeInt32(buffer2, key, value, index);
            } else if (value._bsontype === "MinKey" || value._bsontype === "MaxKey") {
              index = serializeMinMax(buffer2, key, value, index);
            } else if (typeof value._bsontype !== "undefined") {
              throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);
            }
          } else if (type === "function" && serializeFunctions) {
            index = serializeFunction(buffer2, key, value, index);
          }
        }
      } else if (object instanceof Map || isMap(object)) {
        const iterator = object.entries();
        let done = false;
        while (!done) {
          const entry = iterator.next();
          done = !!entry.done;
          if (done)
            continue;
          const key = entry.value ? entry.value[0] : void 0;
          let value = entry.value ? entry.value[1] : void 0;
          if (typeof value?.toBSON === "function") {
            value = value.toBSON();
          }
          const type = typeof value;
          if (typeof key === "string" && !ignoreKeys.has(key)) {
            if (key.match(regexp) != null) {
              throw new BSONError("key " + key + " must not contain null bytes");
            }
            if (checkKeys) {
              if ("$" === key[0]) {
                throw new BSONError("key " + key + " must not start with '$'");
              } else if (key.includes(".")) {
                throw new BSONError("key " + key + " must not contain '.'");
              }
            }
          }
          if (value === void 0) {
            if (ignoreUndefined === false)
              index = serializeNull(buffer2, key, value, index);
          } else if (value === null) {
            index = serializeNull(buffer2, key, value, index);
          } else if (type === "string") {
            index = serializeString(buffer2, key, value, index);
          } else if (type === "number") {
            index = serializeNumber(buffer2, key, value, index);
          } else if (type === "bigint") {
            index = serializeBigInt(buffer2, key, value, index);
          } else if (type === "boolean") {
            index = serializeBoolean(buffer2, key, value, index);
          } else if (type === "object" && value._bsontype == null) {
            if (value instanceof Date || isDate(value)) {
              index = serializeDate(buffer2, key, value, index);
            } else if (value instanceof Uint8Array || isUint8Array(value)) {
              index = serializeBuffer(buffer2, key, value, index);
            } else if (value instanceof RegExp || isRegExp(value)) {
              index = serializeRegExp(buffer2, key, value, index);
            } else {
              index = serializeObject(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path2);
            }
          } else if (type === "object") {
            if (value[BSON_VERSION_SYMBOL] !== BSON_MAJOR_VERSION) {
              throw new BSONVersionError();
            } else if (value._bsontype === "ObjectId") {
              index = serializeObjectId(buffer2, key, value, index);
            } else if (value._bsontype === "Decimal128") {
              index = serializeDecimal128(buffer2, key, value, index);
            } else if (value._bsontype === "Long" || value._bsontype === "Timestamp") {
              index = serializeLong(buffer2, key, value, index);
            } else if (value._bsontype === "Double") {
              index = serializeDouble(buffer2, key, value, index);
            } else if (value._bsontype === "Code") {
              index = serializeCode(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path2);
            } else if (value._bsontype === "Binary") {
              index = serializeBinary(buffer2, key, value, index);
            } else if (value._bsontype === "BSONSymbol") {
              index = serializeSymbol(buffer2, key, value, index);
            } else if (value._bsontype === "DBRef") {
              index = serializeDBRef(buffer2, key, value, index, depth, serializeFunctions, path2);
            } else if (value._bsontype === "BSONRegExp") {
              index = serializeBSONRegExp(buffer2, key, value, index);
            } else if (value._bsontype === "Int32") {
              index = serializeInt32(buffer2, key, value, index);
            } else if (value._bsontype === "MinKey" || value._bsontype === "MaxKey") {
              index = serializeMinMax(buffer2, key, value, index);
            } else if (typeof value._bsontype !== "undefined") {
              throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);
            }
          } else if (type === "function" && serializeFunctions) {
            index = serializeFunction(buffer2, key, value, index);
          }
        }
      } else {
        if (typeof object?.toBSON === "function") {
          object = object.toBSON();
          if (object != null && typeof object !== "object") {
            throw new BSONError("toBSON function did not return an object");
          }
        }
        for (const key of Object.keys(object)) {
          let value = object[key];
          if (typeof value?.toBSON === "function") {
            value = value.toBSON();
          }
          const type = typeof value;
          if (typeof key === "string" && !ignoreKeys.has(key)) {
            if (key.match(regexp) != null) {
              throw new BSONError("key " + key + " must not contain null bytes");
            }
            if (checkKeys) {
              if ("$" === key[0]) {
                throw new BSONError("key " + key + " must not start with '$'");
              } else if (key.includes(".")) {
                throw new BSONError("key " + key + " must not contain '.'");
              }
            }
          }
          if (value === void 0) {
            if (ignoreUndefined === false)
              index = serializeNull(buffer2, key, value, index);
          } else if (value === null) {
            index = serializeNull(buffer2, key, value, index);
          } else if (type === "string") {
            index = serializeString(buffer2, key, value, index);
          } else if (type === "number") {
            index = serializeNumber(buffer2, key, value, index);
          } else if (type === "bigint") {
            index = serializeBigInt(buffer2, key, value, index);
          } else if (type === "boolean") {
            index = serializeBoolean(buffer2, key, value, index);
          } else if (type === "object" && value._bsontype == null) {
            if (value instanceof Date || isDate(value)) {
              index = serializeDate(buffer2, key, value, index);
            } else if (value instanceof Uint8Array || isUint8Array(value)) {
              index = serializeBuffer(buffer2, key, value, index);
            } else if (value instanceof RegExp || isRegExp(value)) {
              index = serializeRegExp(buffer2, key, value, index);
            } else {
              index = serializeObject(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path2);
            }
          } else if (type === "object") {
            if (value[BSON_VERSION_SYMBOL] !== BSON_MAJOR_VERSION) {
              throw new BSONVersionError();
            } else if (value._bsontype === "ObjectId") {
              index = serializeObjectId(buffer2, key, value, index);
            } else if (value._bsontype === "Decimal128") {
              index = serializeDecimal128(buffer2, key, value, index);
            } else if (value._bsontype === "Long" || value._bsontype === "Timestamp") {
              index = serializeLong(buffer2, key, value, index);
            } else if (value._bsontype === "Double") {
              index = serializeDouble(buffer2, key, value, index);
            } else if (value._bsontype === "Code") {
              index = serializeCode(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path2);
            } else if (value._bsontype === "Binary") {
              index = serializeBinary(buffer2, key, value, index);
            } else if (value._bsontype === "BSONSymbol") {
              index = serializeSymbol(buffer2, key, value, index);
            } else if (value._bsontype === "DBRef") {
              index = serializeDBRef(buffer2, key, value, index, depth, serializeFunctions, path2);
            } else if (value._bsontype === "BSONRegExp") {
              index = serializeBSONRegExp(buffer2, key, value, index);
            } else if (value._bsontype === "Int32") {
              index = serializeInt32(buffer2, key, value, index);
            } else if (value._bsontype === "MinKey" || value._bsontype === "MaxKey") {
              index = serializeMinMax(buffer2, key, value, index);
            } else if (typeof value._bsontype !== "undefined") {
              throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);
            }
          } else if (type === "function" && serializeFunctions) {
            index = serializeFunction(buffer2, key, value, index);
          }
        }
      }
      path2.delete(object);
      buffer2[index++] = 0;
      const size = index - startingIndex;
      startingIndex += NumberUtils.setInt32LE(buffer2, startingIndex, size);
      return index;
    }
    function isBSONType(value) {
      return value != null && typeof value === "object" && "_bsontype" in value && typeof value._bsontype === "string";
    }
    var keysToCodecs = {
      $oid: ObjectId,
      $binary: Binary,
      $uuid: Binary,
      $symbol: BSONSymbol,
      $numberInt: Int32,
      $numberDecimal: Decimal128,
      $numberDouble: Double,
      $numberLong: Long,
      $minKey: MinKey,
      $maxKey: MaxKey,
      $regex: BSONRegExp,
      $regularExpression: BSONRegExp,
      $timestamp: Timestamp
    };
    function deserializeValue(value, options = {}) {
      if (typeof value === "number") {
        const in32BitRange = value <= BSON_INT32_MAX && value >= BSON_INT32_MIN;
        const in64BitRange = value <= BSON_INT64_MAX && value >= BSON_INT64_MIN;
        if (options.relaxed || options.legacy) {
          return value;
        }
        if (Number.isInteger(value) && !Object.is(value, -0)) {
          if (in32BitRange) {
            return new Int32(value);
          }
          if (in64BitRange) {
            if (options.useBigInt64) {
              return BigInt(value);
            }
            return Long.fromNumber(value);
          }
        }
        return new Double(value);
      }
      if (value == null || typeof value !== "object")
        return value;
      if (value.$undefined)
        return null;
      const keys = Object.keys(value).filter((k) => k.startsWith("$") && value[k] != null);
      for (let i = 0; i < keys.length; i++) {
        const c = keysToCodecs[keys[i]];
        if (c)
          return c.fromExtendedJSON(value, options);
      }
      if (value.$date != null) {
        const d = value.$date;
        const date = /* @__PURE__ */ new Date();
        if (options.legacy) {
          if (typeof d === "number")
            date.setTime(d);
          else if (typeof d === "string")
            date.setTime(Date.parse(d));
          else if (typeof d === "bigint")
            date.setTime(Number(d));
          else
            throw new BSONRuntimeError(`Unrecognized type for EJSON date: ${typeof d}`);
        } else {
          if (typeof d === "string")
            date.setTime(Date.parse(d));
          else if (Long.isLong(d))
            date.setTime(d.toNumber());
          else if (typeof d === "number" && options.relaxed)
            date.setTime(d);
          else if (typeof d === "bigint")
            date.setTime(Number(d));
          else
            throw new BSONRuntimeError(`Unrecognized type for EJSON date: ${typeof d}`);
        }
        return date;
      }
      if (value.$code != null) {
        const copy = Object.assign({}, value);
        if (value.$scope) {
          copy.$scope = deserializeValue(value.$scope);
        }
        return Code.fromExtendedJSON(value);
      }
      if (isDBRefLike(value) || value.$dbPointer) {
        const v = value.$ref ? value : value.$dbPointer;
        if (v instanceof DBRef)
          return v;
        const dollarKeys = Object.keys(v).filter((k) => k.startsWith("$"));
        let valid = true;
        dollarKeys.forEach((k) => {
          if (["$ref", "$id", "$db"].indexOf(k) === -1)
            valid = false;
        });
        if (valid)
          return DBRef.fromExtendedJSON(v);
      }
      return value;
    }
    function serializeArray(array, options) {
      return array.map((v, index) => {
        options.seenObjects.push({ propertyName: `index ${index}`, obj: null });
        try {
          return serializeValue(v, options);
        } finally {
          options.seenObjects.pop();
        }
      });
    }
    function getISOString(date) {
      const isoStr = date.toISOString();
      return date.getUTCMilliseconds() !== 0 ? isoStr : isoStr.slice(0, -5) + "Z";
    }
    function serializeValue(value, options) {
      if (value instanceof Map || isMap(value)) {
        const obj = /* @__PURE__ */ Object.create(null);
        for (const [k, v] of value) {
          if (typeof k !== "string") {
            throw new BSONError("Can only serialize maps with string keys");
          }
          obj[k] = v;
        }
        return serializeValue(obj, options);
      }
      if ((typeof value === "object" || typeof value === "function") && value !== null) {
        const index = options.seenObjects.findIndex((entry) => entry.obj === value);
        if (index !== -1) {
          const props = options.seenObjects.map((entry) => entry.propertyName);
          const leadingPart = props.slice(0, index).map((prop) => `${prop} -> `).join("");
          const alreadySeen = props[index];
          const circularPart = " -> " + props.slice(index + 1, props.length - 1).map((prop) => `${prop} -> `).join("");
          const current = props[props.length - 1];
          const leadingSpace = " ".repeat(leadingPart.length + alreadySeen.length / 2);
          const dashes = "-".repeat(circularPart.length + (alreadySeen.length + current.length) / 2 - 1);
          throw new BSONError(`Converting circular structure to EJSON:
    ${leadingPart}${alreadySeen}${circularPart}${current}
    ${leadingSpace}\\${dashes}/`);
        }
        options.seenObjects[options.seenObjects.length - 1].obj = value;
      }
      if (Array.isArray(value))
        return serializeArray(value, options);
      if (value === void 0)
        return null;
      if (value instanceof Date || isDate(value)) {
        const dateNum = value.getTime(), inRange = dateNum > -1 && dateNum < 2534023188e5;
        if (options.legacy) {
          return options.relaxed && inRange ? { $date: value.getTime() } : { $date: getISOString(value) };
        }
        return options.relaxed && inRange ? { $date: getISOString(value) } : { $date: { $numberLong: value.getTime().toString() } };
      }
      if (typeof value === "number" && (!options.relaxed || !isFinite(value))) {
        if (Number.isInteger(value) && !Object.is(value, -0)) {
          if (value >= BSON_INT32_MIN && value <= BSON_INT32_MAX) {
            return { $numberInt: value.toString() };
          }
          if (value >= BSON_INT64_MIN && value <= BSON_INT64_MAX) {
            return { $numberLong: value.toString() };
          }
        }
        return { $numberDouble: Object.is(value, -0) ? "-0.0" : value.toString() };
      }
      if (typeof value === "bigint") {
        if (!options.relaxed) {
          return { $numberLong: BigInt.asIntN(64, value).toString() };
        }
        return Number(BigInt.asIntN(64, value));
      }
      if (value instanceof RegExp || isRegExp(value)) {
        let flags = value.flags;
        if (flags === void 0) {
          const match2 = value.toString().match(/[gimuy]*$/);
          if (match2) {
            flags = match2[0];
          }
        }
        const rx = new BSONRegExp(value.source, flags);
        return rx.toExtendedJSON(options);
      }
      if (value != null && typeof value === "object")
        return serializeDocument(value, options);
      return value;
    }
    var BSON_TYPE_MAPPINGS = {
      Binary: (o) => new Binary(o.value(), o.sub_type),
      Code: (o) => new Code(o.code, o.scope),
      DBRef: (o) => new DBRef(o.collection || o.namespace, o.oid, o.db, o.fields),
      Decimal128: (o) => new Decimal128(o.bytes),
      Double: (o) => new Double(o.value),
      Int32: (o) => new Int32(o.value),
      Long: (o) => Long.fromBits(o.low != null ? o.low : o.low_, o.low != null ? o.high : o.high_, o.low != null ? o.unsigned : o.unsigned_),
      MaxKey: () => new MaxKey(),
      MinKey: () => new MinKey(),
      ObjectId: (o) => new ObjectId(o),
      BSONRegExp: (o) => new BSONRegExp(o.pattern, o.options),
      BSONSymbol: (o) => new BSONSymbol(o.value),
      Timestamp: (o) => Timestamp.fromBits(o.low, o.high)
    };
    function serializeDocument(doc, options) {
      if (doc == null || typeof doc !== "object")
        throw new BSONError("not an object instance");
      const bsontype = doc._bsontype;
      if (typeof bsontype === "undefined") {
        const _doc = {};
        for (const name of Object.keys(doc)) {
          options.seenObjects.push({ propertyName: name, obj: null });
          try {
            const value = serializeValue(doc[name], options);
            if (name === "__proto__") {
              Object.defineProperty(_doc, name, {
                value,
                writable: true,
                enumerable: true,
                configurable: true
              });
            } else {
              _doc[name] = value;
            }
          } finally {
            options.seenObjects.pop();
          }
        }
        return _doc;
      } else if (doc != null && typeof doc === "object" && typeof doc._bsontype === "string" && doc[BSON_VERSION_SYMBOL] !== BSON_MAJOR_VERSION) {
        throw new BSONVersionError();
      } else if (isBSONType(doc)) {
        let outDoc = doc;
        if (typeof outDoc.toExtendedJSON !== "function") {
          const mapper = BSON_TYPE_MAPPINGS[doc._bsontype];
          if (!mapper) {
            throw new BSONError("Unrecognized or invalid _bsontype: " + doc._bsontype);
          }
          outDoc = mapper(outDoc);
        }
        if (bsontype === "Code" && outDoc.scope) {
          outDoc = new Code(outDoc.code, serializeValue(outDoc.scope, options));
        } else if (bsontype === "DBRef" && outDoc.oid) {
          outDoc = new DBRef(serializeValue(outDoc.collection, options), serializeValue(outDoc.oid, options), serializeValue(outDoc.db, options), serializeValue(outDoc.fields, options));
        }
        return outDoc.toExtendedJSON(options);
      } else {
        throw new BSONError("_bsontype must be a string, but was: " + typeof bsontype);
      }
    }
    function parse(text, options) {
      const ejsonOptions = {
        useBigInt64: options?.useBigInt64 ?? false,
        relaxed: options?.relaxed ?? true,
        legacy: options?.legacy ?? false
      };
      return JSON.parse(text, (key, value) => {
        if (key.indexOf("\0") !== -1) {
          throw new BSONError(`BSON Document field names cannot contain null bytes, found: ${JSON.stringify(key)}`);
        }
        return deserializeValue(value, ejsonOptions);
      });
    }
    function stringify(value, replacer, space, options) {
      if (space != null && typeof space === "object") {
        options = space;
        space = 0;
      }
      if (replacer != null && typeof replacer === "object" && !Array.isArray(replacer)) {
        options = replacer;
        replacer = void 0;
        space = 0;
      }
      const serializeOptions = Object.assign({ relaxed: true, legacy: false }, options, {
        seenObjects: [{ propertyName: "(root)", obj: null }]
      });
      const doc = serializeValue(value, serializeOptions);
      return JSON.stringify(doc, replacer, space);
    }
    function EJSONserialize(value, options) {
      options = options || {};
      return JSON.parse(stringify(value, options));
    }
    function EJSONdeserialize(ejson, options) {
      options = options || {};
      return parse(JSON.stringify(ejson), options);
    }
    var EJSON = /* @__PURE__ */ Object.create(null);
    EJSON.parse = parse;
    EJSON.stringify = stringify;
    EJSON.serialize = EJSONserialize;
    EJSON.deserialize = EJSONdeserialize;
    Object.freeze(EJSON);
    function getSize(source, offset) {
      try {
        return NumberUtils.getNonnegativeInt32LE(source, offset);
      } catch (cause) {
        throw new BSONOffsetError("BSON size cannot be negative", offset, { cause });
      }
    }
    function findNull(bytes, offset) {
      let nullTerminatorOffset = offset;
      for (; bytes[nullTerminatorOffset] !== 0; nullTerminatorOffset++)
        ;
      if (nullTerminatorOffset === bytes.length - 1) {
        throw new BSONOffsetError("Null terminator not found", offset);
      }
      return nullTerminatorOffset;
    }
    function parseToElements(bytes, startOffset = 0) {
      startOffset ??= 0;
      if (bytes.length < 5) {
        throw new BSONOffsetError(`Input must be at least 5 bytes, got ${bytes.length} bytes`, startOffset);
      }
      const documentSize = getSize(bytes, startOffset);
      if (documentSize > bytes.length - startOffset) {
        throw new BSONOffsetError(`Parsed documentSize (${documentSize} bytes) does not match input length (${bytes.length} bytes)`, startOffset);
      }
      if (bytes[startOffset + documentSize - 1] !== 0) {
        throw new BSONOffsetError("BSON documents must end in 0x00", startOffset + documentSize);
      }
      const elements = [];
      let offset = startOffset + 4;
      while (offset <= documentSize + startOffset) {
        const type = bytes[offset];
        offset += 1;
        if (type === 0) {
          if (offset - startOffset !== documentSize) {
            throw new BSONOffsetError(`Invalid 0x00 type byte`, offset);
          }
          break;
        }
        const nameOffset = offset;
        const nameLength = findNull(bytes, offset) - nameOffset;
        offset += nameLength + 1;
        let length;
        if (type === 1 || type === 18 || type === 9 || type === 17) {
          length = 8;
        } else if (type === 16) {
          length = 4;
        } else if (type === 7) {
          length = 12;
        } else if (type === 19) {
          length = 16;
        } else if (type === 8) {
          length = 1;
        } else if (type === 10 || type === 6 || type === 127 || type === 255) {
          length = 0;
        } else if (type === 11) {
          length = findNull(bytes, findNull(bytes, offset) + 1) + 1 - offset;
        } else if (type === 3 || type === 4 || type === 15) {
          length = getSize(bytes, offset);
        } else if (type === 2 || type === 5 || type === 12 || type === 13 || type === 14) {
          length = getSize(bytes, offset) + 4;
          if (type === 5) {
            length += 1;
          }
          if (type === 12) {
            length += 12;
          }
        } else {
          throw new BSONOffsetError(`Invalid 0x${type.toString(16).padStart(2, "0")} type byte`, offset);
        }
        if (length > documentSize) {
          throw new BSONOffsetError("value reports length larger than document", offset);
        }
        elements.push([type, nameOffset, nameLength, offset, length]);
        offset += length;
      }
      return elements;
    }
    var onDemand = /* @__PURE__ */ Object.create(null);
    onDemand.parseToElements = parseToElements;
    onDemand.ByteUtils = ByteUtils;
    onDemand.NumberUtils = NumberUtils;
    Object.freeze(onDemand);
    var MAXSIZE = 1024 * 1024 * 17;
    var buffer = ByteUtils.allocate(MAXSIZE);
    function setInternalBufferSize(size) {
      if (buffer.length < size) {
        buffer = ByteUtils.allocate(size);
      }
    }
    function serialize(object, options = {}) {
      const checkKeys = typeof options.checkKeys === "boolean" ? options.checkKeys : false;
      const serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
      const ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : true;
      const minInternalBufferSize = typeof options.minInternalBufferSize === "number" ? options.minInternalBufferSize : MAXSIZE;
      if (buffer.length < minInternalBufferSize) {
        buffer = ByteUtils.allocate(minInternalBufferSize);
      }
      const serializationIndex = serializeInto(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, null);
      const finishedBuffer = ByteUtils.allocateUnsafe(serializationIndex);
      finishedBuffer.set(buffer.subarray(0, serializationIndex), 0);
      return finishedBuffer;
    }
    function serializeWithBufferAndIndex(object, finalBuffer, options = {}) {
      const checkKeys = typeof options.checkKeys === "boolean" ? options.checkKeys : false;
      const serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
      const ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : true;
      const startIndex = typeof options.index === "number" ? options.index : 0;
      const serializationIndex = serializeInto(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, null);
      finalBuffer.set(buffer.subarray(0, serializationIndex), startIndex);
      return startIndex + serializationIndex - 1;
    }
    function deserialize(buffer2, options = {}) {
      return internalDeserialize(ByteUtils.toLocalBufferType(buffer2), options);
    }
    function calculateObjectSize(object, options = {}) {
      options = options || {};
      const serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
      const ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : true;
      return internalCalculateObjectSize(object, serializeFunctions, ignoreUndefined);
    }
    function deserializeStream(data, startIndex, numberOfDocuments, documents2, docStartIndex, options) {
      const internalOptions = Object.assign({ allowObjectSmallerThanBufferSize: true, index: 0 }, options);
      const bufferData = ByteUtils.toLocalBufferType(data);
      let index = startIndex;
      for (let i = 0; i < numberOfDocuments; i++) {
        const size = NumberUtils.getInt32LE(bufferData, index);
        internalOptions.index = index;
        documents2[docStartIndex + i] = internalDeserialize(bufferData, internalOptions);
        index = index + size;
      }
      return index;
    }
    var bson = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      BSONError,
      BSONOffsetError,
      BSONRegExp,
      BSONRuntimeError,
      BSONSymbol,
      BSONType,
      BSONValue,
      BSONVersionError,
      Binary,
      Code,
      DBRef,
      Decimal128,
      Double,
      EJSON,
      Int32,
      Long,
      MaxKey,
      MinKey,
      ObjectId,
      Timestamp,
      UUID,
      calculateObjectSize,
      deserialize,
      deserializeStream,
      onDemand,
      serialize,
      serializeWithBufferAndIndex,
      setInternalBufferSize
    });
    exports2.BSON = bson;
    exports2.BSONError = BSONError;
    exports2.BSONOffsetError = BSONOffsetError;
    exports2.BSONRegExp = BSONRegExp;
    exports2.BSONRuntimeError = BSONRuntimeError;
    exports2.BSONSymbol = BSONSymbol;
    exports2.BSONType = BSONType;
    exports2.BSONValue = BSONValue;
    exports2.BSONVersionError = BSONVersionError;
    exports2.Binary = Binary;
    exports2.Code = Code;
    exports2.DBRef = DBRef;
    exports2.Decimal128 = Decimal128;
    exports2.Double = Double;
    exports2.EJSON = EJSON;
    exports2.Int32 = Int32;
    exports2.Long = Long;
    exports2.MaxKey = MaxKey;
    exports2.MinKey = MinKey;
    exports2.ObjectId = ObjectId;
    exports2.Timestamp = Timestamp;
    exports2.UUID = UUID;
    exports2.calculateObjectSize = calculateObjectSize;
    exports2.deserialize = deserialize;
    exports2.deserializeStream = deserializeStream;
    exports2.onDemand = onDemand;
    exports2.serialize = serialize;
    exports2.serializeWithBufferAndIndex = serializeWithBufferAndIndex;
    exports2.setInternalBufferSize = setInternalBufferSize;
  }
});

// ../../../sonata-api/packages/common/dist/serialize.js
var require_serialize = __commonJS({
  "../../../sonata-api/packages/common/dist/serialize.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.deserialize = exports2.serialize = void 0;
    var BSON = require_bson();
    var serialize = (...args) => Buffer.from(BSON.serialize(...args)).toString("latin1");
    exports2.serialize = serialize;
    var deserialize = (buffer) => {
      return BSON.deserialize(new Uint8Array(Array.from(buffer).map((c) => c.charCodeAt(0))));
    };
    exports2.deserialize = deserialize;
  }
});

// ../../../sonata-api/packages/common/dist/index.js
var require_dist2 = __commonJS({
  "../../../sonata-api/packages/common/dist/index.js"(exports2) {
    "use strict";
    init_importMeta();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_arraysIntersect(), exports2);
    __exportStar(require_checkForEmptiness(), exports2);
    __exportStar(require_deepClone(), exports2);
    __exportStar(require_deepMerge(), exports2);
    __exportStar(require_dynamicImport(), exports2);
    __exportStar(require_result2(), exports2);
    __exportStar(require_endpointError2(), exports2);
    __exportStar(require_evaluateCondition(), exports2);
    __exportStar(require_freshItem(), exports2);
    __exportStar(require_getMissingProperties(), exports2);
    __exportStar(require_getReferenceProperty(), exports2);
    __exportStar(require_getValueFromPath(), exports2);
    __exportStar(require_http2(), exports2);
    __exportStar(require_isGranted(), exports2);
    __exportStar(require_isReference(), exports2);
    __exportStar(require_isRequired(), exports2);
    __exportStar(require_isValidCollection(), exports2);
    __exportStar(require_convertConditionToQuery(), exports2);
    __exportStar(require_pipe(), exports2);
    __exportStar(require_serialize(), exports2);
  }
});

// ../../../sonata-api/packages/compiler/dist/semantic.js
var require_semantic = __commonJS({
  "../../../sonata-api/packages/compiler/dist/semantic.js"(exports2) {
    "use strict";
    init_importMeta();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || /* @__PURE__ */ function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.analyze = void 0;
    var common_1 = require_dist2();
    var parser_js_1 = require_parser();
    var diagnostic_js_1 = require_diagnostic2();
    var AST2 = __importStar(require_ast());
    var collectionHasProperty = async (collection, propName, options = {}) => {
      let hasProperty = propName in collection.properties;
      if (!hasProperty) {
        if (collection.extends) {
          if (options.languageServer) {
            return true;
          }
          const { packageName, symbolName } = collection.extends;
          const { [symbolName]: importedCollection } = await Promise.resolve(`${packageName}`).then((s) => __importStar(require(s)));
          if (!(0, common_1.isValidCollection)(importedCollection)) {
            throw new Error();
          }
          hasProperty = propName in importedCollection.description.properties;
        }
      }
      return hasProperty;
    };
    var analyze = async (ast, options, errors = []) => {
      const checkCollectionForeignProperties = async (foreignCollection, property, attributeName) => {
        if (!property[attributeName]) {
          return;
        }
        for (const foreignPropName of property[attributeName]) {
          if (!await collectionHasProperty(foreignCollection, foreignPropName, options)) {
            let location;
            if (property[AST2.LOCATION_SYMBOL]) {
              location = parser_js_1.locationMap.get(property[AST2.LOCATION_SYMBOL].attributes[attributeName]);
            }
            errors.push(new diagnostic_js_1.Diagnostic(`collection "${foreignCollection.name}" hasn't such property "${foreignPropName}"`, location));
          }
        }
      };
      const checkCollectionLocalProperties = async (node, attributeName) => {
        if (!node[attributeName]) {
          return;
        }
        for (const index in node[attributeName]) {
          const propName = node[attributeName][index];
          if (!await collectionHasProperty(node, propName, options)) {
            const symbol = node[AST2.LOCATION_SYMBOL].arrays[attributeName][index];
            const location = parser_js_1.locationMap.get(symbol);
            errors.push(new diagnostic_js_1.Diagnostic(`collection "${node.name}" hasn't such property "${propName}"`, location));
          }
        }
      };
      const checkObjectLocalProperties = async (node, attributeName) => {
        if (!("properties" in node.property) || !node.property[attributeName]) {
          return;
        }
        for (const index in node.property[attributeName]) {
          const propName = node.property[attributeName][index];
          if (!(propName in node.property.properties)) {
            const symbol = node.property[AST2.LOCATION_SYMBOL].arrays[attributeName][index];
            const location = parser_js_1.locationMap.get(symbol);
            errors.push(new diagnostic_js_1.Diagnostic(`object hasn't such property "${propName}"`, location));
          }
        }
      };
      const recurseProperty = async (node) => {
        if ("type" in node.property && node.property.type === "object") {
          if (typeof node.nestedAdditionalProperties === "object") {
            await recurseProperty(node.nestedAdditionalProperties);
          }
          if (node.nestedProperties) {
            await checkObjectLocalProperties(node, "required");
            await checkObjectLocalProperties(node, "writable");
            await checkObjectLocalProperties(node, "form");
            for (const propName in node.nestedProperties) {
              const subProperty = node.nestedProperties[propName];
              await recurseProperty(subProperty);
            }
          }
        } else if ("$ref" in node.property) {
          const refName = node.property.$ref;
          const foreignCollection = ast.collections.find(({ name }) => name === refName);
          if (!foreignCollection) {
            const location = parser_js_1.locationMap.get(node.property[AST2.LOCATION_SYMBOL].type);
            errors.push(new diagnostic_js_1.Diagnostic(`invalid reference "${refName}"`, location));
            return;
          }
          await checkCollectionForeignProperties(foreignCollection, node.property, "indexes");
          await checkCollectionForeignProperties(foreignCollection, node.property, "populate");
          await checkCollectionForeignProperties(foreignCollection, node.property, "form");
          if (node.property.constraints) {
            for (const [name, symbol] of node.property[AST2.LOCATION_SYMBOL].contraintTerms) {
              if (!await collectionHasProperty(foreignCollection, name, options)) {
                const location = parser_js_1.locationMap.get(symbol);
                errors.push(new diagnostic_js_1.Diagnostic(`left operand "${name}" does not exist on collection "${foreignCollection.name}"`, location));
              }
            }
          }
        } else if ("items" in node.property) {
          await recurseProperty({
            kind: "property",
            property: node.property.items
          });
        }
      };
      for (const node of ast.collections) {
        await checkCollectionLocalProperties(node, "indexes");
        await checkCollectionLocalProperties(node, "filters");
        await checkCollectionLocalProperties(node, "form");
        await checkCollectionLocalProperties(node, "table");
        await checkCollectionLocalProperties(node, "tableMeta");
        if (node.required) {
          const propNames = Array.isArray(node.required) ? node.required : Object.keys(node.required);
          for (const index in propNames) {
            const propName = propNames[index];
            if (!(propName in node.properties)) {
              const symbol = node[AST2.LOCATION_SYMBOL].required[index];
              const location = parser_js_1.locationMap.get(symbol);
              errors.push(new diagnostic_js_1.Diagnostic(`collection "${node.name}" hasn't such property "${propName}"`, location));
            }
          }
        }
        for (const propName in node.properties) {
          const subNode = node.properties[propName];
          await recurseProperty(subNode);
        }
        if (node[AST2.LOCATION_SYMBOL].requiredTerms) {
          for (const [name, symbol] of node[AST2.LOCATION_SYMBOL].requiredTerms) {
            if (!(name in node.properties)) {
              const location = parser_js_1.locationMap.get(symbol);
              errors.push(new diagnostic_js_1.Diagnostic(`invalid left operand "${name}"`, location));
            }
          }
        }
        if (node.layout) {
          if (node.layout.options) {
            for (const [name, value] of Object.entries(node.layout[AST2.LOCATION_SYMBOL].options)) {
              const option = node.layout.options[name];
              if (Array.isArray(option)) {
                for (const [i, propName] of option.entries()) {
                  if (!(propName in node.properties)) {
                    const location = parser_js_1.locationMap.get(value[i]);
                    errors.push(new diagnostic_js_1.Diagnostic(`invalid property "${propName}"`, location));
                  }
                }
              } else {
                if (!(option in node.properties)) {
                  const location = parser_js_1.locationMap.get(value);
                  errors.push(new diagnostic_js_1.Diagnostic(`invalid property "${option}"`, location));
                }
              }
            }
          }
        }
        if (node.formLayout) {
          if (node.formLayout.fields) {
            for (const [name, value] of Object.entries(node.formLayout[AST2.LOCATION_SYMBOL].fields)) {
              if (!(name in node.properties)) {
                const location = parser_js_1.locationMap.get(value.name);
                errors.push(new diagnostic_js_1.Diagnostic(`invalid property "${name}"`, location));
              }
            }
          }
          if (node.formLayout[AST2.LOCATION_SYMBOL].terms) {
            for (const [name, symbol] of node.formLayout[AST2.LOCATION_SYMBOL].terms) {
              if (!(name in node.properties)) {
                const location = parser_js_1.locationMap.get(symbol);
                errors.push(new diagnostic_js_1.Diagnostic(`invalid left operand "${name}"`, location));
              }
            }
          }
        }
      }
      for (const node of ast.contracts) {
        if (node.payload) {
          await recurseProperty(node.payload);
        }
        if (node.query) {
          await recurseProperty(node.query);
        }
        if (node.response) {
          if (Array.isArray(node.response)) {
            for (const subNode of node.response) {
              await recurseProperty(subNode);
            }
          } else {
            await recurseProperty(node.response);
          }
        }
      }
      return {
        errors
      };
    };
    exports2.analyze = analyze;
  }
});

// ../../../sonata-api/packages/compiler/dist/codegen/utils.js
var require_utils = __commonJS({
  "../../../sonata-api/packages/compiler/dist/codegen/utils.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getExtendName = exports2.getCollectionId = exports2.resizeFirstChar = exports2.stringify = exports2.recursivelyUnwrapPropertyNodes = exports2.unwrapPropertyNode = exports2.unwrapNode = exports2.makeASTImports = exports2.getExposedFunctions = exports2.ArraySymbol = exports2.UnquotedSymbol = exports2.DEFAULT_FUNCTIONS = exports2.MIDDLEWARES_RUNTIME_PATH = exports2.PACKAGE_NAME = void 0;
    exports2.PACKAGE_NAME = "aeria";
    exports2.MIDDLEWARES_RUNTIME_PATH = "../../../dist/middlewares/index.js";
    exports2.DEFAULT_FUNCTIONS = [
      "count",
      "get",
      "getAll",
      "insert",
      "remove",
      "removeAll",
      "removeFile",
      "unpaginatedGetAll",
      "upload"
    ];
    exports2.UnquotedSymbol = Symbol("unquoted");
    exports2.ArraySymbol = Symbol("array");
    var getExposedFunctions = (astFunctions) => {
      return Object.fromEntries(Object.entries(astFunctions).map(([key, value]) => [
        key,
        value.accessCondition
      ]));
    };
    exports2.getExposedFunctions = getExposedFunctions;
    var makeASTImports = (ast, initialImports, options = {
      includeRuntimeOnlyImports: false
    }) => {
      const modifiedSymbols = {};
      const toImport = ast.reduce((imports, node) => {
        if (node.kind === "collection") {
          if (node.extends?.packageName) {
            if (!(node.extends.packageName in imports)) {
              imports[node.extends.packageName] = /* @__PURE__ */ new Set();
            }
            const modifiedSymbol = `original${(0, exports2.resizeFirstChar)(node.extends.symbolName, true)}`;
            modifiedSymbols[node.extends.symbolName] = modifiedSymbol;
            imports[node.extends.packageName].add(`${node.extends.symbolName} as ${modifiedSymbol}`);
          }
          if (node.functions) {
            const functionsToImport = Object.keys(node.functions).filter((key) => exports2.DEFAULT_FUNCTIONS.includes(key));
            if (functionsToImport.length > 0) {
              imports[exports2.PACKAGE_NAME] ??= /* @__PURE__ */ new Set();
              for (const key of functionsToImport) {
                imports[exports2.PACKAGE_NAME].add(key);
              }
            }
          }
          if (options.includeRuntimeOnlyImports) {
            if (node.middlewares) {
              imports[exports2.MIDDLEWARES_RUNTIME_PATH] ??= /* @__PURE__ */ new Set();
              for (const middleware of node.middlewares) {
                imports[exports2.MIDDLEWARES_RUNTIME_PATH].add(middleware);
              }
            }
          }
        }
        return imports;
      }, initialImports ?? {});
      return {
        code: Object.keys(toImport).map((key) => `import { ${Array.from(toImport[key]).join(", ")} } from '${key}'`),
        modifiedSymbols
      };
    };
    exports2.makeASTImports = makeASTImports;
    var unwrapNode = (node) => {
      const { kind, ...unwrappedNode } = Object.fromEntries(Object.entries(node).filter(([key]) => typeof key === "string"));
      return unwrappedNode;
    };
    exports2.unwrapNode = unwrapNode;
    var unwrapPropertyNode = ({ property, nestedProperties, nestedAdditionalProperties }) => {
      const propertyOrPropertyItems = "items" in property ? property.items : property;
      let unwrappedProperty = propertyOrPropertyItems;
      if ("$ref" in propertyOrPropertyItems) {
        unwrappedProperty = {
          ...propertyOrPropertyItems,
          $ref: (0, exports2.getCollectionId)(propertyOrPropertyItems.$ref)
        };
      } else if ("type" in propertyOrPropertyItems && propertyOrPropertyItems.type === "object") {
        let properties;
        let additionalProperties;
        if (nestedProperties) {
          properties = (0, exports2.recursivelyUnwrapPropertyNodes)(nestedProperties);
        }
        if (nestedAdditionalProperties) {
          additionalProperties = typeof nestedAdditionalProperties === "boolean" ? nestedAdditionalProperties : (0, exports2.unwrapPropertyNode)(nestedAdditionalProperties);
        }
        if (properties && additionalProperties) {
          unwrappedProperty = {
            ...propertyOrPropertyItems,
            properties,
            additionalProperties
          };
        } else if (properties) {
          unwrappedProperty = {
            ...propertyOrPropertyItems,
            properties
          };
        } else if (additionalProperties) {
          unwrappedProperty = {
            ...propertyOrPropertyItems,
            additionalProperties
          };
        }
      }
      if ("items" in property) {
        return {
          ...property,
          items: unwrappedProperty
        };
      }
      return unwrappedProperty;
    };
    exports2.unwrapPropertyNode = unwrapPropertyNode;
    var recursivelyUnwrapPropertyNodes = (properties) => {
      return Object.entries(properties).reduce((acc, [key, value]) => {
        if (Array.isArray(value)) {
          acc[key] = value.map((propertyNode) => (0, exports2.unwrapPropertyNode)(propertyNode));
        } else {
          acc[key] = (0, exports2.unwrapPropertyNode)(value);
        }
        return acc;
      }, {});
    };
    exports2.recursivelyUnwrapPropertyNodes = recursivelyUnwrapPropertyNodes;
    var isRecord = (value) => {
      return !!(value && typeof value === "object");
    };
    var stringify = (value, parents = []) => {
      if (Array.isArray(value)) {
        let arrayString = "[\n";
        value.map((element) => {
          const currentParents = [
            ...parents,
            exports2.ArraySymbol
          ];
          arrayString += "	".repeat(currentParents.length) + checkQuotes(currentParents, element) + ",\n";
        });
        return arrayString + `${"	".repeat(parents.length)}]`;
      }
      if (!isRecord(value)) {
        return typeof value === "number" || typeof value === "boolean" || !value ? String(value) : `"${String(value)}"`;
      }
      const objectString = Object.keys(value).map((key) => {
        const currentParents = [
          ...parents,
          key
        ];
        const prefix = "	".repeat(currentParents.length);
        return `${prefix}${key}: ${checkQuotes(currentParents, value[key])}`;
      }).join(",\n");
      return `{
${objectString}
${"	".repeat(parents.length)}}`;
    };
    exports2.stringify = stringify;
    var checkQuotes = (parents, value) => {
      if (value && typeof value === "object" && exports2.UnquotedSymbol in value) {
        return value[exports2.UnquotedSymbol];
      }
      return (0, exports2.stringify)(value, parents);
    };
    var resizeFirstChar = (text, capitalize) => {
      if (capitalize === true) {
        return text.charAt(0).toUpperCase() + text.slice(1);
      }
      return text.charAt(0).toLowerCase() + text.slice(1);
    };
    exports2.resizeFirstChar = resizeFirstChar;
    var getCollectionId = (name) => (0, exports2.resizeFirstChar)(name, false);
    exports2.getCollectionId = getCollectionId;
    var getExtendName = (name) => `extend${(0, exports2.resizeFirstChar)(name, true)}Collection`;
    exports2.getExtendName = getExtendName;
  }
});

// ../../../sonata-api/packages/compiler/dist/codegen/generateJSCollections.js
var require_generateJSCollections = __commonJS({
  "../../../sonata-api/packages/compiler/dist/codegen/generateJSCollections.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.generateJSCollections = void 0;
    var utils_js_1 = require_utils();
    var initialImportedFunctions = [
      "extendCollection",
      "defineCollection"
    ];
    var generateJSCollections = (ast) => {
      let javascriptCode = "";
      const importsResult = (0, utils_js_1.makeASTImports)(ast.collections, {
        [utils_js_1.PACKAGE_NAME]: new Set(initialImportedFunctions)
      }, {
        includeRuntimeOnlyImports: true
      });
      javascriptCode += importsResult.code.join("\n") + "\n\n";
      javascriptCode += makeJSCollections(ast, importsResult.modifiedSymbols) + "\n\n";
      return javascriptCode;
    };
    exports2.generateJSCollections = generateJSCollections;
    var makeJSCollections = (ast, modifiedSymbols) => {
      const collectionCodes = {};
      for (const collectionNode of ast.collections) {
        const id = (0, utils_js_1.getCollectionId)(collectionNode.name);
        const extendCollectionName = (0, utils_js_1.getExtendName)(collectionNode.name);
        const collectionDefinition = `export const ${id} = ${collectionNode.extends ? `extendCollection(${id in modifiedSymbols ? modifiedSymbols[id] : id}, ${makeJSCollectionSchema(ast, collectionNode, id)})` : `defineCollection(${makeJSCollectionSchema(ast, collectionNode, id)})`}`;
        const collectionDeclaration = `export const ${extendCollectionName} = (collection) => extendCollection(${id}, collection)`;
        collectionCodes[collectionNode.name] = [
          "//" + collectionNode.name,
          collectionDefinition,
          collectionDeclaration
        ].join("\n");
      }
      return Object.values(collectionCodes).join("\n\n");
    };
    var makeJSCollectionSchema = (ast, collectionNode, collectionId) => {
      const collectionSchema = {
        item: {},
        description: {
          $id: collectionId,
          properties: {}
        }
      };
      for (const key of Object.keys(collectionNode)) {
        if (collectionNode[key] === void 0) {
          continue;
        }
        switch (key) {
          case "properties":
            collectionSchema.description[key] = (0, utils_js_1.recursivelyUnwrapPropertyNodes)(collectionNode[key]);
            break;
          case "owned":
            collectionSchema.description[key] = collectionNode[key];
            break;
          case "middlewares":
            collectionSchema.middlewares = {
              [utils_js_1.UnquotedSymbol]: `[ ${collectionNode[key].join(", ")} ]`
            };
            break;
          case "functions":
            collectionSchema.functions = {
              [utils_js_1.UnquotedSymbol]: `{ ${makeJSFunctions(collectionNode[key])} }`
            };
            collectionSchema.exposedFunctions = (0, utils_js_1.getExposedFunctions)(collectionNode[key]);
            break;
          case "required":
            collectionSchema.description[key] = collectionNode[key];
            break;
          case "table":
          case "filters":
          case "indexes":
          case "form":
            collectionSchema.description[key] = collectionNode[key];
            break;
          case "actions":
          case "individualActions":
            collectionSchema.description[key] = collectionNode[key];
            break;
          case "icon":
            collectionSchema.description[key] = collectionNode[key];
            break;
          case "presets":
            collectionSchema.description[key] = collectionNode[key];
            break;
          case "search":
            collectionSchema.description[key] = collectionNode[key];
            break;
          case "layout":
            collectionSchema.description[key] = (0, utils_js_1.unwrapNode)(collectionNode[key]);
            break;
          case "formLayout":
            collectionSchema.description[key] = (0, utils_js_1.unwrapNode)(collectionNode[key]);
            break;
        }
      }
      return (0, utils_js_1.stringify)(collectionSchema);
    };
    var makeJSFunctions = (functions) => {
      return Object.entries(functions).map(([key, _value]) => utils_js_1.DEFAULT_FUNCTIONS.includes(key) ? key : `${key}: () => { throw new Error('Function not implemented') }`).join(", ");
    };
  }
});

// ../../../sonata-api/packages/compiler/dist/codegen/generateTSCollections.js
var require_generateTSCollections = __commonJS({
  "../../../sonata-api/packages/compiler/dist/codegen/generateTSCollections.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.generateTSCollections = void 0;
    var utils_js_1 = require_utils();
    var initialImportedTypes = [
      "Collection",
      "SchemaWithId",
      "ExtendCollection",
      "Context"
    ];
    var generateTSCollections = (ast) => {
      let code = "";
      code += `import type { ${initialImportedTypes.join(", ")} } from '${utils_js_1.PACKAGE_NAME}'
`;
      const importsResult = (0, utils_js_1.makeASTImports)(ast.collections);
      code += importsResult.code.join("\n") + "\n\n";
      code += makeTSCollections(ast, importsResult.modifiedSymbols) + "\n";
      return code;
    };
    exports2.generateTSCollections = generateTSCollections;
    var makeTSCollections = (ast, modifiedSymbols) => {
      const collectionCodes = {};
      for (const collectionNode of ast.collections) {
        const id = (0, utils_js_1.getCollectionId)(collectionNode.name);
        const schemaName = (0, utils_js_1.resizeFirstChar)(collectionNode.name, true);
        const typeName = id + "Collection";
        const collectionType = `export declare type ${typeName} = ${id in modifiedSymbols ? `ExtendCollection<typeof ${modifiedSymbols[id]}, ${makeTSCollectionSchema(collectionNode, id)}>` : makeTSCollectionSchema(collectionNode, id)}`;
        const collectionDeclaration = `export declare const ${id}: ${typeName} & { item: SchemaWithId<${typeName}["description"]> }`;
        const collectionSchema = `export declare type ${schemaName} = SchemaWithId<typeof ${id}.description>`;
        const collectionExtend = `export declare const extend${schemaName}Collection: <
            const TCollection extends {
              [P in Exclude<keyof Collection, "functions">]?: Partial<Collection[P]>
            } & {
              functions?: {
                [F: string]: (payload: any, context: Context<typeof ${id}["description"]>) => unknown
              }
            }>(collection: TCollection) => ExtendCollection<typeof ${id}, TCollection>`;
        collectionCodes[collectionNode.name] = [
          "//" + collectionNode.name,
          collectionType,
          collectionDeclaration,
          collectionSchema,
          collectionExtend
        ].join("\n");
      }
      return Object.values(collectionCodes).join("\n\n");
    };
    var makeTSCollectionSchema = (collectionNode, collectionId) => {
      const collectionSchema = {
        item: {},
        description: {
          $id: collectionId,
          properties: {}
        }
      };
      for (const key of Object.keys(collectionNode)) {
        if (collectionNode[key] === void 0) {
          continue;
        }
        switch (key) {
          case "properties":
            collectionSchema.description.properties = (0, utils_js_1.recursivelyUnwrapPropertyNodes)(collectionNode[key]);
            break;
          case "owned":
            collectionSchema.description.owned = collectionNode[key];
            break;
          case "middlewares":
            collectionSchema.middlewares = {
              [utils_js_1.UnquotedSymbol]: "import('@aeriajs/types').CollectionMiddleware<unknown>[]"
            };
            break;
          case "functions":
            collectionSchema.functions = makeTSFunctions(collectionNode[key]);
            collectionSchema.exposedFunctions = (0, utils_js_1.getExposedFunctions)(collectionNode[key]);
            break;
          case "required":
            collectionSchema.description[key] = collectionNode[key];
            break;
          case "table":
          case "filters":
          case "indexes":
          case "form":
            collectionSchema.description[key] = collectionNode[key];
            break;
          case "actions":
          case "individualActions":
            collectionSchema.description[key] = collectionNode[key];
            break;
          case "icon":
            collectionSchema.description[key] = collectionNode[key];
            break;
          case "presets":
            collectionSchema.description[key] = collectionNode[key];
            break;
          case "search":
            collectionSchema.description[key] = collectionNode[key];
            break;
          case "layout":
            collectionSchema.description[key] = (0, utils_js_1.unwrapNode)(collectionNode[key]);
            break;
          case "formLayout":
            collectionSchema.description[key] = (0, utils_js_1.unwrapNode)(collectionNode[key]);
            break;
        }
      }
      return (0, utils_js_1.stringify)(collectionSchema);
    };
    var makeTSFunctions = (functions) => {
      return Object.keys(functions).reduce((acc, key) => {
        acc[key] = {
          [utils_js_1.UnquotedSymbol]: utils_js_1.DEFAULT_FUNCTIONS.includes(key) ? `typeof ${key}` : "() => never"
        };
        return acc;
      }, {});
    };
  }
});

// ../../../sonata-api/packages/compiler/dist/codegen/generateExports.js
var require_generateExports = __commonJS({
  "../../../sonata-api/packages/compiler/dist/codegen/generateExports.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.generateExports = void 0;
    var utils_js_1 = require_utils();
    var generateExports = (ast, options = {
      hasContracts: false
    }) => {
      const symbolsToExport = Object.values(ast.collections.reduce((symbols, node) => {
        const id = (0, utils_js_1.getCollectionId)(node.name);
        symbols[id] = {
          id,
          schema: (0, utils_js_1.resizeFirstChar)(node.name, true),
          extend: (0, utils_js_1.getExtendName)(node.name)
        };
        return symbols;
      }, {}));
      const exports3 = {
        collections: {
          js: `export { ${symbolsToExport.map((symbol) => `${symbol.id}`).join(", ")} } from './collections.js'`,
          dts: `export { ${symbolsToExport.map((symbol) => `${symbol.id}`).join(", ")} } from './collections.js'`
        },
        main: {
          js: (options.hasContracts ? "export * as contracts from './contracts/index.js'\n" : "") + `export * as collections from './collections/index.js'
export { ${symbolsToExport.map((symbol) => symbol.extend).join(", ")} } from './collections/collections.js'`,
          dts: (options.hasContracts ? "export * as contracts from './contracts/index.js'\n" : "") + `export * as collections from './collections/index.js'
export { ${symbolsToExport.map((symbol) => `${symbol.extend}, ${symbol.schema}`).join(", ")} } from './collections/collections.js'`
        }
      };
      if (options.hasContracts) {
        exports3.contracts = {
          js: "export * from './contracts.js'",
          dts: "export * from './contracts.js'"
        };
      }
      return exports3;
    };
    exports2.generateExports = generateExports;
  }
});

// ../../../sonata-api/packages/compiler/dist/codegen/generateContracts.js
var require_generateContracts = __commonJS({
  "../../../sonata-api/packages/compiler/dist/codegen/generateContracts.js"(exports2) {
    "use strict";
    init_importMeta();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.generateContracts = void 0;
    var types_1 = require_dist();
    var utils_js_1 = require_utils();
    var generateContracts = (ast) => {
      if (ast.contracts.length === 0) {
        return false;
      }
      return {
        js: makeJSContractsCode(ast),
        dts: makeTSContractsCode(ast)
      };
    };
    exports2.generateContracts = generateContracts;
    var makeJSContractsCode = (ast) => {
      const imports = /* @__PURE__ */ new Set(["defineContract"]);
      const getCodeForResponse = (responseProperty) => {
        const { kind, modifier, ...propertyNode } = responseProperty;
        if (!modifier) {
          return (0, utils_js_1.stringify)((0, utils_js_1.unwrapPropertyNode)(propertyNode));
        }
        const modifierSymbol = responseProperty.modifier === "Result" ? "resultSchema" : "errorSchema";
        if (!imports.has(modifierSymbol)) {
          imports.add(modifierSymbol);
        }
        return `${modifierSymbol}(${(0, utils_js_1.stringify)((0, utils_js_1.unwrapPropertyNode)(propertyNode))})`;
      };
      const declarations = ast.contracts.map((node) => {
        const { name, kind, roles, response, ...contractProperty } = node;
        let responseString;
        if (response) {
          responseString = "";
          if (Array.isArray(response)) {
            const responseArray = [];
            for (const responseElement of response) {
              responseArray.push({
                [utils_js_1.UnquotedSymbol]: getCodeForResponse(responseElement)
              });
            }
            responseString = (0, utils_js_1.stringify)(responseArray);
          } else {
            responseString = (0, utils_js_1.stringify)(getCodeForResponse(response));
          }
        }
        const contractSchema = (0, utils_js_1.recursivelyUnwrapPropertyNodes)(contractProperty);
        if (responseString) {
          contractSchema.response = {
            [utils_js_1.UnquotedSymbol]: responseString
          };
        }
        if (roles) {
          contractSchema.roles = roles;
        }
        return `export const ${name} = defineContract(${(0, utils_js_1.stringify)(contractSchema)})`;
      }).join("\n\n");
      return `import { ${Array.from(imports).join(", ")} } from 'aeria'

` + declarations;
    };
    var getResponseSchema = (response) => {
      const responseSchema = (0, utils_js_1.unwrapPropertyNode)(response);
      if (!response.modifier) {
        return responseSchema;
      }
      return response.modifier === "Result" ? (0, types_1.resultSchema)(responseSchema) : (0, types_1.errorSchema)(responseSchema);
    };
    var makeTSContractsCode = (ast) => {
      return ast.contracts.map((node) => {
        const { name, kind, roles, ...contractSchema } = node;
        let responseSchema = null;
        if (contractSchema.response) {
          if (Array.isArray(contractSchema.response)) {
            responseSchema = contractSchema.response.map(getResponseSchema);
          } else {
            responseSchema = getResponseSchema(contractSchema.response);
          }
        }
        const contractProperties = (0, utils_js_1.recursivelyUnwrapPropertyNodes)(contractSchema);
        if (responseSchema) {
          contractProperties.response = responseSchema;
        }
        if (roles) {
          contractProperties.roles = roles;
        }
        return `export declare const ${node.name}: ${(0, utils_js_1.stringify)(contractProperties)}`;
      }).join("\n\n");
    };
  }
});

// ../../../sonata-api/packages/compiler/dist/codegen/index.js
var require_codegen = __commonJS({
  "../../../sonata-api/packages/compiler/dist/codegen/index.js"(exports2) {
    "use strict";
    init_importMeta();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_generateJSCollections(), exports2);
    __exportStar(require_generateTSCollections(), exports2);
    __exportStar(require_generateExports(), exports2);
    __exportStar(require_generateContracts(), exports2);
  }
});

// ../../../sonata-api/packages/compiler/dist/codegen.js
var require_codegen2 = __commonJS({
  "../../../sonata-api/packages/compiler/dist/codegen.js"(exports2) {
    "use strict";
    init_importMeta();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || /* @__PURE__ */ function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.generateCode = void 0;
    var index_js_1 = require_codegen();
    var fsPromises = __importStar(require("node:fs/promises"));
    var path2 = __importStar(require("node:path"));
    var generateFileMap = async (fileTree, outDir = ".") => {
      const mappedPaths = {};
      const mapPathTree = async (tree, previousPath) => {
        for (const treePath in tree) {
          const currentPath = path2.join(previousPath, treePath);
          if (typeof tree[treePath] === "object") {
            await mapPathTree(tree[treePath], currentPath);
            continue;
          }
          await fsPromises.mkdir(previousPath, {
            recursive: true
          });
          mappedPaths[currentPath] = tree[treePath];
        }
        return;
      };
      await mapPathTree(fileTree, outDir);
      return mappedPaths;
    };
    var generateCode = async (ast, options) => {
      const contracts = (0, index_js_1.generateContracts)(ast);
      const exports3 = (0, index_js_1.generateExports)(ast, {
        hasContracts: !!contracts
      });
      const fileTree = {
        ["collections"]: {
          ["collections.d.ts"]: (0, index_js_1.generateTSCollections)(ast),
          ["collections.js"]: (0, index_js_1.generateJSCollections)(ast),
          ["index.d.ts"]: exports3.collections.dts,
          ["index.js"]: exports3.collections.js
        },
        ["index.d.ts"]: exports3.main.dts,
        ["index.js"]: exports3.main.js
      };
      if (contracts) {
        fileTree.contracts = {
          ["contracts.js"]: contracts.js,
          ["contracts.d.ts"]: contracts.dts,
          ["index.d.ts"]: exports3.contracts.dts,
          ["index.js"]: exports3.contracts.js
        };
      }
      const fileStructure = await generateFileMap(fileTree, options.outDir);
      if (!options.dryRun) {
        for (const path3 in fileStructure) {
          await fsPromises.writeFile(path3, fileStructure[path3]);
        }
      }
      return fileStructure;
    };
    exports2.generateCode = generateCode;
  }
});

// ../../../sonata-api/packages/compiler/dist/compile.js
var require_compile = __commonJS({
  "../../../sonata-api/packages/compiler/dist/compile.js"(exports2) {
    "use strict";
    init_importMeta();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || /* @__PURE__ */ function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.compileFromFiles = exports2.parseAndCheck = exports2.postflight = exports2.GLOB_PATTERN = void 0;
    var diagnostic_js_1 = require_diagnostic2();
    var lexer_js_1 = require_lexer();
    var parser_js_1 = require_parser();
    var semantic_js_1 = require_semantic();
    var codegen_js_1 = require_codegen2();
    var fs = __importStar(require("node:fs"));
    exports2.GLOB_PATTERN = "**/*.aeria";
    var postflight = (ast) => {
      const errors = [];
      for (const node of ast.collections) {
        if (node.functionSets?.length) {
          for (const [functionSetName, locationSymbol] of node.functionSets) {
            const functionSet = ast.functionsets.find(({ name }) => name === functionSetName);
            if (!functionSet) {
              const location = parser_js_1.locationMap.get(locationSymbol);
              errors.push(new diagnostic_js_1.Diagnostic(`invalid function set "${functionSetName}"`, location));
              continue;
            }
            Object.assign(node.functions, functionSet.functions);
          }
        }
      }
      return {
        errors
      };
    };
    exports2.postflight = postflight;
    var parseAndCheck = async (sources, options = {}) => {
      const errors = [];
      const allTokens = [];
      for (const fileName in sources) {
        const { errors: lexerErrors, tokens } = (0, lexer_js_1.tokenize)(sources[fileName], fileName);
        if (lexerErrors.length > 0) {
          errors.push(...lexerErrors);
        }
        allTokens.push(...tokens);
      }
      const { errors: parserErrors, ast } = (0, parser_js_1.parse)(allTokens);
      const { errors: semanticErrors } = await (0, semantic_js_1.analyze)(ast, options);
      const { errors: postflightErrors } = (0, exports2.postflight)(ast);
      errors.push(...parserErrors.concat(semanticErrors, postflightErrors));
      return {
        success: errors.length === 0,
        errors,
        errorCount: errors.length,
        ast
      };
    };
    exports2.parseAndCheck = parseAndCheck;
    var compileFromFiles = async (options) => {
      const fileList = await Array.fromAsync(fs.promises.glob(exports2.GLOB_PATTERN));
      const sources = {};
      for (const fileName of fileList) {
        sources[fileName] = await fs.promises.readFile(fileName, {
          encoding: "utf-8"
        });
      }
      const result = await (0, exports2.parseAndCheck)(sources, options);
      if (!result.ast || result.errorCount > 0) {
        return result;
      }
      if (options.outDir) {
        const emittedFiles = await (0, codegen_js_1.generateCode)(result.ast, options);
        return {
          ...result,
          emittedFiles
        };
      }
      return result;
    };
    exports2.compileFromFiles = compileFromFiles;
  }
});

// ../../../sonata-api/packages/compiler/dist/index.js
var require_dist3 = __commonJS({
  "../../../sonata-api/packages/compiler/dist/index.js"(exports2) {
    "use strict";
    init_importMeta();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_ast(), exports2);
    __exportStar(require_compile(), exports2);
    __exportStar(require_parser(), exports2);
    __exportStar(require_lexer(), exports2);
    __exportStar(require_semantic(), exports2);
    __exportStar(require_token(), exports2);
    __exportStar(require_diagnostic2(), exports2);
  }
});

// src/index.ts
init_importMeta();
var import_node = __toESM(require_node3());

// ../../node_modules/.pnpm/vscode-languageserver-textdocument@1.0.12/node_modules/vscode-languageserver-textdocument/lib/esm/main.js
init_importMeta();
var FullTextDocument = class _FullTextDocument {
  constructor(uri, languageId, version, content) {
    this._uri = uri;
    this._languageId = languageId;
    this._version = version;
    this._content = content;
    this._lineOffsets = void 0;
  }
  get uri() {
    return this._uri;
  }
  get languageId() {
    return this._languageId;
  }
  get version() {
    return this._version;
  }
  getText(range) {
    if (range) {
      const start = this.offsetAt(range.start);
      const end = this.offsetAt(range.end);
      return this._content.substring(start, end);
    }
    return this._content;
  }
  update(changes, version) {
    for (const change of changes) {
      if (_FullTextDocument.isIncremental(change)) {
        const range = getWellformedRange(change.range);
        const startOffset = this.offsetAt(range.start);
        const endOffset = this.offsetAt(range.end);
        this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);
        const startLine = Math.max(range.start.line, 0);
        const endLine = Math.max(range.end.line, 0);
        let lineOffsets = this._lineOffsets;
        const addedLineOffsets = computeLineOffsets(change.text, false, startOffset);
        if (endLine - startLine === addedLineOffsets.length) {
          for (let i = 0, len = addedLineOffsets.length; i < len; i++) {
            lineOffsets[i + startLine + 1] = addedLineOffsets[i];
          }
        } else {
          if (addedLineOffsets.length < 1e4) {
            lineOffsets.splice(startLine + 1, endLine - startLine, ...addedLineOffsets);
          } else {
            this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));
          }
        }
        const diff = change.text.length - (endOffset - startOffset);
        if (diff !== 0) {
          for (let i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {
            lineOffsets[i] = lineOffsets[i] + diff;
          }
        }
      } else if (_FullTextDocument.isFull(change)) {
        this._content = change.text;
        this._lineOffsets = void 0;
      } else {
        throw new Error("Unknown change event received");
      }
    }
    this._version = version;
  }
  getLineOffsets() {
    if (this._lineOffsets === void 0) {
      this._lineOffsets = computeLineOffsets(this._content, true);
    }
    return this._lineOffsets;
  }
  positionAt(offset) {
    offset = Math.max(Math.min(offset, this._content.length), 0);
    const lineOffsets = this.getLineOffsets();
    let low = 0, high = lineOffsets.length;
    if (high === 0) {
      return { line: 0, character: offset };
    }
    while (low < high) {
      const mid = Math.floor((low + high) / 2);
      if (lineOffsets[mid] > offset) {
        high = mid;
      } else {
        low = mid + 1;
      }
    }
    const line = low - 1;
    offset = this.ensureBeforeEOL(offset, lineOffsets[line]);
    return { line, character: offset - lineOffsets[line] };
  }
  offsetAt(position) {
    const lineOffsets = this.getLineOffsets();
    if (position.line >= lineOffsets.length) {
      return this._content.length;
    } else if (position.line < 0) {
      return 0;
    }
    const lineOffset = lineOffsets[position.line];
    if (position.character <= 0) {
      return lineOffset;
    }
    const nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
    const offset = Math.min(lineOffset + position.character, nextLineOffset);
    return this.ensureBeforeEOL(offset, lineOffset);
  }
  ensureBeforeEOL(offset, lineOffset) {
    while (offset > lineOffset && isEOL(this._content.charCodeAt(offset - 1))) {
      offset--;
    }
    return offset;
  }
  get lineCount() {
    return this.getLineOffsets().length;
  }
  static isIncremental(event) {
    const candidate = event;
    return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
  }
  static isFull(event) {
    const candidate = event;
    return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
  }
};
var TextDocument;
(function(TextDocument2) {
  function create(uri, languageId, version, content) {
    return new FullTextDocument(uri, languageId, version, content);
  }
  TextDocument2.create = create;
  function update(document, changes, version) {
    if (document instanceof FullTextDocument) {
      document.update(changes, version);
      return document;
    } else {
      throw new Error("TextDocument.update: document must be created by TextDocument.create");
    }
  }
  TextDocument2.update = update;
  function applyEdits(document, edits) {
    const text = document.getText();
    const sortedEdits = mergeSort(edits.map(getWellformedEdit), (a, b) => {
      const diff = a.range.start.line - b.range.start.line;
      if (diff === 0) {
        return a.range.start.character - b.range.start.character;
      }
      return diff;
    });
    let lastModifiedOffset = 0;
    const spans = [];
    for (const e of sortedEdits) {
      const startOffset = document.offsetAt(e.range.start);
      if (startOffset < lastModifiedOffset) {
        throw new Error("Overlapping edit");
      } else if (startOffset > lastModifiedOffset) {
        spans.push(text.substring(lastModifiedOffset, startOffset));
      }
      if (e.newText.length) {
        spans.push(e.newText);
      }
      lastModifiedOffset = document.offsetAt(e.range.end);
    }
    spans.push(text.substr(lastModifiedOffset));
    return spans.join("");
  }
  TextDocument2.applyEdits = applyEdits;
})(TextDocument || (TextDocument = {}));
function mergeSort(data, compare) {
  if (data.length <= 1) {
    return data;
  }
  const p = data.length / 2 | 0;
  const left = data.slice(0, p);
  const right = data.slice(p);
  mergeSort(left, compare);
  mergeSort(right, compare);
  let leftIdx = 0;
  let rightIdx = 0;
  let i = 0;
  while (leftIdx < left.length && rightIdx < right.length) {
    const ret = compare(left[leftIdx], right[rightIdx]);
    if (ret <= 0) {
      data[i++] = left[leftIdx++];
    } else {
      data[i++] = right[rightIdx++];
    }
  }
  while (leftIdx < left.length) {
    data[i++] = left[leftIdx++];
  }
  while (rightIdx < right.length) {
    data[i++] = right[rightIdx++];
  }
  return data;
}
function computeLineOffsets(text, isAtLineStart, textOffset = 0) {
  const result = isAtLineStart ? [textOffset] : [];
  for (let i = 0; i < text.length; i++) {
    const ch = text.charCodeAt(i);
    if (isEOL(ch)) {
      if (ch === 13 && i + 1 < text.length && text.charCodeAt(i + 1) === 10) {
        i++;
      }
      result.push(textOffset + i + 1);
    }
  }
  return result;
}
function isEOL(char) {
  return char === 13 || char === 10;
}
function getWellformedRange(range) {
  const start = range.start;
  const end = range.end;
  if (start.line > end.line || start.line === end.line && start.character > end.character) {
    return { start: end, end: start };
  }
  return range;
}
function getWellformedEdit(textEdit) {
  const range = getWellformedRange(textEdit.range);
  if (range !== textEdit.range) {
    return { newText: textEdit.newText, range };
  }
  return textEdit;
}

// src/lib.ts
init_importMeta();
var import_node_url3 = require("node:url");
var import_promises2 = require("node:fs/promises");

// ../../node_modules/.pnpm/glob@11.0.2/node_modules/glob/dist/esm/index.js
init_importMeta();

// ../../node_modules/.pnpm/minimatch@10.0.1/node_modules/minimatch/dist/esm/index.js
init_importMeta();
var import_brace_expansion = __toESM(require_brace_expansion(), 1);

// ../../node_modules/.pnpm/minimatch@10.0.1/node_modules/minimatch/dist/esm/assert-valid-pattern.js
init_importMeta();
var MAX_PATTERN_LENGTH = 1024 * 64;
var assertValidPattern = (pattern) => {
  if (typeof pattern !== "string") {
    throw new TypeError("invalid pattern");
  }
  if (pattern.length > MAX_PATTERN_LENGTH) {
    throw new TypeError("pattern is too long");
  }
};

// ../../node_modules/.pnpm/minimatch@10.0.1/node_modules/minimatch/dist/esm/ast.js
init_importMeta();

// ../../node_modules/.pnpm/minimatch@10.0.1/node_modules/minimatch/dist/esm/brace-expressions.js
init_importMeta();
var posixClasses = {
  "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", true],
  "[:alpha:]": ["\\p{L}\\p{Nl}", true],
  "[:ascii:]": ["\\x00-\\x7f", false],
  "[:blank:]": ["\\p{Zs}\\t", true],
  "[:cntrl:]": ["\\p{Cc}", true],
  "[:digit:]": ["\\p{Nd}", true],
  "[:graph:]": ["\\p{Z}\\p{C}", true, true],
  "[:lower:]": ["\\p{Ll}", true],
  "[:print:]": ["\\p{C}", true],
  "[:punct:]": ["\\p{P}", true],
  "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", true],
  "[:upper:]": ["\\p{Lu}", true],
  "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", true],
  "[:xdigit:]": ["A-Fa-f0-9", false]
};
var braceEscape = (s) => s.replace(/[[\]\\-]/g, "\\$&");
var regexpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var rangesToString = (ranges) => ranges.join("");
var parseClass = (glob2, position) => {
  const pos = position;
  if (glob2.charAt(pos) !== "[") {
    throw new Error("not in a brace expression");
  }
  const ranges = [];
  const negs = [];
  let i = pos + 1;
  let sawStart = false;
  let uflag = false;
  let escaping = false;
  let negate = false;
  let endPos = pos;
  let rangeStart = "";
  WHILE: while (i < glob2.length) {
    const c = glob2.charAt(i);
    if ((c === "!" || c === "^") && i === pos + 1) {
      negate = true;
      i++;
      continue;
    }
    if (c === "]" && sawStart && !escaping) {
      endPos = i + 1;
      break;
    }
    sawStart = true;
    if (c === "\\") {
      if (!escaping) {
        escaping = true;
        i++;
        continue;
      }
    }
    if (c === "[" && !escaping) {
      for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {
        if (glob2.startsWith(cls, i)) {
          if (rangeStart) {
            return ["$.", false, glob2.length - pos, true];
          }
          i += cls.length;
          if (neg)
            negs.push(unip);
          else
            ranges.push(unip);
          uflag = uflag || u;
          continue WHILE;
        }
      }
    }
    escaping = false;
    if (rangeStart) {
      if (c > rangeStart) {
        ranges.push(braceEscape(rangeStart) + "-" + braceEscape(c));
      } else if (c === rangeStart) {
        ranges.push(braceEscape(c));
      }
      rangeStart = "";
      i++;
      continue;
    }
    if (glob2.startsWith("-]", i + 1)) {
      ranges.push(braceEscape(c + "-"));
      i += 2;
      continue;
    }
    if (glob2.startsWith("-", i + 1)) {
      rangeStart = c;
      i += 2;
      continue;
    }
    ranges.push(braceEscape(c));
    i++;
  }
  if (endPos < i) {
    return ["", false, 0, false];
  }
  if (!ranges.length && !negs.length) {
    return ["$.", false, glob2.length - pos, true];
  }
  if (negs.length === 0 && ranges.length === 1 && /^\\?.$/.test(ranges[0]) && !negate) {
    const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
    return [regexpEscape(r), false, endPos - pos, false];
  }
  const sranges = "[" + (negate ? "^" : "") + rangesToString(ranges) + "]";
  const snegs = "[" + (negate ? "" : "^") + rangesToString(negs) + "]";
  const comb = ranges.length && negs.length ? "(" + sranges + "|" + snegs + ")" : ranges.length ? sranges : snegs;
  return [comb, uflag, endPos - pos, true];
};

// ../../node_modules/.pnpm/minimatch@10.0.1/node_modules/minimatch/dist/esm/unescape.js
init_importMeta();
var unescape = (s, { windowsPathsNoEscape = false } = {}) => {
  return windowsPathsNoEscape ? s.replace(/\[([^\/\\])\]/g, "$1") : s.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1");
};

// ../../node_modules/.pnpm/minimatch@10.0.1/node_modules/minimatch/dist/esm/ast.js
var types = /* @__PURE__ */ new Set(["!", "?", "+", "*", "@"]);
var isExtglobType = (c) => types.has(c);
var startNoTraversal = "(?!(?:^|/)\\.\\.?(?:$|/))";
var startNoDot = "(?!\\.)";
var addPatternStart = /* @__PURE__ */ new Set(["[", "."]);
var justDots = /* @__PURE__ */ new Set(["..", "."]);
var reSpecials = new Set("().*{}+?[]^$\\!");
var regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var qmark = "[^/]";
var star = qmark + "*?";
var starNoEmpty = qmark + "+?";
var AST = class _AST {
  type;
  #root;
  #hasMagic;
  #uflag = false;
  #parts = [];
  #parent;
  #parentIndex;
  #negs;
  #filledNegs = false;
  #options;
  #toString;
  // set to true if it's an extglob with no children
  // (which really means one child of '')
  #emptyExt = false;
  constructor(type, parent, options = {}) {
    this.type = type;
    if (type)
      this.#hasMagic = true;
    this.#parent = parent;
    this.#root = this.#parent ? this.#parent.#root : this;
    this.#options = this.#root === this ? options : this.#root.#options;
    this.#negs = this.#root === this ? [] : this.#root.#negs;
    if (type === "!" && !this.#root.#filledNegs)
      this.#negs.push(this);
    this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;
  }
  get hasMagic() {
    if (this.#hasMagic !== void 0)
      return this.#hasMagic;
    for (const p of this.#parts) {
      if (typeof p === "string")
        continue;
      if (p.type || p.hasMagic)
        return this.#hasMagic = true;
    }
    return this.#hasMagic;
  }
  // reconstructs the pattern
  toString() {
    if (this.#toString !== void 0)
      return this.#toString;
    if (!this.type) {
      return this.#toString = this.#parts.map((p) => String(p)).join("");
    } else {
      return this.#toString = this.type + "(" + this.#parts.map((p) => String(p)).join("|") + ")";
    }
  }
  #fillNegs() {
    if (this !== this.#root)
      throw new Error("should only call on root");
    if (this.#filledNegs)
      return this;
    this.toString();
    this.#filledNegs = true;
    let n;
    while (n = this.#negs.pop()) {
      if (n.type !== "!")
        continue;
      let p = n;
      let pp = p.#parent;
      while (pp) {
        for (let i = p.#parentIndex + 1; !pp.type && i < pp.#parts.length; i++) {
          for (const part of n.#parts) {
            if (typeof part === "string") {
              throw new Error("string part in extglob AST??");
            }
            part.copyIn(pp.#parts[i]);
          }
        }
        p = pp;
        pp = p.#parent;
      }
    }
    return this;
  }
  push(...parts) {
    for (const p of parts) {
      if (p === "")
        continue;
      if (typeof p !== "string" && !(p instanceof _AST && p.#parent === this)) {
        throw new Error("invalid part: " + p);
      }
      this.#parts.push(p);
    }
  }
  toJSON() {
    const ret = this.type === null ? this.#parts.slice().map((p) => typeof p === "string" ? p : p.toJSON()) : [this.type, ...this.#parts.map((p) => p.toJSON())];
    if (this.isStart() && !this.type)
      ret.unshift([]);
    if (this.isEnd() && (this === this.#root || this.#root.#filledNegs && this.#parent?.type === "!")) {
      ret.push({});
    }
    return ret;
  }
  isStart() {
    if (this.#root === this)
      return true;
    if (!this.#parent?.isStart())
      return false;
    if (this.#parentIndex === 0)
      return true;
    const p = this.#parent;
    for (let i = 0; i < this.#parentIndex; i++) {
      const pp = p.#parts[i];
      if (!(pp instanceof _AST && pp.type === "!")) {
        return false;
      }
    }
    return true;
  }
  isEnd() {
    if (this.#root === this)
      return true;
    if (this.#parent?.type === "!")
      return true;
    if (!this.#parent?.isEnd())
      return false;
    if (!this.type)
      return this.#parent?.isEnd();
    const pl = this.#parent ? this.#parent.#parts.length : 0;
    return this.#parentIndex === pl - 1;
  }
  copyIn(part) {
    if (typeof part === "string")
      this.push(part);
    else
      this.push(part.clone(this));
  }
  clone(parent) {
    const c = new _AST(this.type, parent);
    for (const p of this.#parts) {
      c.copyIn(p);
    }
    return c;
  }
  static #parseAST(str, ast, pos, opt) {
    let escaping = false;
    let inBrace = false;
    let braceStart = -1;
    let braceNeg = false;
    if (ast.type === null) {
      let i2 = pos;
      let acc2 = "";
      while (i2 < str.length) {
        const c = str.charAt(i2++);
        if (escaping || c === "\\") {
          escaping = !escaping;
          acc2 += c;
          continue;
        }
        if (inBrace) {
          if (i2 === braceStart + 1) {
            if (c === "^" || c === "!") {
              braceNeg = true;
            }
          } else if (c === "]" && !(i2 === braceStart + 2 && braceNeg)) {
            inBrace = false;
          }
          acc2 += c;
          continue;
        } else if (c === "[") {
          inBrace = true;
          braceStart = i2;
          braceNeg = false;
          acc2 += c;
          continue;
        }
        if (!opt.noext && isExtglobType(c) && str.charAt(i2) === "(") {
          ast.push(acc2);
          acc2 = "";
          const ext2 = new _AST(c, ast);
          i2 = _AST.#parseAST(str, ext2, i2, opt);
          ast.push(ext2);
          continue;
        }
        acc2 += c;
      }
      ast.push(acc2);
      return i2;
    }
    let i = pos + 1;
    let part = new _AST(null, ast);
    const parts = [];
    let acc = "";
    while (i < str.length) {
      const c = str.charAt(i++);
      if (escaping || c === "\\") {
        escaping = !escaping;
        acc += c;
        continue;
      }
      if (inBrace) {
        if (i === braceStart + 1) {
          if (c === "^" || c === "!") {
            braceNeg = true;
          }
        } else if (c === "]" && !(i === braceStart + 2 && braceNeg)) {
          inBrace = false;
        }
        acc += c;
        continue;
      } else if (c === "[") {
        inBrace = true;
        braceStart = i;
        braceNeg = false;
        acc += c;
        continue;
      }
      if (isExtglobType(c) && str.charAt(i) === "(") {
        part.push(acc);
        acc = "";
        const ext2 = new _AST(c, part);
        part.push(ext2);
        i = _AST.#parseAST(str, ext2, i, opt);
        continue;
      }
      if (c === "|") {
        part.push(acc);
        acc = "";
        parts.push(part);
        part = new _AST(null, ast);
        continue;
      }
      if (c === ")") {
        if (acc === "" && ast.#parts.length === 0) {
          ast.#emptyExt = true;
        }
        part.push(acc);
        acc = "";
        ast.push(...parts, part);
        return i;
      }
      acc += c;
    }
    ast.type = null;
    ast.#hasMagic = void 0;
    ast.#parts = [str.substring(pos - 1)];
    return i;
  }
  static fromGlob(pattern, options = {}) {
    const ast = new _AST(null, void 0, options);
    _AST.#parseAST(pattern, ast, 0, options);
    return ast;
  }
  // returns the regular expression if there's magic, or the unescaped
  // string if not.
  toMMPattern() {
    if (this !== this.#root)
      return this.#root.toMMPattern();
    const glob2 = this.toString();
    const [re, body, hasMagic2, uflag] = this.toRegExpSource();
    const anyMagic = hasMagic2 || this.#hasMagic || this.#options.nocase && !this.#options.nocaseMagicOnly && glob2.toUpperCase() !== glob2.toLowerCase();
    if (!anyMagic) {
      return body;
    }
    const flags = (this.#options.nocase ? "i" : "") + (uflag ? "u" : "");
    return Object.assign(new RegExp(`^${re}$`, flags), {
      _src: re,
      _glob: glob2
    });
  }
  get options() {
    return this.#options;
  }
  // returns the string match, the regexp source, whether there's magic
  // in the regexp (so a regular expression is required) and whether or
  // not the uflag is needed for the regular expression (for posix classes)
  // TODO: instead of injecting the start/end at this point, just return
  // the BODY of the regexp, along with the start/end portions suitable
  // for binding the start/end in either a joined full-path makeRe context
  // (where we bind to (^|/), or a standalone matchPart context (where
  // we bind to ^, and not /).  Otherwise slashes get duped!
  //
  // In part-matching mode, the start is:
  // - if not isStart: nothing
  // - if traversal possible, but not allowed: ^(?!\.\.?$)
  // - if dots allowed or not possible: ^
  // - if dots possible and not allowed: ^(?!\.)
  // end is:
  // - if not isEnd(): nothing
  // - else: $
  //
  // In full-path matching mode, we put the slash at the START of the
  // pattern, so start is:
  // - if first pattern: same as part-matching mode
  // - if not isStart(): nothing
  // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
  // - if dots allowed or not possible: /
  // - if dots possible and not allowed: /(?!\.)
  // end is:
  // - if last pattern, same as part-matching mode
  // - else nothing
  //
  // Always put the (?:$|/) on negated tails, though, because that has to be
  // there to bind the end of the negated pattern portion, and it's easier to
  // just stick it in now rather than try to inject it later in the middle of
  // the pattern.
  //
  // We can just always return the same end, and leave it up to the caller
  // to know whether it's going to be used joined or in parts.
  // And, if the start is adjusted slightly, can do the same there:
  // - if not isStart: nothing
  // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
  // - if dots allowed or not possible: (?:/|^)
  // - if dots possible and not allowed: (?:/|^)(?!\.)
  //
  // But it's better to have a simpler binding without a conditional, for
  // performance, so probably better to return both start options.
  //
  // Then the caller just ignores the end if it's not the first pattern,
  // and the start always gets applied.
  //
  // But that's always going to be $ if it's the ending pattern, or nothing,
  // so the caller can just attach $ at the end of the pattern when building.
  //
  // So the todo is:
  // - better detect what kind of start is needed
  // - return both flavors of starting pattern
  // - attach $ at the end of the pattern when creating the actual RegExp
  //
  // Ah, but wait, no, that all only applies to the root when the first pattern
  // is not an extglob. If the first pattern IS an extglob, then we need all
  // that dot prevention biz to live in the extglob portions, because eg
  // +(*|.x*) can match .xy but not .yx.
  //
  // So, return the two flavors if it's #root and the first child is not an
  // AST, otherwise leave it to the child AST to handle it, and there,
  // use the (?:^|/) style of start binding.
  //
  // Even simplified further:
  // - Since the start for a join is eg /(?!\.) and the start for a part
  // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
  // or start or whatever) and prepend ^ or / at the Regexp construction.
  toRegExpSource(allowDot) {
    const dot = allowDot ?? !!this.#options.dot;
    if (this.#root === this)
      this.#fillNegs();
    if (!this.type) {
      const noEmpty = this.isStart() && this.isEnd();
      const src = this.#parts.map((p) => {
        const [re, _, hasMagic2, uflag] = typeof p === "string" ? _AST.#parseGlob(p, this.#hasMagic, noEmpty) : p.toRegExpSource(allowDot);
        this.#hasMagic = this.#hasMagic || hasMagic2;
        this.#uflag = this.#uflag || uflag;
        return re;
      }).join("");
      let start2 = "";
      if (this.isStart()) {
        if (typeof this.#parts[0] === "string") {
          const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);
          if (!dotTravAllowed) {
            const aps = addPatternStart;
            const needNoTrav = (
              // dots are allowed, and the pattern starts with [ or .
              dot && aps.has(src.charAt(0)) || // the pattern starts with \., and then [ or .
              src.startsWith("\\.") && aps.has(src.charAt(2)) || // the pattern starts with \.\., and then [ or .
              src.startsWith("\\.\\.") && aps.has(src.charAt(4))
            );
            const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
            start2 = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : "";
          }
        }
      }
      let end = "";
      if (this.isEnd() && this.#root.#filledNegs && this.#parent?.type === "!") {
        end = "(?:$|\\/)";
      }
      const final2 = start2 + src + end;
      return [
        final2,
        unescape(src),
        this.#hasMagic = !!this.#hasMagic,
        this.#uflag
      ];
    }
    const repeated = this.type === "*" || this.type === "+";
    const start = this.type === "!" ? "(?:(?!(?:" : "(?:";
    let body = this.#partsToRegExp(dot);
    if (this.isStart() && this.isEnd() && !body && this.type !== "!") {
      const s = this.toString();
      this.#parts = [s];
      this.type = null;
      this.#hasMagic = void 0;
      return [s, unescape(this.toString()), false, false];
    }
    let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot ? "" : this.#partsToRegExp(true);
    if (bodyDotAllowed === body) {
      bodyDotAllowed = "";
    }
    if (bodyDotAllowed) {
      body = `(?:${body})(?:${bodyDotAllowed})*?`;
    }
    let final = "";
    if (this.type === "!" && this.#emptyExt) {
      final = (this.isStart() && !dot ? startNoDot : "") + starNoEmpty;
    } else {
      const close = this.type === "!" ? (
        // !() must match something,but !(x) can match ''
        "))" + (this.isStart() && !dot && !allowDot ? startNoDot : "") + star + ")"
      ) : this.type === "@" ? ")" : this.type === "?" ? ")?" : this.type === "+" && bodyDotAllowed ? ")" : this.type === "*" && bodyDotAllowed ? `)?` : `)${this.type}`;
      final = start + body + close;
    }
    return [
      final,
      unescape(body),
      this.#hasMagic = !!this.#hasMagic,
      this.#uflag
    ];
  }
  #partsToRegExp(dot) {
    return this.#parts.map((p) => {
      if (typeof p === "string") {
        throw new Error("string type in extglob ast??");
      }
      const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);
      this.#uflag = this.#uflag || uflag;
      return re;
    }).filter((p) => !(this.isStart() && this.isEnd()) || !!p).join("|");
  }
  static #parseGlob(glob2, hasMagic2, noEmpty = false) {
    let escaping = false;
    let re = "";
    let uflag = false;
    for (let i = 0; i < glob2.length; i++) {
      const c = glob2.charAt(i);
      if (escaping) {
        escaping = false;
        re += (reSpecials.has(c) ? "\\" : "") + c;
        continue;
      }
      if (c === "\\") {
        if (i === glob2.length - 1) {
          re += "\\\\";
        } else {
          escaping = true;
        }
        continue;
      }
      if (c === "[") {
        const [src, needUflag, consumed, magic] = parseClass(glob2, i);
        if (consumed) {
          re += src;
          uflag = uflag || needUflag;
          i += consumed - 1;
          hasMagic2 = hasMagic2 || magic;
          continue;
        }
      }
      if (c === "*") {
        if (noEmpty && glob2 === "*")
          re += starNoEmpty;
        else
          re += star;
        hasMagic2 = true;
        continue;
      }
      if (c === "?") {
        re += qmark;
        hasMagic2 = true;
        continue;
      }
      re += regExpEscape(c);
    }
    return [re, unescape(glob2), !!hasMagic2, uflag];
  }
};

// ../../node_modules/.pnpm/minimatch@10.0.1/node_modules/minimatch/dist/esm/escape.js
init_importMeta();
var escape = (s, { windowsPathsNoEscape = false } = {}) => {
  return windowsPathsNoEscape ? s.replace(/[?*()[\]]/g, "[$&]") : s.replace(/[?*()[\]\\]/g, "\\$&");
};

// ../../node_modules/.pnpm/minimatch@10.0.1/node_modules/minimatch/dist/esm/index.js
var minimatch = (p, pattern, options = {}) => {
  assertValidPattern(pattern);
  if (!options.nocomment && pattern.charAt(0) === "#") {
    return false;
  }
  return new Minimatch(pattern, options).match(p);
};
var starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
var starDotExtTest = (ext2) => (f) => !f.startsWith(".") && f.endsWith(ext2);
var starDotExtTestDot = (ext2) => (f) => f.endsWith(ext2);
var starDotExtTestNocase = (ext2) => {
  ext2 = ext2.toLowerCase();
  return (f) => !f.startsWith(".") && f.toLowerCase().endsWith(ext2);
};
var starDotExtTestNocaseDot = (ext2) => {
  ext2 = ext2.toLowerCase();
  return (f) => f.toLowerCase().endsWith(ext2);
};
var starDotStarRE = /^\*+\.\*+$/;
var starDotStarTest = (f) => !f.startsWith(".") && f.includes(".");
var starDotStarTestDot = (f) => f !== "." && f !== ".." && f.includes(".");
var dotStarRE = /^\.\*+$/;
var dotStarTest = (f) => f !== "." && f !== ".." && f.startsWith(".");
var starRE = /^\*+$/;
var starTest = (f) => f.length !== 0 && !f.startsWith(".");
var starTestDot = (f) => f.length !== 0 && f !== "." && f !== "..";
var qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
var qmarksTestNocase = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExt([$0]);
  if (!ext2)
    return noext;
  ext2 = ext2.toLowerCase();
  return (f) => noext(f) && f.toLowerCase().endsWith(ext2);
};
var qmarksTestNocaseDot = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExtDot([$0]);
  if (!ext2)
    return noext;
  ext2 = ext2.toLowerCase();
  return (f) => noext(f) && f.toLowerCase().endsWith(ext2);
};
var qmarksTestDot = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExtDot([$0]);
  return !ext2 ? noext : (f) => noext(f) && f.endsWith(ext2);
};
var qmarksTest = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExt([$0]);
  return !ext2 ? noext : (f) => noext(f) && f.endsWith(ext2);
};
var qmarksTestNoExt = ([$0]) => {
  const len = $0.length;
  return (f) => f.length === len && !f.startsWith(".");
};
var qmarksTestNoExtDot = ([$0]) => {
  const len = $0.length;
  return (f) => f.length === len && f !== "." && f !== "..";
};
var defaultPlatform = typeof process === "object" && process ? typeof process.env === "object" && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : "posix";
var path = {
  win32: { sep: "\\" },
  posix: { sep: "/" }
};
var sep = defaultPlatform === "win32" ? path.win32.sep : path.posix.sep;
minimatch.sep = sep;
var GLOBSTAR = Symbol("globstar **");
minimatch.GLOBSTAR = GLOBSTAR;
var qmark2 = "[^/]";
var star2 = qmark2 + "*?";
var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
var filter = (pattern, options = {}) => (p) => minimatch(p, pattern, options);
minimatch.filter = filter;
var ext = (a, b = {}) => Object.assign({}, a, b);
var defaults = (def) => {
  if (!def || typeof def !== "object" || !Object.keys(def).length) {
    return minimatch;
  }
  const orig = minimatch;
  const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));
  return Object.assign(m, {
    Minimatch: class Minimatch extends orig.Minimatch {
      constructor(pattern, options = {}) {
        super(pattern, ext(def, options));
      }
      static defaults(options) {
        return orig.defaults(ext(def, options)).Minimatch;
      }
    },
    AST: class AST extends orig.AST {
      /* c8 ignore start */
      constructor(type, parent, options = {}) {
        super(type, parent, ext(def, options));
      }
      /* c8 ignore stop */
      static fromGlob(pattern, options = {}) {
        return orig.AST.fromGlob(pattern, ext(def, options));
      }
    },
    unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),
    escape: (s, options = {}) => orig.escape(s, ext(def, options)),
    filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),
    defaults: (options) => orig.defaults(ext(def, options)),
    makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),
    braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),
    match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),
    sep: orig.sep,
    GLOBSTAR
  });
};
minimatch.defaults = defaults;
var braceExpand = (pattern, options = {}) => {
  assertValidPattern(pattern);
  if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
    return [pattern];
  }
  return (0, import_brace_expansion.default)(pattern);
};
minimatch.braceExpand = braceExpand;
var makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();
minimatch.makeRe = makeRe;
var match = (list, pattern, options = {}) => {
  const mm = new Minimatch(pattern, options);
  list = list.filter((f) => mm.match(f));
  if (mm.options.nonull && !list.length) {
    list.push(pattern);
  }
  return list;
};
minimatch.match = match;
var globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
var regExpEscape2 = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var Minimatch = class {
  options;
  set;
  pattern;
  windowsPathsNoEscape;
  nonegate;
  negate;
  comment;
  empty;
  preserveMultipleSlashes;
  partial;
  globSet;
  globParts;
  nocase;
  isWindows;
  platform;
  windowsNoMagicRoot;
  regexp;
  constructor(pattern, options = {}) {
    assertValidPattern(pattern);
    options = options || {};
    this.options = options;
    this.pattern = pattern;
    this.platform = options.platform || defaultPlatform;
    this.isWindows = this.platform === "win32";
    this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
    if (this.windowsPathsNoEscape) {
      this.pattern = this.pattern.replace(/\\/g, "/");
    }
    this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;
    this.regexp = null;
    this.negate = false;
    this.nonegate = !!options.nonegate;
    this.comment = false;
    this.empty = false;
    this.partial = !!options.partial;
    this.nocase = !!this.options.nocase;
    this.windowsNoMagicRoot = options.windowsNoMagicRoot !== void 0 ? options.windowsNoMagicRoot : !!(this.isWindows && this.nocase);
    this.globSet = [];
    this.globParts = [];
    this.set = [];
    this.make();
  }
  hasMagic() {
    if (this.options.magicalBraces && this.set.length > 1) {
      return true;
    }
    for (const pattern of this.set) {
      for (const part of pattern) {
        if (typeof part !== "string")
          return true;
      }
    }
    return false;
  }
  debug(..._) {
  }
  make() {
    const pattern = this.pattern;
    const options = this.options;
    if (!options.nocomment && pattern.charAt(0) === "#") {
      this.comment = true;
      return;
    }
    if (!pattern) {
      this.empty = true;
      return;
    }
    this.parseNegate();
    this.globSet = [...new Set(this.braceExpand())];
    if (options.debug) {
      this.debug = (...args) => console.error(...args);
    }
    this.debug(this.pattern, this.globSet);
    const rawGlobParts = this.globSet.map((s) => this.slashSplit(s));
    this.globParts = this.preprocess(rawGlobParts);
    this.debug(this.pattern, this.globParts);
    let set = this.globParts.map((s, _, __) => {
      if (this.isWindows && this.windowsNoMagicRoot) {
        const isUNC = s[0] === "" && s[1] === "" && (s[2] === "?" || !globMagic.test(s[2])) && !globMagic.test(s[3]);
        const isDrive = /^[a-z]:/i.test(s[0]);
        if (isUNC) {
          return [...s.slice(0, 4), ...s.slice(4).map((ss) => this.parse(ss))];
        } else if (isDrive) {
          return [s[0], ...s.slice(1).map((ss) => this.parse(ss))];
        }
      }
      return s.map((ss) => this.parse(ss));
    });
    this.debug(this.pattern, set);
    this.set = set.filter((s) => s.indexOf(false) === -1);
    if (this.isWindows) {
      for (let i = 0; i < this.set.length; i++) {
        const p = this.set[i];
        if (p[0] === "" && p[1] === "" && this.globParts[i][2] === "?" && typeof p[3] === "string" && /^[a-z]:$/i.test(p[3])) {
          p[2] = "?";
        }
      }
    }
    this.debug(this.pattern, this.set);
  }
  // various transforms to equivalent pattern sets that are
  // faster to process in a filesystem walk.  The goal is to
  // eliminate what we can, and push all ** patterns as far
  // to the right as possible, even if it increases the number
  // of patterns that we have to process.
  preprocess(globParts) {
    if (this.options.noglobstar) {
      for (let i = 0; i < globParts.length; i++) {
        for (let j = 0; j < globParts[i].length; j++) {
          if (globParts[i][j] === "**") {
            globParts[i][j] = "*";
          }
        }
      }
    }
    const { optimizationLevel = 1 } = this.options;
    if (optimizationLevel >= 2) {
      globParts = this.firstPhasePreProcess(globParts);
      globParts = this.secondPhasePreProcess(globParts);
    } else if (optimizationLevel >= 1) {
      globParts = this.levelOneOptimize(globParts);
    } else {
      globParts = this.adjascentGlobstarOptimize(globParts);
    }
    return globParts;
  }
  // just get rid of adjascent ** portions
  adjascentGlobstarOptimize(globParts) {
    return globParts.map((parts) => {
      let gs = -1;
      while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
        let i = gs;
        while (parts[i + 1] === "**") {
          i++;
        }
        if (i !== gs) {
          parts.splice(gs, i - gs);
        }
      }
      return parts;
    });
  }
  // get rid of adjascent ** and resolve .. portions
  levelOneOptimize(globParts) {
    return globParts.map((parts) => {
      parts = parts.reduce((set, part) => {
        const prev = set[set.length - 1];
        if (part === "**" && prev === "**") {
          return set;
        }
        if (part === "..") {
          if (prev && prev !== ".." && prev !== "." && prev !== "**") {
            set.pop();
            return set;
          }
        }
        set.push(part);
        return set;
      }, []);
      return parts.length === 0 ? [""] : parts;
    });
  }
  levelTwoFileOptimize(parts) {
    if (!Array.isArray(parts)) {
      parts = this.slashSplit(parts);
    }
    let didSomething = false;
    do {
      didSomething = false;
      if (!this.preserveMultipleSlashes) {
        for (let i = 1; i < parts.length - 1; i++) {
          const p = parts[i];
          if (i === 1 && p === "" && parts[0] === "")
            continue;
          if (p === "." || p === "") {
            didSomething = true;
            parts.splice(i, 1);
            i--;
          }
        }
        if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
          didSomething = true;
          parts.pop();
        }
      }
      let dd = 0;
      while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
        const p = parts[dd - 1];
        if (p && p !== "." && p !== ".." && p !== "**") {
          didSomething = true;
          parts.splice(dd - 1, 2);
          dd -= 2;
        }
      }
    } while (didSomething);
    return parts.length === 0 ? [""] : parts;
  }
  // First phase: single-pattern processing
  // <pre> is 1 or more portions
  // <rest> is 1 or more portions
  // <p> is any portion other than ., .., '', or **
  // <e> is . or ''
  //
  // **/.. is *brutal* for filesystem walking performance, because
  // it effectively resets the recursive walk each time it occurs,
  // and ** cannot be reduced out by a .. pattern part like a regexp
  // or most strings (other than .., ., and '') can be.
  //
  // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
  // <pre>/<e>/<rest> -> <pre>/<rest>
  // <pre>/<p>/../<rest> -> <pre>/<rest>
  // **/**/<rest> -> **/<rest>
  //
  // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow
  // this WOULD be allowed if ** did follow symlinks, or * didn't
  firstPhasePreProcess(globParts) {
    let didSomething = false;
    do {
      didSomething = false;
      for (let parts of globParts) {
        let gs = -1;
        while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
          let gss = gs;
          while (parts[gss + 1] === "**") {
            gss++;
          }
          if (gss > gs) {
            parts.splice(gs + 1, gss - gs);
          }
          let next = parts[gs + 1];
          const p = parts[gs + 2];
          const p2 = parts[gs + 3];
          if (next !== "..")
            continue;
          if (!p || p === "." || p === ".." || !p2 || p2 === "." || p2 === "..") {
            continue;
          }
          didSomething = true;
          parts.splice(gs, 1);
          const other = parts.slice(0);
          other[gs] = "**";
          globParts.push(other);
          gs--;
        }
        if (!this.preserveMultipleSlashes) {
          for (let i = 1; i < parts.length - 1; i++) {
            const p = parts[i];
            if (i === 1 && p === "" && parts[0] === "")
              continue;
            if (p === "." || p === "") {
              didSomething = true;
              parts.splice(i, 1);
              i--;
            }
          }
          if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
            didSomething = true;
            parts.pop();
          }
        }
        let dd = 0;
        while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
          const p = parts[dd - 1];
          if (p && p !== "." && p !== ".." && p !== "**") {
            didSomething = true;
            const needDot = dd === 1 && parts[dd + 1] === "**";
            const splin = needDot ? ["."] : [];
            parts.splice(dd - 1, 2, ...splin);
            if (parts.length === 0)
              parts.push("");
            dd -= 2;
          }
        }
      }
    } while (didSomething);
    return globParts;
  }
  // second phase: multi-pattern dedupes
  // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>
  // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>
  // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>
  //
  // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>
  // ^-- not valid because ** doens't follow symlinks
  secondPhasePreProcess(globParts) {
    for (let i = 0; i < globParts.length - 1; i++) {
      for (let j = i + 1; j < globParts.length; j++) {
        const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);
        if (matched) {
          globParts[i] = [];
          globParts[j] = matched;
          break;
        }
      }
    }
    return globParts.filter((gs) => gs.length);
  }
  partsMatch(a, b, emptyGSMatch = false) {
    let ai = 0;
    let bi = 0;
    let result = [];
    let which = "";
    while (ai < a.length && bi < b.length) {
      if (a[ai] === b[bi]) {
        result.push(which === "b" ? b[bi] : a[ai]);
        ai++;
        bi++;
      } else if (emptyGSMatch && a[ai] === "**" && b[bi] === a[ai + 1]) {
        result.push(a[ai]);
        ai++;
      } else if (emptyGSMatch && b[bi] === "**" && a[ai] === b[bi + 1]) {
        result.push(b[bi]);
        bi++;
      } else if (a[ai] === "*" && b[bi] && (this.options.dot || !b[bi].startsWith(".")) && b[bi] !== "**") {
        if (which === "b")
          return false;
        which = "a";
        result.push(a[ai]);
        ai++;
        bi++;
      } else if (b[bi] === "*" && a[ai] && (this.options.dot || !a[ai].startsWith(".")) && a[ai] !== "**") {
        if (which === "a")
          return false;
        which = "b";
        result.push(b[bi]);
        ai++;
        bi++;
      } else {
        return false;
      }
    }
    return a.length === b.length && result;
  }
  parseNegate() {
    if (this.nonegate)
      return;
    const pattern = this.pattern;
    let negate = false;
    let negateOffset = 0;
    for (let i = 0; i < pattern.length && pattern.charAt(i) === "!"; i++) {
      negate = !negate;
      negateOffset++;
    }
    if (negateOffset)
      this.pattern = pattern.slice(negateOffset);
    this.negate = negate;
  }
  // set partial to true to test if, for example,
  // "/a/b" matches the start of "/*/b/*/d"
  // Partial means, if you run out of file before you run
  // out of pattern, then that's fine, as long as all
  // the parts match.
  matchOne(file, pattern, partial = false) {
    const options = this.options;
    if (this.isWindows) {
      const fileDrive = typeof file[0] === "string" && /^[a-z]:$/i.test(file[0]);
      const fileUNC = !fileDrive && file[0] === "" && file[1] === "" && file[2] === "?" && /^[a-z]:$/i.test(file[3]);
      const patternDrive = typeof pattern[0] === "string" && /^[a-z]:$/i.test(pattern[0]);
      const patternUNC = !patternDrive && pattern[0] === "" && pattern[1] === "" && pattern[2] === "?" && typeof pattern[3] === "string" && /^[a-z]:$/i.test(pattern[3]);
      const fdi = fileUNC ? 3 : fileDrive ? 0 : void 0;
      const pdi = patternUNC ? 3 : patternDrive ? 0 : void 0;
      if (typeof fdi === "number" && typeof pdi === "number") {
        const [fd, pd] = [file[fdi], pattern[pdi]];
        if (fd.toLowerCase() === pd.toLowerCase()) {
          pattern[pdi] = fd;
          if (pdi > fdi) {
            pattern = pattern.slice(pdi);
          } else if (fdi > pdi) {
            file = file.slice(fdi);
          }
        }
      }
    }
    const { optimizationLevel = 1 } = this.options;
    if (optimizationLevel >= 2) {
      file = this.levelTwoFileOptimize(file);
    }
    this.debug("matchOne", this, { file, pattern });
    this.debug("matchOne", file.length, pattern.length);
    for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
      this.debug("matchOne loop");
      var p = pattern[pi];
      var f = file[fi];
      this.debug(pattern, p, f);
      if (p === false) {
        return false;
      }
      if (p === GLOBSTAR) {
        this.debug("GLOBSTAR", [pattern, p, f]);
        var fr = fi;
        var pr = pi + 1;
        if (pr === pl) {
          this.debug("** at the end");
          for (; fi < fl; fi++) {
            if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
              return false;
          }
          return true;
        }
        while (fr < fl) {
          var swallowee = file[fr];
          this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
            this.debug("globstar found match!", fr, fl, swallowee);
            return true;
          } else {
            if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
              this.debug("dot detected!", file, fr, pattern, pr);
              break;
            }
            this.debug("globstar swallow a segment, and continue");
            fr++;
          }
        }
        if (partial) {
          this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
          if (fr === fl) {
            return true;
          }
        }
        return false;
      }
      let hit;
      if (typeof p === "string") {
        hit = f === p;
        this.debug("string match", p, f, hit);
      } else {
        hit = p.test(f);
        this.debug("pattern match", p, f, hit);
      }
      if (!hit)
        return false;
    }
    if (fi === fl && pi === pl) {
      return true;
    } else if (fi === fl) {
      return partial;
    } else if (pi === pl) {
      return fi === fl - 1 && file[fi] === "";
    } else {
      throw new Error("wtf?");
    }
  }
  braceExpand() {
    return braceExpand(this.pattern, this.options);
  }
  parse(pattern) {
    assertValidPattern(pattern);
    const options = this.options;
    if (pattern === "**")
      return GLOBSTAR;
    if (pattern === "")
      return "";
    let m;
    let fastTest = null;
    if (m = pattern.match(starRE)) {
      fastTest = options.dot ? starTestDot : starTest;
    } else if (m = pattern.match(starDotExtRE)) {
      fastTest = (options.nocase ? options.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options.dot ? starDotExtTestDot : starDotExtTest)(m[1]);
    } else if (m = pattern.match(qmarksRE)) {
      fastTest = (options.nocase ? options.dot ? qmarksTestNocaseDot : qmarksTestNocase : options.dot ? qmarksTestDot : qmarksTest)(m);
    } else if (m = pattern.match(starDotStarRE)) {
      fastTest = options.dot ? starDotStarTestDot : starDotStarTest;
    } else if (m = pattern.match(dotStarRE)) {
      fastTest = dotStarTest;
    }
    const re = AST.fromGlob(pattern, this.options).toMMPattern();
    if (fastTest && typeof re === "object") {
      Reflect.defineProperty(re, "test", { value: fastTest });
    }
    return re;
  }
  makeRe() {
    if (this.regexp || this.regexp === false)
      return this.regexp;
    const set = this.set;
    if (!set.length) {
      this.regexp = false;
      return this.regexp;
    }
    const options = this.options;
    const twoStar = options.noglobstar ? star2 : options.dot ? twoStarDot : twoStarNoDot;
    const flags = new Set(options.nocase ? ["i"] : []);
    let re = set.map((pattern) => {
      const pp = pattern.map((p) => {
        if (p instanceof RegExp) {
          for (const f of p.flags.split(""))
            flags.add(f);
        }
        return typeof p === "string" ? regExpEscape2(p) : p === GLOBSTAR ? GLOBSTAR : p._src;
      });
      pp.forEach((p, i) => {
        const next = pp[i + 1];
        const prev = pp[i - 1];
        if (p !== GLOBSTAR || prev === GLOBSTAR) {
          return;
        }
        if (prev === void 0) {
          if (next !== void 0 && next !== GLOBSTAR) {
            pp[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + next;
          } else {
            pp[i] = twoStar;
          }
        } else if (next === void 0) {
          pp[i - 1] = prev + "(?:\\/|" + twoStar + ")?";
        } else if (next !== GLOBSTAR) {
          pp[i - 1] = prev + "(?:\\/|\\/" + twoStar + "\\/)" + next;
          pp[i + 1] = GLOBSTAR;
        }
      });
      return pp.filter((p) => p !== GLOBSTAR).join("/");
    }).join("|");
    const [open, close] = set.length > 1 ? ["(?:", ")"] : ["", ""];
    re = "^" + open + re + close + "$";
    if (this.negate)
      re = "^(?!" + re + ").+$";
    try {
      this.regexp = new RegExp(re, [...flags].join(""));
    } catch (ex) {
      this.regexp = false;
    }
    return this.regexp;
  }
  slashSplit(p) {
    if (this.preserveMultipleSlashes) {
      return p.split("/");
    } else if (this.isWindows && /^\/\/[^\/]+/.test(p)) {
      return ["", ...p.split(/\/+/)];
    } else {
      return p.split(/\/+/);
    }
  }
  match(f, partial = this.partial) {
    this.debug("match", f, this.pattern);
    if (this.comment) {
      return false;
    }
    if (this.empty) {
      return f === "";
    }
    if (f === "/" && partial) {
      return true;
    }
    const options = this.options;
    if (this.isWindows) {
      f = f.split("\\").join("/");
    }
    const ff = this.slashSplit(f);
    this.debug(this.pattern, "split", ff);
    const set = this.set;
    this.debug(this.pattern, "set", set);
    let filename = ff[ff.length - 1];
    if (!filename) {
      for (let i = ff.length - 2; !filename && i >= 0; i--) {
        filename = ff[i];
      }
    }
    for (let i = 0; i < set.length; i++) {
      const pattern = set[i];
      let file = ff;
      if (options.matchBase && pattern.length === 1) {
        file = [filename];
      }
      const hit = this.matchOne(file, pattern, partial);
      if (hit) {
        if (options.flipNegate) {
          return true;
        }
        return !this.negate;
      }
    }
    if (options.flipNegate) {
      return false;
    }
    return this.negate;
  }
  static defaults(def) {
    return minimatch.defaults(def).Minimatch;
  }
};
minimatch.AST = AST;
minimatch.Minimatch = Minimatch;
minimatch.escape = escape;
minimatch.unescape = unescape;

// ../../node_modules/.pnpm/glob@11.0.2/node_modules/glob/dist/esm/glob.js
init_importMeta();
var import_node_url2 = require("node:url");

// ../../node_modules/.pnpm/path-scurry@2.0.0/node_modules/path-scurry/dist/esm/index.js
init_importMeta();

// ../../node_modules/.pnpm/lru-cache@11.1.0/node_modules/lru-cache/dist/esm/index.js
init_importMeta();
var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
var warned = /* @__PURE__ */ new Set();
var PROCESS = typeof process === "object" && !!process ? process : {};
var emitWarning = (msg, type, code, fn) => {
  typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);
};
var AC = globalThis.AbortController;
var AS = globalThis.AbortSignal;
if (typeof AC === "undefined") {
  AS = class AbortSignal {
    onabort;
    _onabort = [];
    reason;
    aborted = false;
    addEventListener(_, fn) {
      this._onabort.push(fn);
    }
  };
  AC = class AbortController {
    constructor() {
      warnACPolyfill();
    }
    signal = new AS();
    abort(reason) {
      if (this.signal.aborted)
        return;
      this.signal.reason = reason;
      this.signal.aborted = true;
      for (const fn of this.signal._onabort) {
        fn(reason);
      }
      this.signal.onabort?.(reason);
    }
  };
  let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
  const warnACPolyfill = () => {
    if (!printACPolyfillWarning)
      return;
    printACPolyfillWarning = false;
    emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
  };
}
var shouldWarn = (code) => !warned.has(code);
var TYPE = Symbol("type");
var isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
var getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
var ZeroArray = class extends Array {
  constructor(size) {
    super(size);
    this.fill(0);
  }
};
var Stack = class _Stack {
  heap;
  length;
  // private constructor
  static #constructing = false;
  static create(max) {
    const HeapCls = getUintArray(max);
    if (!HeapCls)
      return [];
    _Stack.#constructing = true;
    const s = new _Stack(max, HeapCls);
    _Stack.#constructing = false;
    return s;
  }
  constructor(max, HeapCls) {
    if (!_Stack.#constructing) {
      throw new TypeError("instantiate Stack using Stack.create(n)");
    }
    this.heap = new HeapCls(max);
    this.length = 0;
  }
  push(n) {
    this.heap[this.length++] = n;
  }
  pop() {
    return this.heap[--this.length];
  }
};
var LRUCache = class _LRUCache {
  // options that cannot be changed without disaster
  #max;
  #maxSize;
  #dispose;
  #onInsert;
  #disposeAfter;
  #fetchMethod;
  #memoMethod;
  /**
   * {@link LRUCache.OptionsBase.ttl}
   */
  ttl;
  /**
   * {@link LRUCache.OptionsBase.ttlResolution}
   */
  ttlResolution;
  /**
   * {@link LRUCache.OptionsBase.ttlAutopurge}
   */
  ttlAutopurge;
  /**
   * {@link LRUCache.OptionsBase.updateAgeOnGet}
   */
  updateAgeOnGet;
  /**
   * {@link LRUCache.OptionsBase.updateAgeOnHas}
   */
  updateAgeOnHas;
  /**
   * {@link LRUCache.OptionsBase.allowStale}
   */
  allowStale;
  /**
   * {@link LRUCache.OptionsBase.noDisposeOnSet}
   */
  noDisposeOnSet;
  /**
   * {@link LRUCache.OptionsBase.noUpdateTTL}
   */
  noUpdateTTL;
  /**
   * {@link LRUCache.OptionsBase.maxEntrySize}
   */
  maxEntrySize;
  /**
   * {@link LRUCache.OptionsBase.sizeCalculation}
   */
  sizeCalculation;
  /**
   * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
   */
  noDeleteOnFetchRejection;
  /**
   * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
   */
  noDeleteOnStaleGet;
  /**
   * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
   */
  allowStaleOnFetchAbort;
  /**
   * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
   */
  allowStaleOnFetchRejection;
  /**
   * {@link LRUCache.OptionsBase.ignoreFetchAbort}
   */
  ignoreFetchAbort;
  // computed properties
  #size;
  #calculatedSize;
  #keyMap;
  #keyList;
  #valList;
  #next;
  #prev;
  #head;
  #tail;
  #free;
  #disposed;
  #sizes;
  #starts;
  #ttls;
  #hasDispose;
  #hasFetchMethod;
  #hasDisposeAfter;
  #hasOnInsert;
  /**
   * Do not call this method unless you need to inspect the
   * inner workings of the cache.  If anything returned by this
   * object is modified in any way, strange breakage may occur.
   *
   * These fields are private for a reason!
   *
   * @internal
   */
  static unsafeExposeInternals(c) {
    return {
      // properties
      starts: c.#starts,
      ttls: c.#ttls,
      sizes: c.#sizes,
      keyMap: c.#keyMap,
      keyList: c.#keyList,
      valList: c.#valList,
      next: c.#next,
      prev: c.#prev,
      get head() {
        return c.#head;
      },
      get tail() {
        return c.#tail;
      },
      free: c.#free,
      // methods
      isBackgroundFetch: (p) => c.#isBackgroundFetch(p),
      backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),
      moveToTail: (index) => c.#moveToTail(index),
      indexes: (options) => c.#indexes(options),
      rindexes: (options) => c.#rindexes(options),
      isStale: (index) => c.#isStale(index)
    };
  }
  // Protected read-only members
  /**
   * {@link LRUCache.OptionsBase.max} (read-only)
   */
  get max() {
    return this.#max;
  }
  /**
   * {@link LRUCache.OptionsBase.maxSize} (read-only)
   */
  get maxSize() {
    return this.#maxSize;
  }
  /**
   * The total computed size of items in the cache (read-only)
   */
  get calculatedSize() {
    return this.#calculatedSize;
  }
  /**
   * The number of items stored in the cache (read-only)
   */
  get size() {
    return this.#size;
  }
  /**
   * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
   */
  get fetchMethod() {
    return this.#fetchMethod;
  }
  get memoMethod() {
    return this.#memoMethod;
  }
  /**
   * {@link LRUCache.OptionsBase.dispose} (read-only)
   */
  get dispose() {
    return this.#dispose;
  }
  /**
   * {@link LRUCache.OptionsBase.onInsert} (read-only)
   */
  get onInsert() {
    return this.#onInsert;
  }
  /**
   * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
   */
  get disposeAfter() {
    return this.#disposeAfter;
  }
  constructor(options) {
    const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, onInsert, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;
    if (max !== 0 && !isPosInt(max)) {
      throw new TypeError("max option must be a nonnegative integer");
    }
    const UintArray = max ? getUintArray(max) : Array;
    if (!UintArray) {
      throw new Error("invalid max value: " + max);
    }
    this.#max = max;
    this.#maxSize = maxSize;
    this.maxEntrySize = maxEntrySize || this.#maxSize;
    this.sizeCalculation = sizeCalculation;
    if (this.sizeCalculation) {
      if (!this.#maxSize && !this.maxEntrySize) {
        throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
      }
      if (typeof this.sizeCalculation !== "function") {
        throw new TypeError("sizeCalculation set to non-function");
      }
    }
    if (memoMethod !== void 0 && typeof memoMethod !== "function") {
      throw new TypeError("memoMethod must be a function if defined");
    }
    this.#memoMethod = memoMethod;
    if (fetchMethod !== void 0 && typeof fetchMethod !== "function") {
      throw new TypeError("fetchMethod must be a function if specified");
    }
    this.#fetchMethod = fetchMethod;
    this.#hasFetchMethod = !!fetchMethod;
    this.#keyMap = /* @__PURE__ */ new Map();
    this.#keyList = new Array(max).fill(void 0);
    this.#valList = new Array(max).fill(void 0);
    this.#next = new UintArray(max);
    this.#prev = new UintArray(max);
    this.#head = 0;
    this.#tail = 0;
    this.#free = Stack.create(max);
    this.#size = 0;
    this.#calculatedSize = 0;
    if (typeof dispose === "function") {
      this.#dispose = dispose;
    }
    if (typeof onInsert === "function") {
      this.#onInsert = onInsert;
    }
    if (typeof disposeAfter === "function") {
      this.#disposeAfter = disposeAfter;
      this.#disposed = [];
    } else {
      this.#disposeAfter = void 0;
      this.#disposed = void 0;
    }
    this.#hasDispose = !!this.#dispose;
    this.#hasOnInsert = !!this.#onInsert;
    this.#hasDisposeAfter = !!this.#disposeAfter;
    this.noDisposeOnSet = !!noDisposeOnSet;
    this.noUpdateTTL = !!noUpdateTTL;
    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
    this.ignoreFetchAbort = !!ignoreFetchAbort;
    if (this.maxEntrySize !== 0) {
      if (this.#maxSize !== 0) {
        if (!isPosInt(this.#maxSize)) {
          throw new TypeError("maxSize must be a positive integer if specified");
        }
      }
      if (!isPosInt(this.maxEntrySize)) {
        throw new TypeError("maxEntrySize must be a positive integer if specified");
      }
      this.#initializeSizeTracking();
    }
    this.allowStale = !!allowStale;
    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
    this.updateAgeOnGet = !!updateAgeOnGet;
    this.updateAgeOnHas = !!updateAgeOnHas;
    this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
    this.ttlAutopurge = !!ttlAutopurge;
    this.ttl = ttl || 0;
    if (this.ttl) {
      if (!isPosInt(this.ttl)) {
        throw new TypeError("ttl must be a positive integer if specified");
      }
      this.#initializeTTLTracking();
    }
    if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
      throw new TypeError("At least one of max, maxSize, or ttl is required");
    }
    if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
      const code = "LRU_CACHE_UNBOUNDED";
      if (shouldWarn(code)) {
        warned.add(code);
        const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
        emitWarning(msg, "UnboundedCacheWarning", code, _LRUCache);
      }
    }
  }
  /**
   * Return the number of ms left in the item's TTL. If item is not in cache,
   * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.
   */
  getRemainingTTL(key) {
    return this.#keyMap.has(key) ? Infinity : 0;
  }
  #initializeTTLTracking() {
    const ttls = new ZeroArray(this.#max);
    const starts = new ZeroArray(this.#max);
    this.#ttls = ttls;
    this.#starts = starts;
    this.#setItemTTL = (index, ttl, start = perf.now()) => {
      starts[index] = ttl !== 0 ? start : 0;
      ttls[index] = ttl;
      if (ttl !== 0 && this.ttlAutopurge) {
        const t = setTimeout(() => {
          if (this.#isStale(index)) {
            this.#delete(this.#keyList[index], "expire");
          }
        }, ttl + 1);
        if (t.unref) {
          t.unref();
        }
      }
    };
    this.#updateItemAge = (index) => {
      starts[index] = ttls[index] !== 0 ? perf.now() : 0;
    };
    this.#statusTTL = (status, index) => {
      if (ttls[index]) {
        const ttl = ttls[index];
        const start = starts[index];
        if (!ttl || !start)
          return;
        status.ttl = ttl;
        status.start = start;
        status.now = cachedNow || getNow();
        const age = status.now - start;
        status.remainingTTL = ttl - age;
      }
    };
    let cachedNow = 0;
    const getNow = () => {
      const n = perf.now();
      if (this.ttlResolution > 0) {
        cachedNow = n;
        const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
        if (t.unref) {
          t.unref();
        }
      }
      return n;
    };
    this.getRemainingTTL = (key) => {
      const index = this.#keyMap.get(key);
      if (index === void 0) {
        return 0;
      }
      const ttl = ttls[index];
      const start = starts[index];
      if (!ttl || !start) {
        return Infinity;
      }
      const age = (cachedNow || getNow()) - start;
      return ttl - age;
    };
    this.#isStale = (index) => {
      const s = starts[index];
      const t = ttls[index];
      return !!t && !!s && (cachedNow || getNow()) - s > t;
    };
  }
  // conditionally set private methods related to TTL
  #updateItemAge = () => {
  };
  #statusTTL = () => {
  };
  #setItemTTL = () => {
  };
  /* c8 ignore stop */
  #isStale = () => false;
  #initializeSizeTracking() {
    const sizes = new ZeroArray(this.#max);
    this.#calculatedSize = 0;
    this.#sizes = sizes;
    this.#removeItemSize = (index) => {
      this.#calculatedSize -= sizes[index];
      sizes[index] = 0;
    };
    this.#requireSize = (k, v, size, sizeCalculation) => {
      if (this.#isBackgroundFetch(v)) {
        return 0;
      }
      if (!isPosInt(size)) {
        if (sizeCalculation) {
          if (typeof sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation must be a function");
          }
          size = sizeCalculation(v, k);
          if (!isPosInt(size)) {
            throw new TypeError("sizeCalculation return invalid (expect positive integer)");
          }
        } else {
          throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
        }
      }
      return size;
    };
    this.#addItemSize = (index, size, status) => {
      sizes[index] = size;
      if (this.#maxSize) {
        const maxSize = this.#maxSize - sizes[index];
        while (this.#calculatedSize > maxSize) {
          this.#evict(true);
        }
      }
      this.#calculatedSize += sizes[index];
      if (status) {
        status.entrySize = size;
        status.totalCalculatedSize = this.#calculatedSize;
      }
    };
  }
  #removeItemSize = (_i) => {
  };
  #addItemSize = (_i, _s, _st) => {
  };
  #requireSize = (_k, _v, size, sizeCalculation) => {
    if (size || sizeCalculation) {
      throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
    }
    return 0;
  };
  *#indexes({ allowStale = this.allowStale } = {}) {
    if (this.#size) {
      for (let i = this.#tail; true; ) {
        if (!this.#isValidIndex(i)) {
          break;
        }
        if (allowStale || !this.#isStale(i)) {
          yield i;
        }
        if (i === this.#head) {
          break;
        } else {
          i = this.#prev[i];
        }
      }
    }
  }
  *#rindexes({ allowStale = this.allowStale } = {}) {
    if (this.#size) {
      for (let i = this.#head; true; ) {
        if (!this.#isValidIndex(i)) {
          break;
        }
        if (allowStale || !this.#isStale(i)) {
          yield i;
        }
        if (i === this.#tail) {
          break;
        } else {
          i = this.#next[i];
        }
      }
    }
  }
  #isValidIndex(index) {
    return index !== void 0 && this.#keyMap.get(this.#keyList[index]) === index;
  }
  /**
   * Return a generator yielding `[key, value]` pairs,
   * in order from most recently used to least recently used.
   */
  *entries() {
    for (const i of this.#indexes()) {
      if (this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield [this.#keyList[i], this.#valList[i]];
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.entries}
   *
   * Return a generator yielding `[key, value]` pairs,
   * in order from least recently used to most recently used.
   */
  *rentries() {
    for (const i of this.#rindexes()) {
      if (this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield [this.#keyList[i], this.#valList[i]];
      }
    }
  }
  /**
   * Return a generator yielding the keys in the cache,
   * in order from most recently used to least recently used.
   */
  *keys() {
    for (const i of this.#indexes()) {
      const k = this.#keyList[i];
      if (k !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield k;
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.keys}
   *
   * Return a generator yielding the keys in the cache,
   * in order from least recently used to most recently used.
   */
  *rkeys() {
    for (const i of this.#rindexes()) {
      const k = this.#keyList[i];
      if (k !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield k;
      }
    }
  }
  /**
   * Return a generator yielding the values in the cache,
   * in order from most recently used to least recently used.
   */
  *values() {
    for (const i of this.#indexes()) {
      const v = this.#valList[i];
      if (v !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield this.#valList[i];
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.values}
   *
   * Return a generator yielding the values in the cache,
   * in order from least recently used to most recently used.
   */
  *rvalues() {
    for (const i of this.#rindexes()) {
      const v = this.#valList[i];
      if (v !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield this.#valList[i];
      }
    }
  }
  /**
   * Iterating over the cache itself yields the same results as
   * {@link LRUCache.entries}
   */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * A String value that is used in the creation of the default string
   * description of an object. Called by the built-in method
   * `Object.prototype.toString`.
   */
  [Symbol.toStringTag] = "LRUCache";
  /**
   * Find a value for which the supplied fn method returns a truthy value,
   * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.
   */
  find(fn, getOptions = {}) {
    for (const i of this.#indexes()) {
      const v = this.#valList[i];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === void 0)
        continue;
      if (fn(value, this.#keyList[i], this)) {
        return this.get(this.#keyList[i], getOptions);
      }
    }
  }
  /**
   * Call the supplied function on each item in the cache, in order from most
   * recently used to least recently used.
   *
   * `fn` is called as `fn(value, key, cache)`.
   *
   * If `thisp` is provided, function will be called in the `this`-context of
   * the provided object, or the cache if no `thisp` object is provided.
   *
   * Does not update age or recenty of use, or iterate over stale values.
   */
  forEach(fn, thisp = this) {
    for (const i of this.#indexes()) {
      const v = this.#valList[i];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === void 0)
        continue;
      fn.call(thisp, value, this.#keyList[i], this);
    }
  }
  /**
   * The same as {@link LRUCache.forEach} but items are iterated over in
   * reverse order.  (ie, less recently used items are iterated over first.)
   */
  rforEach(fn, thisp = this) {
    for (const i of this.#rindexes()) {
      const v = this.#valList[i];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === void 0)
        continue;
      fn.call(thisp, value, this.#keyList[i], this);
    }
  }
  /**
   * Delete any stale entries. Returns true if anything was removed,
   * false otherwise.
   */
  purgeStale() {
    let deleted = false;
    for (const i of this.#rindexes({ allowStale: true })) {
      if (this.#isStale(i)) {
        this.#delete(this.#keyList[i], "expire");
        deleted = true;
      }
    }
    return deleted;
  }
  /**
   * Get the extended info about a given entry, to get its value, size, and
   * TTL info simultaneously. Returns `undefined` if the key is not present.
   *
   * Unlike {@link LRUCache#dump}, which is designed to be portable and survive
   * serialization, the `start` value is always the current timestamp, and the
   * `ttl` is a calculated remaining time to live (negative if expired).
   *
   * Always returns stale values, if their info is found in the cache, so be
   * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})
   * if relevant.
   */
  info(key) {
    const i = this.#keyMap.get(key);
    if (i === void 0)
      return void 0;
    const v = this.#valList[i];
    const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
    if (value === void 0)
      return void 0;
    const entry = { value };
    if (this.#ttls && this.#starts) {
      const ttl = this.#ttls[i];
      const start = this.#starts[i];
      if (ttl && start) {
        const remain = ttl - (perf.now() - start);
        entry.ttl = remain;
        entry.start = Date.now();
      }
    }
    if (this.#sizes) {
      entry.size = this.#sizes[i];
    }
    return entry;
  }
  /**
   * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
   * passed to {@link LRUCache#load}.
   *
   * The `start` fields are calculated relative to a portable `Date.now()`
   * timestamp, even if `performance.now()` is available.
   *
   * Stale entries are always included in the `dump`, even if
   * {@link LRUCache.OptionsBase.allowStale} is false.
   *
   * Note: this returns an actual array, not a generator, so it can be more
   * easily passed around.
   */
  dump() {
    const arr = [];
    for (const i of this.#indexes({ allowStale: true })) {
      const key = this.#keyList[i];
      const v = this.#valList[i];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === void 0 || key === void 0)
        continue;
      const entry = { value };
      if (this.#ttls && this.#starts) {
        entry.ttl = this.#ttls[i];
        const age = perf.now() - this.#starts[i];
        entry.start = Math.floor(Date.now() - age);
      }
      if (this.#sizes) {
        entry.size = this.#sizes[i];
      }
      arr.unshift([key, entry]);
    }
    return arr;
  }
  /**
   * Reset the cache and load in the items in entries in the order listed.
   *
   * The shape of the resulting cache may be different if the same options are
   * not used in both caches.
   *
   * The `start` fields are assumed to be calculated relative to a portable
   * `Date.now()` timestamp, even if `performance.now()` is available.
   */
  load(arr) {
    this.clear();
    for (const [key, entry] of arr) {
      if (entry.start) {
        const age = Date.now() - entry.start;
        entry.start = perf.now() - age;
      }
      this.set(key, entry.value, entry);
    }
  }
  /**
   * Add a value to the cache.
   *
   * Note: if `undefined` is specified as a value, this is an alias for
   * {@link LRUCache#delete}
   *
   * Fields on the {@link LRUCache.SetOptions} options param will override
   * their corresponding values in the constructor options for the scope
   * of this single `set()` operation.
   *
   * If `start` is provided, then that will set the effective start
   * time for the TTL calculation. Note that this must be a previous
   * value of `performance.now()` if supported, or a previous value of
   * `Date.now()` if not.
   *
   * Options object may also include `size`, which will prevent
   * calling the `sizeCalculation` function and just use the specified
   * number if it is a positive integer, and `noDisposeOnSet` which
   * will prevent calling a `dispose` function in the case of
   * overwrites.
   *
   * If the `size` (or return value of `sizeCalculation`) for a given
   * entry is greater than `maxEntrySize`, then the item will not be
   * added to the cache.
   *
   * Will update the recency of the entry.
   *
   * If the value is `undefined`, then this is an alias for
   * `cache.delete(key)`. `undefined` is never stored in the cache.
   */
  set(k, v, setOptions = {}) {
    if (v === void 0) {
      this.delete(k);
      return this;
    }
    const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
    let { noUpdateTTL = this.noUpdateTTL } = setOptions;
    const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
    if (this.maxEntrySize && size > this.maxEntrySize) {
      if (status) {
        status.set = "miss";
        status.maxEntrySizeExceeded = true;
      }
      this.#delete(k, "set");
      return this;
    }
    let index = this.#size === 0 ? void 0 : this.#keyMap.get(k);
    if (index === void 0) {
      index = this.#size === 0 ? this.#tail : this.#free.length !== 0 ? this.#free.pop() : this.#size === this.#max ? this.#evict(false) : this.#size;
      this.#keyList[index] = k;
      this.#valList[index] = v;
      this.#keyMap.set(k, index);
      this.#next[this.#tail] = index;
      this.#prev[index] = this.#tail;
      this.#tail = index;
      this.#size++;
      this.#addItemSize(index, size, status);
      if (status)
        status.set = "add";
      noUpdateTTL = false;
      if (this.#hasOnInsert) {
        this.#onInsert?.(v, k, "add");
      }
    } else {
      this.#moveToTail(index);
      const oldVal = this.#valList[index];
      if (v !== oldVal) {
        if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
          oldVal.__abortController.abort(new Error("replaced"));
          const { __staleWhileFetching: s } = oldVal;
          if (s !== void 0 && !noDisposeOnSet) {
            if (this.#hasDispose) {
              this.#dispose?.(s, k, "set");
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([s, k, "set"]);
            }
          }
        } else if (!noDisposeOnSet) {
          if (this.#hasDispose) {
            this.#dispose?.(oldVal, k, "set");
          }
          if (this.#hasDisposeAfter) {
            this.#disposed?.push([oldVal, k, "set"]);
          }
        }
        this.#removeItemSize(index);
        this.#addItemSize(index, size, status);
        this.#valList[index] = v;
        if (status) {
          status.set = "replace";
          const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
          if (oldValue !== void 0)
            status.oldValue = oldValue;
        }
      } else if (status) {
        status.set = "update";
      }
      if (this.#hasOnInsert) {
        this.onInsert?.(v, k, v === oldVal ? "update" : "replace");
      }
    }
    if (ttl !== 0 && !this.#ttls) {
      this.#initializeTTLTracking();
    }
    if (this.#ttls) {
      if (!noUpdateTTL) {
        this.#setItemTTL(index, ttl, start);
      }
      if (status)
        this.#statusTTL(status, index);
    }
    if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
      const dt = this.#disposed;
      let task;
      while (task = dt?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
    return this;
  }
  /**
   * Evict the least recently used item, returning its value or
   * `undefined` if cache is empty.
   */
  pop() {
    try {
      while (this.#size) {
        const val = this.#valList[this.#head];
        this.#evict(true);
        if (this.#isBackgroundFetch(val)) {
          if (val.__staleWhileFetching) {
            return val.__staleWhileFetching;
          }
        } else if (val !== void 0) {
          return val;
        }
      }
    } finally {
      if (this.#hasDisposeAfter && this.#disposed) {
        const dt = this.#disposed;
        let task;
        while (task = dt?.shift()) {
          this.#disposeAfter?.(...task);
        }
      }
    }
  }
  #evict(free) {
    const head = this.#head;
    const k = this.#keyList[head];
    const v = this.#valList[head];
    if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {
      v.__abortController.abort(new Error("evicted"));
    } else if (this.#hasDispose || this.#hasDisposeAfter) {
      if (this.#hasDispose) {
        this.#dispose?.(v, k, "evict");
      }
      if (this.#hasDisposeAfter) {
        this.#disposed?.push([v, k, "evict"]);
      }
    }
    this.#removeItemSize(head);
    if (free) {
      this.#keyList[head] = void 0;
      this.#valList[head] = void 0;
      this.#free.push(head);
    }
    if (this.#size === 1) {
      this.#head = this.#tail = 0;
      this.#free.length = 0;
    } else {
      this.#head = this.#next[head];
    }
    this.#keyMap.delete(k);
    this.#size--;
    return head;
  }
  /**
   * Check if a key is in the cache, without updating the recency of use.
   * Will return false if the item is stale, even though it is technically
   * in the cache.
   *
   * Check if a key is in the cache, without updating the recency of
   * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set
   * to `true` in either the options or the constructor.
   *
   * Will return `false` if the item is stale, even though it is technically in
   * the cache. The difference can be determined (if it matters) by using a
   * `status` argument, and inspecting the `has` field.
   *
   * Will not update item age unless
   * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
   */
  has(k, hasOptions = {}) {
    const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
    const index = this.#keyMap.get(k);
    if (index !== void 0) {
      const v = this.#valList[index];
      if (this.#isBackgroundFetch(v) && v.__staleWhileFetching === void 0) {
        return false;
      }
      if (!this.#isStale(index)) {
        if (updateAgeOnHas) {
          this.#updateItemAge(index);
        }
        if (status) {
          status.has = "hit";
          this.#statusTTL(status, index);
        }
        return true;
      } else if (status) {
        status.has = "stale";
        this.#statusTTL(status, index);
      }
    } else if (status) {
      status.has = "miss";
    }
    return false;
  }
  /**
   * Like {@link LRUCache#get} but doesn't update recency or delete stale
   * items.
   *
   * Returns `undefined` if the item is stale, unless
   * {@link LRUCache.OptionsBase.allowStale} is set.
   */
  peek(k, peekOptions = {}) {
    const { allowStale = this.allowStale } = peekOptions;
    const index = this.#keyMap.get(k);
    if (index === void 0 || !allowStale && this.#isStale(index)) {
      return;
    }
    const v = this.#valList[index];
    return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
  }
  #backgroundFetch(k, index, options, context) {
    const v = index === void 0 ? void 0 : this.#valList[index];
    if (this.#isBackgroundFetch(v)) {
      return v;
    }
    const ac = new AC();
    const { signal } = options;
    signal?.addEventListener("abort", () => ac.abort(signal.reason), {
      signal: ac.signal
    });
    const fetchOpts = {
      signal: ac.signal,
      options,
      context
    };
    const cb = (v2, updateCache = false) => {
      const { aborted } = ac.signal;
      const ignoreAbort = options.ignoreFetchAbort && v2 !== void 0;
      if (options.status) {
        if (aborted && !updateCache) {
          options.status.fetchAborted = true;
          options.status.fetchError = ac.signal.reason;
          if (ignoreAbort)
            options.status.fetchAbortIgnored = true;
        } else {
          options.status.fetchResolved = true;
        }
      }
      if (aborted && !ignoreAbort && !updateCache) {
        return fetchFail(ac.signal.reason);
      }
      const bf2 = p;
      if (this.#valList[index] === p) {
        if (v2 === void 0) {
          if (bf2.__staleWhileFetching) {
            this.#valList[index] = bf2.__staleWhileFetching;
          } else {
            this.#delete(k, "fetch");
          }
        } else {
          if (options.status)
            options.status.fetchUpdated = true;
          this.set(k, v2, fetchOpts.options);
        }
      }
      return v2;
    };
    const eb = (er) => {
      if (options.status) {
        options.status.fetchRejected = true;
        options.status.fetchError = er;
      }
      return fetchFail(er);
    };
    const fetchFail = (er) => {
      const { aborted } = ac.signal;
      const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
      const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
      const noDelete = allowStale || options.noDeleteOnFetchRejection;
      const bf2 = p;
      if (this.#valList[index] === p) {
        const del = !noDelete || bf2.__staleWhileFetching === void 0;
        if (del) {
          this.#delete(k, "fetch");
        } else if (!allowStaleAborted) {
          this.#valList[index] = bf2.__staleWhileFetching;
        }
      }
      if (allowStale) {
        if (options.status && bf2.__staleWhileFetching !== void 0) {
          options.status.returnedStale = true;
        }
        return bf2.__staleWhileFetching;
      } else if (bf2.__returned === bf2) {
        throw er;
      }
    };
    const pcall = (res, rej) => {
      const fmp = this.#fetchMethod?.(k, v, fetchOpts);
      if (fmp && fmp instanceof Promise) {
        fmp.then((v2) => res(v2 === void 0 ? void 0 : v2), rej);
      }
      ac.signal.addEventListener("abort", () => {
        if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
          res(void 0);
          if (options.allowStaleOnFetchAbort) {
            res = (v2) => cb(v2, true);
          }
        }
      });
    };
    if (options.status)
      options.status.fetchDispatched = true;
    const p = new Promise(pcall).then(cb, eb);
    const bf = Object.assign(p, {
      __abortController: ac,
      __staleWhileFetching: v,
      __returned: void 0
    });
    if (index === void 0) {
      this.set(k, bf, { ...fetchOpts.options, status: void 0 });
      index = this.#keyMap.get(k);
    } else {
      this.#valList[index] = bf;
    }
    return bf;
  }
  #isBackgroundFetch(p) {
    if (!this.#hasFetchMethod)
      return false;
    const b = p;
    return !!b && b instanceof Promise && b.hasOwnProperty("__staleWhileFetching") && b.__abortController instanceof AC;
  }
  async fetch(k, fetchOptions = {}) {
    const {
      // get options
      allowStale = this.allowStale,
      updateAgeOnGet = this.updateAgeOnGet,
      noDeleteOnStaleGet = this.noDeleteOnStaleGet,
      // set options
      ttl = this.ttl,
      noDisposeOnSet = this.noDisposeOnSet,
      size = 0,
      sizeCalculation = this.sizeCalculation,
      noUpdateTTL = this.noUpdateTTL,
      // fetch exclusive options
      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
      ignoreFetchAbort = this.ignoreFetchAbort,
      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
      context,
      forceRefresh = false,
      status,
      signal
    } = fetchOptions;
    if (!this.#hasFetchMethod) {
      if (status)
        status.fetch = "get";
      return this.get(k, {
        allowStale,
        updateAgeOnGet,
        noDeleteOnStaleGet,
        status
      });
    }
    const options = {
      allowStale,
      updateAgeOnGet,
      noDeleteOnStaleGet,
      ttl,
      noDisposeOnSet,
      size,
      sizeCalculation,
      noUpdateTTL,
      noDeleteOnFetchRejection,
      allowStaleOnFetchRejection,
      allowStaleOnFetchAbort,
      ignoreFetchAbort,
      status,
      signal
    };
    let index = this.#keyMap.get(k);
    if (index === void 0) {
      if (status)
        status.fetch = "miss";
      const p = this.#backgroundFetch(k, index, options, context);
      return p.__returned = p;
    } else {
      const v = this.#valList[index];
      if (this.#isBackgroundFetch(v)) {
        const stale = allowStale && v.__staleWhileFetching !== void 0;
        if (status) {
          status.fetch = "inflight";
          if (stale)
            status.returnedStale = true;
        }
        return stale ? v.__staleWhileFetching : v.__returned = v;
      }
      const isStale = this.#isStale(index);
      if (!forceRefresh && !isStale) {
        if (status)
          status.fetch = "hit";
        this.#moveToTail(index);
        if (updateAgeOnGet) {
          this.#updateItemAge(index);
        }
        if (status)
          this.#statusTTL(status, index);
        return v;
      }
      const p = this.#backgroundFetch(k, index, options, context);
      const hasStale = p.__staleWhileFetching !== void 0;
      const staleVal = hasStale && allowStale;
      if (status) {
        status.fetch = isStale ? "stale" : "refresh";
        if (staleVal && isStale)
          status.returnedStale = true;
      }
      return staleVal ? p.__staleWhileFetching : p.__returned = p;
    }
  }
  async forceFetch(k, fetchOptions = {}) {
    const v = await this.fetch(k, fetchOptions);
    if (v === void 0)
      throw new Error("fetch() returned undefined");
    return v;
  }
  memo(k, memoOptions = {}) {
    const memoMethod = this.#memoMethod;
    if (!memoMethod) {
      throw new Error("no memoMethod provided to constructor");
    }
    const { context, forceRefresh, ...options } = memoOptions;
    const v = this.get(k, options);
    if (!forceRefresh && v !== void 0)
      return v;
    const vv = memoMethod(k, v, {
      options,
      context
    });
    this.set(k, vv, options);
    return vv;
  }
  /**
   * Return a value from the cache. Will update the recency of the cache
   * entry found.
   *
   * If the key is not found, get() will return `undefined`.
   */
  get(k, getOptions = {}) {
    const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
    const index = this.#keyMap.get(k);
    if (index !== void 0) {
      const value = this.#valList[index];
      const fetching = this.#isBackgroundFetch(value);
      if (status)
        this.#statusTTL(status, index);
      if (this.#isStale(index)) {
        if (status)
          status.get = "stale";
        if (!fetching) {
          if (!noDeleteOnStaleGet) {
            this.#delete(k, "expire");
          }
          if (status && allowStale)
            status.returnedStale = true;
          return allowStale ? value : void 0;
        } else {
          if (status && allowStale && value.__staleWhileFetching !== void 0) {
            status.returnedStale = true;
          }
          return allowStale ? value.__staleWhileFetching : void 0;
        }
      } else {
        if (status)
          status.get = "hit";
        if (fetching) {
          return value.__staleWhileFetching;
        }
        this.#moveToTail(index);
        if (updateAgeOnGet) {
          this.#updateItemAge(index);
        }
        return value;
      }
    } else if (status) {
      status.get = "miss";
    }
  }
  #connect(p, n) {
    this.#prev[n] = p;
    this.#next[p] = n;
  }
  #moveToTail(index) {
    if (index !== this.#tail) {
      if (index === this.#head) {
        this.#head = this.#next[index];
      } else {
        this.#connect(this.#prev[index], this.#next[index]);
      }
      this.#connect(this.#tail, index);
      this.#tail = index;
    }
  }
  /**
   * Deletes a key out of the cache.
   *
   * Returns true if the key was deleted, false otherwise.
   */
  delete(k) {
    return this.#delete(k, "delete");
  }
  #delete(k, reason) {
    let deleted = false;
    if (this.#size !== 0) {
      const index = this.#keyMap.get(k);
      if (index !== void 0) {
        deleted = true;
        if (this.#size === 1) {
          this.#clear(reason);
        } else {
          this.#removeItemSize(index);
          const v = this.#valList[index];
          if (this.#isBackgroundFetch(v)) {
            v.__abortController.abort(new Error("deleted"));
          } else if (this.#hasDispose || this.#hasDisposeAfter) {
            if (this.#hasDispose) {
              this.#dispose?.(v, k, reason);
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([v, k, reason]);
            }
          }
          this.#keyMap.delete(k);
          this.#keyList[index] = void 0;
          this.#valList[index] = void 0;
          if (index === this.#tail) {
            this.#tail = this.#prev[index];
          } else if (index === this.#head) {
            this.#head = this.#next[index];
          } else {
            const pi = this.#prev[index];
            this.#next[pi] = this.#next[index];
            const ni = this.#next[index];
            this.#prev[ni] = this.#prev[index];
          }
          this.#size--;
          this.#free.push(index);
        }
      }
    }
    if (this.#hasDisposeAfter && this.#disposed?.length) {
      const dt = this.#disposed;
      let task;
      while (task = dt?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
    return deleted;
  }
  /**
   * Clear the cache entirely, throwing away all values.
   */
  clear() {
    return this.#clear("delete");
  }
  #clear(reason) {
    for (const index of this.#rindexes({ allowStale: true })) {
      const v = this.#valList[index];
      if (this.#isBackgroundFetch(v)) {
        v.__abortController.abort(new Error("deleted"));
      } else {
        const k = this.#keyList[index];
        if (this.#hasDispose) {
          this.#dispose?.(v, k, reason);
        }
        if (this.#hasDisposeAfter) {
          this.#disposed?.push([v, k, reason]);
        }
      }
    }
    this.#keyMap.clear();
    this.#valList.fill(void 0);
    this.#keyList.fill(void 0);
    if (this.#ttls && this.#starts) {
      this.#ttls.fill(0);
      this.#starts.fill(0);
    }
    if (this.#sizes) {
      this.#sizes.fill(0);
    }
    this.#head = 0;
    this.#tail = 0;
    this.#free.length = 0;
    this.#calculatedSize = 0;
    this.#size = 0;
    if (this.#hasDisposeAfter && this.#disposed) {
      const dt = this.#disposed;
      let task;
      while (task = dt?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
  }
};

// ../../node_modules/.pnpm/path-scurry@2.0.0/node_modules/path-scurry/dist/esm/index.js
var import_node_path = require("node:path");
var import_node_url = require("node:url");
var import_fs = require("fs");
var actualFS = __toESM(require("node:fs"), 1);
var import_promises = require("node:fs/promises");

// ../../node_modules/.pnpm/minipass@7.1.2/node_modules/minipass/dist/esm/index.js
init_importMeta();
var import_node_events = require("node:events");
var import_node_stream = __toESM(require("node:stream"), 1);
var import_node_string_decoder = require("node:string_decoder");
var proc = typeof process === "object" && process ? process : {
  stdout: null,
  stderr: null
};
var isStream = (s) => !!s && typeof s === "object" && (s instanceof Minipass || s instanceof import_node_stream.default || isReadable(s) || isWritable(s));
var isReadable = (s) => !!s && typeof s === "object" && s instanceof import_node_events.EventEmitter && typeof s.pipe === "function" && // node core Writable streams have a pipe() method, but it throws
s.pipe !== import_node_stream.default.Writable.prototype.pipe;
var isWritable = (s) => !!s && typeof s === "object" && s instanceof import_node_events.EventEmitter && typeof s.write === "function" && typeof s.end === "function";
var EOF = Symbol("EOF");
var MAYBE_EMIT_END = Symbol("maybeEmitEnd");
var EMITTED_END = Symbol("emittedEnd");
var EMITTING_END = Symbol("emittingEnd");
var EMITTED_ERROR = Symbol("emittedError");
var CLOSED = Symbol("closed");
var READ = Symbol("read");
var FLUSH = Symbol("flush");
var FLUSHCHUNK = Symbol("flushChunk");
var ENCODING = Symbol("encoding");
var DECODER = Symbol("decoder");
var FLOWING = Symbol("flowing");
var PAUSED = Symbol("paused");
var RESUME = Symbol("resume");
var BUFFER = Symbol("buffer");
var PIPES = Symbol("pipes");
var BUFFERLENGTH = Symbol("bufferLength");
var BUFFERPUSH = Symbol("bufferPush");
var BUFFERSHIFT = Symbol("bufferShift");
var OBJECTMODE = Symbol("objectMode");
var DESTROYED = Symbol("destroyed");
var ERROR = Symbol("error");
var EMITDATA = Symbol("emitData");
var EMITEND = Symbol("emitEnd");
var EMITEND2 = Symbol("emitEnd2");
var ASYNC = Symbol("async");
var ABORT = Symbol("abort");
var ABORTED = Symbol("aborted");
var SIGNAL = Symbol("signal");
var DATALISTENERS = Symbol("dataListeners");
var DISCARDED = Symbol("discarded");
var defer = (fn) => Promise.resolve().then(fn);
var nodefer = (fn) => fn();
var isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
var isArrayBufferLike = (b) => b instanceof ArrayBuffer || !!b && typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0;
var isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
var Pipe = class {
  src;
  dest;
  opts;
  ondrain;
  constructor(src, dest, opts) {
    this.src = src;
    this.dest = dest;
    this.opts = opts;
    this.ondrain = () => src[RESUME]();
    this.dest.on("drain", this.ondrain);
  }
  unpipe() {
    this.dest.removeListener("drain", this.ondrain);
  }
  // only here for the prototype
  /* c8 ignore start */
  proxyErrors(_er) {
  }
  /* c8 ignore stop */
  end() {
    this.unpipe();
    if (this.opts.end)
      this.dest.end();
  }
};
var PipeProxyErrors = class extends Pipe {
  unpipe() {
    this.src.removeListener("error", this.proxyErrors);
    super.unpipe();
  }
  constructor(src, dest, opts) {
    super(src, dest, opts);
    this.proxyErrors = (er) => dest.emit("error", er);
    src.on("error", this.proxyErrors);
  }
};
var isObjectModeOptions = (o) => !!o.objectMode;
var isEncodingOptions = (o) => !o.objectMode && !!o.encoding && o.encoding !== "buffer";
var Minipass = class extends import_node_events.EventEmitter {
  [FLOWING] = false;
  [PAUSED] = false;
  [PIPES] = [];
  [BUFFER] = [];
  [OBJECTMODE];
  [ENCODING];
  [ASYNC];
  [DECODER];
  [EOF] = false;
  [EMITTED_END] = false;
  [EMITTING_END] = false;
  [CLOSED] = false;
  [EMITTED_ERROR] = null;
  [BUFFERLENGTH] = 0;
  [DESTROYED] = false;
  [SIGNAL];
  [ABORTED] = false;
  [DATALISTENERS] = 0;
  [DISCARDED] = false;
  /**
   * true if the stream can be written
   */
  writable = true;
  /**
   * true if the stream can be read
   */
  readable = true;
  /**
   * If `RType` is Buffer, then options do not need to be provided.
   * Otherwise, an options object must be provided to specify either
   * {@link Minipass.SharedOptions.objectMode} or
   * {@link Minipass.SharedOptions.encoding}, as appropriate.
   */
  constructor(...args) {
    const options = args[0] || {};
    super();
    if (options.objectMode && typeof options.encoding === "string") {
      throw new TypeError("Encoding and objectMode may not be used together");
    }
    if (isObjectModeOptions(options)) {
      this[OBJECTMODE] = true;
      this[ENCODING] = null;
    } else if (isEncodingOptions(options)) {
      this[ENCODING] = options.encoding;
      this[OBJECTMODE] = false;
    } else {
      this[OBJECTMODE] = false;
      this[ENCODING] = null;
    }
    this[ASYNC] = !!options.async;
    this[DECODER] = this[ENCODING] ? new import_node_string_decoder.StringDecoder(this[ENCODING]) : null;
    if (options && options.debugExposeBuffer === true) {
      Object.defineProperty(this, "buffer", { get: () => this[BUFFER] });
    }
    if (options && options.debugExposePipes === true) {
      Object.defineProperty(this, "pipes", { get: () => this[PIPES] });
    }
    const { signal } = options;
    if (signal) {
      this[SIGNAL] = signal;
      if (signal.aborted) {
        this[ABORT]();
      } else {
        signal.addEventListener("abort", () => this[ABORT]());
      }
    }
  }
  /**
   * The amount of data stored in the buffer waiting to be read.
   *
   * For Buffer strings, this will be the total byte length.
   * For string encoding streams, this will be the string character length,
   * according to JavaScript's `string.length` logic.
   * For objectMode streams, this is a count of the items waiting to be
   * emitted.
   */
  get bufferLength() {
    return this[BUFFERLENGTH];
  }
  /**
   * The `BufferEncoding` currently in use, or `null`
   */
  get encoding() {
    return this[ENCODING];
  }
  /**
   * @deprecated - This is a read only property
   */
  set encoding(_enc) {
    throw new Error("Encoding must be set at instantiation time");
  }
  /**
   * @deprecated - Encoding may only be set at instantiation time
   */
  setEncoding(_enc) {
    throw new Error("Encoding must be set at instantiation time");
  }
  /**
   * True if this is an objectMode stream
   */
  get objectMode() {
    return this[OBJECTMODE];
  }
  /**
   * @deprecated - This is a read-only property
   */
  set objectMode(_om) {
    throw new Error("objectMode must be set at instantiation time");
  }
  /**
   * true if this is an async stream
   */
  get ["async"]() {
    return this[ASYNC];
  }
  /**
   * Set to true to make this stream async.
   *
   * Once set, it cannot be unset, as this would potentially cause incorrect
   * behavior.  Ie, a sync stream can be made async, but an async stream
   * cannot be safely made sync.
   */
  set ["async"](a) {
    this[ASYNC] = this[ASYNC] || !!a;
  }
  // drop everything and get out of the flow completely
  [ABORT]() {
    this[ABORTED] = true;
    this.emit("abort", this[SIGNAL]?.reason);
    this.destroy(this[SIGNAL]?.reason);
  }
  /**
   * True if the stream has been aborted.
   */
  get aborted() {
    return this[ABORTED];
  }
  /**
   * No-op setter. Stream aborted status is set via the AbortSignal provided
   * in the constructor options.
   */
  set aborted(_) {
  }
  write(chunk, encoding, cb) {
    if (this[ABORTED])
      return false;
    if (this[EOF])
      throw new Error("write after end");
    if (this[DESTROYED]) {
      this.emit("error", Object.assign(new Error("Cannot call write after a stream was destroyed"), { code: "ERR_STREAM_DESTROYED" }));
      return true;
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = "utf8";
    }
    if (!encoding)
      encoding = "utf8";
    const fn = this[ASYNC] ? defer : nodefer;
    if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
      if (isArrayBufferView(chunk)) {
        chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
      } else if (isArrayBufferLike(chunk)) {
        chunk = Buffer.from(chunk);
      } else if (typeof chunk !== "string") {
        throw new Error("Non-contiguous data written to non-objectMode stream");
      }
    }
    if (this[OBJECTMODE]) {
      if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
        this[FLUSH](true);
      if (this[FLOWING])
        this.emit("data", chunk);
      else
        this[BUFFERPUSH](chunk);
      if (this[BUFFERLENGTH] !== 0)
        this.emit("readable");
      if (cb)
        fn(cb);
      return this[FLOWING];
    }
    if (!chunk.length) {
      if (this[BUFFERLENGTH] !== 0)
        this.emit("readable");
      if (cb)
        fn(cb);
      return this[FLOWING];
    }
    if (typeof chunk === "string" && // unless it is a string already ready for us to use
    !(encoding === this[ENCODING] && !this[DECODER]?.lastNeed)) {
      chunk = Buffer.from(chunk, encoding);
    }
    if (Buffer.isBuffer(chunk) && this[ENCODING]) {
      chunk = this[DECODER].write(chunk);
    }
    if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
      this[FLUSH](true);
    if (this[FLOWING])
      this.emit("data", chunk);
    else
      this[BUFFERPUSH](chunk);
    if (this[BUFFERLENGTH] !== 0)
      this.emit("readable");
    if (cb)
      fn(cb);
    return this[FLOWING];
  }
  /**
   * Low-level explicit read method.
   *
   * In objectMode, the argument is ignored, and one item is returned if
   * available.
   *
   * `n` is the number of bytes (or in the case of encoding streams,
   * characters) to consume. If `n` is not provided, then the entire buffer
   * is returned, or `null` is returned if no data is available.
   *
   * If `n` is greater that the amount of data in the internal buffer,
   * then `null` is returned.
   */
  read(n) {
    if (this[DESTROYED])
      return null;
    this[DISCARDED] = false;
    if (this[BUFFERLENGTH] === 0 || n === 0 || n && n > this[BUFFERLENGTH]) {
      this[MAYBE_EMIT_END]();
      return null;
    }
    if (this[OBJECTMODE])
      n = null;
    if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {
      this[BUFFER] = [
        this[ENCODING] ? this[BUFFER].join("") : Buffer.concat(this[BUFFER], this[BUFFERLENGTH])
      ];
    }
    const ret = this[READ](n || null, this[BUFFER][0]);
    this[MAYBE_EMIT_END]();
    return ret;
  }
  [READ](n, chunk) {
    if (this[OBJECTMODE])
      this[BUFFERSHIFT]();
    else {
      const c = chunk;
      if (n === c.length || n === null)
        this[BUFFERSHIFT]();
      else if (typeof c === "string") {
        this[BUFFER][0] = c.slice(n);
        chunk = c.slice(0, n);
        this[BUFFERLENGTH] -= n;
      } else {
        this[BUFFER][0] = c.subarray(n);
        chunk = c.subarray(0, n);
        this[BUFFERLENGTH] -= n;
      }
    }
    this.emit("data", chunk);
    if (!this[BUFFER].length && !this[EOF])
      this.emit("drain");
    return chunk;
  }
  end(chunk, encoding, cb) {
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = void 0;
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = "utf8";
    }
    if (chunk !== void 0)
      this.write(chunk, encoding);
    if (cb)
      this.once("end", cb);
    this[EOF] = true;
    this.writable = false;
    if (this[FLOWING] || !this[PAUSED])
      this[MAYBE_EMIT_END]();
    return this;
  }
  // don't let the internal resume be overwritten
  [RESUME]() {
    if (this[DESTROYED])
      return;
    if (!this[DATALISTENERS] && !this[PIPES].length) {
      this[DISCARDED] = true;
    }
    this[PAUSED] = false;
    this[FLOWING] = true;
    this.emit("resume");
    if (this[BUFFER].length)
      this[FLUSH]();
    else if (this[EOF])
      this[MAYBE_EMIT_END]();
    else
      this.emit("drain");
  }
  /**
   * Resume the stream if it is currently in a paused state
   *
   * If called when there are no pipe destinations or `data` event listeners,
   * this will place the stream in a "discarded" state, where all data will
   * be thrown away. The discarded state is removed if a pipe destination or
   * data handler is added, if pause() is called, or if any synchronous or
   * asynchronous iteration is started.
   */
  resume() {
    return this[RESUME]();
  }
  /**
   * Pause the stream
   */
  pause() {
    this[FLOWING] = false;
    this[PAUSED] = true;
    this[DISCARDED] = false;
  }
  /**
   * true if the stream has been forcibly destroyed
   */
  get destroyed() {
    return this[DESTROYED];
  }
  /**
   * true if the stream is currently in a flowing state, meaning that
   * any writes will be immediately emitted.
   */
  get flowing() {
    return this[FLOWING];
  }
  /**
   * true if the stream is currently in a paused state
   */
  get paused() {
    return this[PAUSED];
  }
  [BUFFERPUSH](chunk) {
    if (this[OBJECTMODE])
      this[BUFFERLENGTH] += 1;
    else
      this[BUFFERLENGTH] += chunk.length;
    this[BUFFER].push(chunk);
  }
  [BUFFERSHIFT]() {
    if (this[OBJECTMODE])
      this[BUFFERLENGTH] -= 1;
    else
      this[BUFFERLENGTH] -= this[BUFFER][0].length;
    return this[BUFFER].shift();
  }
  [FLUSH](noDrain = false) {
    do {
    } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) && this[BUFFER].length);
    if (!noDrain && !this[BUFFER].length && !this[EOF])
      this.emit("drain");
  }
  [FLUSHCHUNK](chunk) {
    this.emit("data", chunk);
    return this[FLOWING];
  }
  /**
   * Pipe all data emitted by this stream into the destination provided.
   *
   * Triggers the flow of data.
   */
  pipe(dest, opts) {
    if (this[DESTROYED])
      return dest;
    this[DISCARDED] = false;
    const ended = this[EMITTED_END];
    opts = opts || {};
    if (dest === proc.stdout || dest === proc.stderr)
      opts.end = false;
    else
      opts.end = opts.end !== false;
    opts.proxyErrors = !!opts.proxyErrors;
    if (ended) {
      if (opts.end)
        dest.end();
    } else {
      this[PIPES].push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));
      if (this[ASYNC])
        defer(() => this[RESUME]());
      else
        this[RESUME]();
    }
    return dest;
  }
  /**
   * Fully unhook a piped destination stream.
   *
   * If the destination stream was the only consumer of this stream (ie,
   * there are no other piped destinations or `'data'` event listeners)
   * then the flow of data will stop until there is another consumer or
   * {@link Minipass#resume} is explicitly called.
   */
  unpipe(dest) {
    const p = this[PIPES].find((p2) => p2.dest === dest);
    if (p) {
      if (this[PIPES].length === 1) {
        if (this[FLOWING] && this[DATALISTENERS] === 0) {
          this[FLOWING] = false;
        }
        this[PIPES] = [];
      } else
        this[PIPES].splice(this[PIPES].indexOf(p), 1);
      p.unpipe();
    }
  }
  /**
   * Alias for {@link Minipass#on}
   */
  addListener(ev, handler) {
    return this.on(ev, handler);
  }
  /**
   * Mostly identical to `EventEmitter.on`, with the following
   * behavior differences to prevent data loss and unnecessary hangs:
   *
   * - Adding a 'data' event handler will trigger the flow of data
   *
   * - Adding a 'readable' event handler when there is data waiting to be read
   *   will cause 'readable' to be emitted immediately.
   *
   * - Adding an 'endish' event handler ('end', 'finish', etc.) which has
   *   already passed will cause the event to be emitted immediately and all
   *   handlers removed.
   *
   * - Adding an 'error' event handler after an error has been emitted will
   *   cause the event to be re-emitted immediately with the error previously
   *   raised.
   */
  on(ev, handler) {
    const ret = super.on(ev, handler);
    if (ev === "data") {
      this[DISCARDED] = false;
      this[DATALISTENERS]++;
      if (!this[PIPES].length && !this[FLOWING]) {
        this[RESUME]();
      }
    } else if (ev === "readable" && this[BUFFERLENGTH] !== 0) {
      super.emit("readable");
    } else if (isEndish(ev) && this[EMITTED_END]) {
      super.emit(ev);
      this.removeAllListeners(ev);
    } else if (ev === "error" && this[EMITTED_ERROR]) {
      const h = handler;
      if (this[ASYNC])
        defer(() => h.call(this, this[EMITTED_ERROR]));
      else
        h.call(this, this[EMITTED_ERROR]);
    }
    return ret;
  }
  /**
   * Alias for {@link Minipass#off}
   */
  removeListener(ev, handler) {
    return this.off(ev, handler);
  }
  /**
   * Mostly identical to `EventEmitter.off`
   *
   * If a 'data' event handler is removed, and it was the last consumer
   * (ie, there are no pipe destinations or other 'data' event listeners),
   * then the flow of data will stop until there is another consumer or
   * {@link Minipass#resume} is explicitly called.
   */
  off(ev, handler) {
    const ret = super.off(ev, handler);
    if (ev === "data") {
      this[DATALISTENERS] = this.listeners("data").length;
      if (this[DATALISTENERS] === 0 && !this[DISCARDED] && !this[PIPES].length) {
        this[FLOWING] = false;
      }
    }
    return ret;
  }
  /**
   * Mostly identical to `EventEmitter.removeAllListeners`
   *
   * If all 'data' event handlers are removed, and they were the last consumer
   * (ie, there are no pipe destinations), then the flow of data will stop
   * until there is another consumer or {@link Minipass#resume} is explicitly
   * called.
   */
  removeAllListeners(ev) {
    const ret = super.removeAllListeners(ev);
    if (ev === "data" || ev === void 0) {
      this[DATALISTENERS] = 0;
      if (!this[DISCARDED] && !this[PIPES].length) {
        this[FLOWING] = false;
      }
    }
    return ret;
  }
  /**
   * true if the 'end' event has been emitted
   */
  get emittedEnd() {
    return this[EMITTED_END];
  }
  [MAYBE_EMIT_END]() {
    if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this[BUFFER].length === 0 && this[EOF]) {
      this[EMITTING_END] = true;
      this.emit("end");
      this.emit("prefinish");
      this.emit("finish");
      if (this[CLOSED])
        this.emit("close");
      this[EMITTING_END] = false;
    }
  }
  /**
   * Mostly identical to `EventEmitter.emit`, with the following
   * behavior differences to prevent data loss and unnecessary hangs:
   *
   * If the stream has been destroyed, and the event is something other
   * than 'close' or 'error', then `false` is returned and no handlers
   * are called.
   *
   * If the event is 'end', and has already been emitted, then the event
   * is ignored. If the stream is in a paused or non-flowing state, then
   * the event will be deferred until data flow resumes. If the stream is
   * async, then handlers will be called on the next tick rather than
   * immediately.
   *
   * If the event is 'close', and 'end' has not yet been emitted, then
   * the event will be deferred until after 'end' is emitted.
   *
   * If the event is 'error', and an AbortSignal was provided for the stream,
   * and there are no listeners, then the event is ignored, matching the
   * behavior of node core streams in the presense of an AbortSignal.
   *
   * If the event is 'finish' or 'prefinish', then all listeners will be
   * removed after emitting the event, to prevent double-firing.
   */
  emit(ev, ...args) {
    const data = args[0];
    if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED]) {
      return false;
    } else if (ev === "data") {
      return !this[OBJECTMODE] && !data ? false : this[ASYNC] ? (defer(() => this[EMITDATA](data)), true) : this[EMITDATA](data);
    } else if (ev === "end") {
      return this[EMITEND]();
    } else if (ev === "close") {
      this[CLOSED] = true;
      if (!this[EMITTED_END] && !this[DESTROYED])
        return false;
      const ret2 = super.emit("close");
      this.removeAllListeners("close");
      return ret2;
    } else if (ev === "error") {
      this[EMITTED_ERROR] = data;
      super.emit(ERROR, data);
      const ret2 = !this[SIGNAL] || this.listeners("error").length ? super.emit("error", data) : false;
      this[MAYBE_EMIT_END]();
      return ret2;
    } else if (ev === "resume") {
      const ret2 = super.emit("resume");
      this[MAYBE_EMIT_END]();
      return ret2;
    } else if (ev === "finish" || ev === "prefinish") {
      const ret2 = super.emit(ev);
      this.removeAllListeners(ev);
      return ret2;
    }
    const ret = super.emit(ev, ...args);
    this[MAYBE_EMIT_END]();
    return ret;
  }
  [EMITDATA](data) {
    for (const p of this[PIPES]) {
      if (p.dest.write(data) === false)
        this.pause();
    }
    const ret = this[DISCARDED] ? false : super.emit("data", data);
    this[MAYBE_EMIT_END]();
    return ret;
  }
  [EMITEND]() {
    if (this[EMITTED_END])
      return false;
    this[EMITTED_END] = true;
    this.readable = false;
    return this[ASYNC] ? (defer(() => this[EMITEND2]()), true) : this[EMITEND2]();
  }
  [EMITEND2]() {
    if (this[DECODER]) {
      const data = this[DECODER].end();
      if (data) {
        for (const p of this[PIPES]) {
          p.dest.write(data);
        }
        if (!this[DISCARDED])
          super.emit("data", data);
      }
    }
    for (const p of this[PIPES]) {
      p.end();
    }
    const ret = super.emit("end");
    this.removeAllListeners("end");
    return ret;
  }
  /**
   * Return a Promise that resolves to an array of all emitted data once
   * the stream ends.
   */
  async collect() {
    const buf = Object.assign([], {
      dataLength: 0
    });
    if (!this[OBJECTMODE])
      buf.dataLength = 0;
    const p = this.promise();
    this.on("data", (c) => {
      buf.push(c);
      if (!this[OBJECTMODE])
        buf.dataLength += c.length;
    });
    await p;
    return buf;
  }
  /**
   * Return a Promise that resolves to the concatenation of all emitted data
   * once the stream ends.
   *
   * Not allowed on objectMode streams.
   */
  async concat() {
    if (this[OBJECTMODE]) {
      throw new Error("cannot concat in objectMode");
    }
    const buf = await this.collect();
    return this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength);
  }
  /**
   * Return a void Promise that resolves once the stream ends.
   */
  async promise() {
    return new Promise((resolve, reject) => {
      this.on(DESTROYED, () => reject(new Error("stream destroyed")));
      this.on("error", (er) => reject(er));
      this.on("end", () => resolve());
    });
  }
  /**
   * Asynchronous `for await of` iteration.
   *
   * This will continue emitting all chunks until the stream terminates.
   */
  [Symbol.asyncIterator]() {
    this[DISCARDED] = false;
    let stopped = false;
    const stop = async () => {
      this.pause();
      stopped = true;
      return { value: void 0, done: true };
    };
    const next = () => {
      if (stopped)
        return stop();
      const res = this.read();
      if (res !== null)
        return Promise.resolve({ done: false, value: res });
      if (this[EOF])
        return stop();
      let resolve;
      let reject;
      const onerr = (er) => {
        this.off("data", ondata);
        this.off("end", onend);
        this.off(DESTROYED, ondestroy);
        stop();
        reject(er);
      };
      const ondata = (value) => {
        this.off("error", onerr);
        this.off("end", onend);
        this.off(DESTROYED, ondestroy);
        this.pause();
        resolve({ value, done: !!this[EOF] });
      };
      const onend = () => {
        this.off("error", onerr);
        this.off("data", ondata);
        this.off(DESTROYED, ondestroy);
        stop();
        resolve({ done: true, value: void 0 });
      };
      const ondestroy = () => onerr(new Error("stream destroyed"));
      return new Promise((res2, rej) => {
        reject = rej;
        resolve = res2;
        this.once(DESTROYED, ondestroy);
        this.once("error", onerr);
        this.once("end", onend);
        this.once("data", ondata);
      });
    };
    return {
      next,
      throw: stop,
      return: stop,
      [Symbol.asyncIterator]() {
        return this;
      }
    };
  }
  /**
   * Synchronous `for of` iteration.
   *
   * The iteration will terminate when the internal buffer runs out, even
   * if the stream has not yet terminated.
   */
  [Symbol.iterator]() {
    this[DISCARDED] = false;
    let stopped = false;
    const stop = () => {
      this.pause();
      this.off(ERROR, stop);
      this.off(DESTROYED, stop);
      this.off("end", stop);
      stopped = true;
      return { done: true, value: void 0 };
    };
    const next = () => {
      if (stopped)
        return stop();
      const value = this.read();
      return value === null ? stop() : { done: false, value };
    };
    this.once("end", stop);
    this.once(ERROR, stop);
    this.once(DESTROYED, stop);
    return {
      next,
      throw: stop,
      return: stop,
      [Symbol.iterator]() {
        return this;
      }
    };
  }
  /**
   * Destroy a stream, preventing it from being used for any further purpose.
   *
   * If the stream has a `close()` method, then it will be called on
   * destruction.
   *
   * After destruction, any attempt to write data, read data, or emit most
   * events will be ignored.
   *
   * If an error argument is provided, then it will be emitted in an
   * 'error' event.
   */
  destroy(er) {
    if (this[DESTROYED]) {
      if (er)
        this.emit("error", er);
      else
        this.emit(DESTROYED);
      return this;
    }
    this[DESTROYED] = true;
    this[DISCARDED] = true;
    this[BUFFER].length = 0;
    this[BUFFERLENGTH] = 0;
    const wc = this;
    if (typeof wc.close === "function" && !this[CLOSED])
      wc.close();
    if (er)
      this.emit("error", er);
    else
      this.emit(DESTROYED);
    return this;
  }
  /**
   * Alias for {@link isStream}
   *
   * Former export location, maintained for backwards compatibility.
   *
   * @deprecated
   */
  static get isStream() {
    return isStream;
  }
};

// ../../node_modules/.pnpm/path-scurry@2.0.0/node_modules/path-scurry/dist/esm/index.js
var realpathSync = import_fs.realpathSync.native;
var defaultFS = {
  lstatSync: import_fs.lstatSync,
  readdir: import_fs.readdir,
  readdirSync: import_fs.readdirSync,
  readlinkSync: import_fs.readlinkSync,
  realpathSync,
  promises: {
    lstat: import_promises.lstat,
    readdir: import_promises.readdir,
    readlink: import_promises.readlink,
    realpath: import_promises.realpath
  }
};
var fsFromOption = (fsOption) => !fsOption || fsOption === defaultFS || fsOption === actualFS ? defaultFS : {
  ...defaultFS,
  ...fsOption,
  promises: {
    ...defaultFS.promises,
    ...fsOption.promises || {}
  }
};
var uncDriveRegexp = /^\\\\\?\\([a-z]:)\\?$/i;
var uncToDrive = (rootPath) => rootPath.replace(/\//g, "\\").replace(uncDriveRegexp, "$1\\");
var eitherSep = /[\\\/]/;
var UNKNOWN = 0;
var IFIFO = 1;
var IFCHR = 2;
var IFDIR = 4;
var IFBLK = 6;
var IFREG = 8;
var IFLNK = 10;
var IFSOCK = 12;
var IFMT = 15;
var IFMT_UNKNOWN = ~IFMT;
var READDIR_CALLED = 16;
var LSTAT_CALLED = 32;
var ENOTDIR = 64;
var ENOENT = 128;
var ENOREADLINK = 256;
var ENOREALPATH = 512;
var ENOCHILD = ENOTDIR | ENOENT | ENOREALPATH;
var TYPEMASK = 1023;
var entToType = (s) => s.isFile() ? IFREG : s.isDirectory() ? IFDIR : s.isSymbolicLink() ? IFLNK : s.isCharacterDevice() ? IFCHR : s.isBlockDevice() ? IFBLK : s.isSocket() ? IFSOCK : s.isFIFO() ? IFIFO : UNKNOWN;
var normalizeCache = /* @__PURE__ */ new Map();
var normalize = (s) => {
  const c = normalizeCache.get(s);
  if (c)
    return c;
  const n = s.normalize("NFKD");
  normalizeCache.set(s, n);
  return n;
};
var normalizeNocaseCache = /* @__PURE__ */ new Map();
var normalizeNocase = (s) => {
  const c = normalizeNocaseCache.get(s);
  if (c)
    return c;
  const n = normalize(s.toLowerCase());
  normalizeNocaseCache.set(s, n);
  return n;
};
var ResolveCache = class extends LRUCache {
  constructor() {
    super({ max: 256 });
  }
};
var ChildrenCache = class extends LRUCache {
  constructor(maxSize = 16 * 1024) {
    super({
      maxSize,
      // parent + children
      sizeCalculation: (a) => a.length + 1
    });
  }
};
var setAsCwd = Symbol("PathScurry setAsCwd");
var PathBase = class {
  /**
   * the basename of this path
   *
   * **Important**: *always* test the path name against any test string
   * usingthe {@link isNamed} method, and not by directly comparing this
   * string. Otherwise, unicode path strings that the system sees as identical
   * will not be properly treated as the same path, leading to incorrect
   * behavior and possible security issues.
   */
  name;
  /**
   * the Path entry corresponding to the path root.
   *
   * @internal
   */
  root;
  /**
   * All roots found within the current PathScurry family
   *
   * @internal
   */
  roots;
  /**
   * a reference to the parent path, or undefined in the case of root entries
   *
   * @internal
   */
  parent;
  /**
   * boolean indicating whether paths are compared case-insensitively
   * @internal
   */
  nocase;
  /**
   * boolean indicating that this path is the current working directory
   * of the PathScurry collection that contains it.
   */
  isCWD = false;
  // potential default fs override
  #fs;
  // Stats fields
  #dev;
  get dev() {
    return this.#dev;
  }
  #mode;
  get mode() {
    return this.#mode;
  }
  #nlink;
  get nlink() {
    return this.#nlink;
  }
  #uid;
  get uid() {
    return this.#uid;
  }
  #gid;
  get gid() {
    return this.#gid;
  }
  #rdev;
  get rdev() {
    return this.#rdev;
  }
  #blksize;
  get blksize() {
    return this.#blksize;
  }
  #ino;
  get ino() {
    return this.#ino;
  }
  #size;
  get size() {
    return this.#size;
  }
  #blocks;
  get blocks() {
    return this.#blocks;
  }
  #atimeMs;
  get atimeMs() {
    return this.#atimeMs;
  }
  #mtimeMs;
  get mtimeMs() {
    return this.#mtimeMs;
  }
  #ctimeMs;
  get ctimeMs() {
    return this.#ctimeMs;
  }
  #birthtimeMs;
  get birthtimeMs() {
    return this.#birthtimeMs;
  }
  #atime;
  get atime() {
    return this.#atime;
  }
  #mtime;
  get mtime() {
    return this.#mtime;
  }
  #ctime;
  get ctime() {
    return this.#ctime;
  }
  #birthtime;
  get birthtime() {
    return this.#birthtime;
  }
  #matchName;
  #depth;
  #fullpath;
  #fullpathPosix;
  #relative;
  #relativePosix;
  #type;
  #children;
  #linkTarget;
  #realpath;
  /**
   * This property is for compatibility with the Dirent class as of
   * Node v20, where Dirent['parentPath'] refers to the path of the
   * directory that was passed to readdir. For root entries, it's the path
   * to the entry itself.
   */
  get parentPath() {
    return (this.parent || this).fullpath();
  }
  /**
   * Deprecated alias for Dirent['parentPath'] Somewhat counterintuitively,
   * this property refers to the *parent* path, not the path object itself.
   *
   * @deprecated
   */
  get path() {
    return this.parentPath;
  }
  /**
   * Do not create new Path objects directly.  They should always be accessed
   * via the PathScurry class or other methods on the Path class.
   *
   * @internal
   */
  constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {
    this.name = name;
    this.#matchName = nocase ? normalizeNocase(name) : normalize(name);
    this.#type = type & TYPEMASK;
    this.nocase = nocase;
    this.roots = roots;
    this.root = root || this;
    this.#children = children;
    this.#fullpath = opts.fullpath;
    this.#relative = opts.relative;
    this.#relativePosix = opts.relativePosix;
    this.parent = opts.parent;
    if (this.parent) {
      this.#fs = this.parent.#fs;
    } else {
      this.#fs = fsFromOption(opts.fs);
    }
  }
  /**
   * Returns the depth of the Path object from its root.
   *
   * For example, a path at `/foo/bar` would have a depth of 2.
   */
  depth() {
    if (this.#depth !== void 0)
      return this.#depth;
    if (!this.parent)
      return this.#depth = 0;
    return this.#depth = this.parent.depth() + 1;
  }
  /**
   * @internal
   */
  childrenCache() {
    return this.#children;
  }
  /**
   * Get the Path object referenced by the string path, resolved from this Path
   */
  resolve(path2) {
    if (!path2) {
      return this;
    }
    const rootPath = this.getRootString(path2);
    const dir = path2.substring(rootPath.length);
    const dirParts = dir.split(this.splitSep);
    const result = rootPath ? this.getRoot(rootPath).#resolveParts(dirParts) : this.#resolveParts(dirParts);
    return result;
  }
  #resolveParts(dirParts) {
    let p = this;
    for (const part of dirParts) {
      p = p.child(part);
    }
    return p;
  }
  /**
   * Returns the cached children Path objects, if still available.  If they
   * have fallen out of the cache, then returns an empty array, and resets the
   * READDIR_CALLED bit, so that future calls to readdir() will require an fs
   * lookup.
   *
   * @internal
   */
  children() {
    const cached = this.#children.get(this);
    if (cached) {
      return cached;
    }
    const children = Object.assign([], { provisional: 0 });
    this.#children.set(this, children);
    this.#type &= ~READDIR_CALLED;
    return children;
  }
  /**
   * Resolves a path portion and returns or creates the child Path.
   *
   * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is
   * `'..'`.
   *
   * This should not be called directly.  If `pathPart` contains any path
   * separators, it will lead to unsafe undefined behavior.
   *
   * Use `Path.resolve()` instead.
   *
   * @internal
   */
  child(pathPart, opts) {
    if (pathPart === "" || pathPart === ".") {
      return this;
    }
    if (pathPart === "..") {
      return this.parent || this;
    }
    const children = this.children();
    const name = this.nocase ? normalizeNocase(pathPart) : normalize(pathPart);
    for (const p of children) {
      if (p.#matchName === name) {
        return p;
      }
    }
    const s = this.parent ? this.sep : "";
    const fullpath = this.#fullpath ? this.#fullpath + s + pathPart : void 0;
    const pchild = this.newChild(pathPart, UNKNOWN, {
      ...opts,
      parent: this,
      fullpath
    });
    if (!this.canReaddir()) {
      pchild.#type |= ENOENT;
    }
    children.push(pchild);
    return pchild;
  }
  /**
   * The relative path from the cwd. If it does not share an ancestor with
   * the cwd, then this ends up being equivalent to the fullpath()
   */
  relative() {
    if (this.isCWD)
      return "";
    if (this.#relative !== void 0) {
      return this.#relative;
    }
    const name = this.name;
    const p = this.parent;
    if (!p) {
      return this.#relative = this.name;
    }
    const pv = p.relative();
    return pv + (!pv || !p.parent ? "" : this.sep) + name;
  }
  /**
   * The relative path from the cwd, using / as the path separator.
   * If it does not share an ancestor with
   * the cwd, then this ends up being equivalent to the fullpathPosix()
   * On posix systems, this is identical to relative().
   */
  relativePosix() {
    if (this.sep === "/")
      return this.relative();
    if (this.isCWD)
      return "";
    if (this.#relativePosix !== void 0)
      return this.#relativePosix;
    const name = this.name;
    const p = this.parent;
    if (!p) {
      return this.#relativePosix = this.fullpathPosix();
    }
    const pv = p.relativePosix();
    return pv + (!pv || !p.parent ? "" : "/") + name;
  }
  /**
   * The fully resolved path string for this Path entry
   */
  fullpath() {
    if (this.#fullpath !== void 0) {
      return this.#fullpath;
    }
    const name = this.name;
    const p = this.parent;
    if (!p) {
      return this.#fullpath = this.name;
    }
    const pv = p.fullpath();
    const fp = pv + (!p.parent ? "" : this.sep) + name;
    return this.#fullpath = fp;
  }
  /**
   * On platforms other than windows, this is identical to fullpath.
   *
   * On windows, this is overridden to return the forward-slash form of the
   * full UNC path.
   */
  fullpathPosix() {
    if (this.#fullpathPosix !== void 0)
      return this.#fullpathPosix;
    if (this.sep === "/")
      return this.#fullpathPosix = this.fullpath();
    if (!this.parent) {
      const p2 = this.fullpath().replace(/\\/g, "/");
      if (/^[a-z]:\//i.test(p2)) {
        return this.#fullpathPosix = `//?/${p2}`;
      } else {
        return this.#fullpathPosix = p2;
      }
    }
    const p = this.parent;
    const pfpp = p.fullpathPosix();
    const fpp = pfpp + (!pfpp || !p.parent ? "" : "/") + this.name;
    return this.#fullpathPosix = fpp;
  }
  /**
   * Is the Path of an unknown type?
   *
   * Note that we might know *something* about it if there has been a previous
   * filesystem operation, for example that it does not exist, or is not a
   * link, or whether it has child entries.
   */
  isUnknown() {
    return (this.#type & IFMT) === UNKNOWN;
  }
  isType(type) {
    return this[`is${type}`]();
  }
  getType() {
    return this.isUnknown() ? "Unknown" : this.isDirectory() ? "Directory" : this.isFile() ? "File" : this.isSymbolicLink() ? "SymbolicLink" : this.isFIFO() ? "FIFO" : this.isCharacterDevice() ? "CharacterDevice" : this.isBlockDevice() ? "BlockDevice" : (
      /* c8 ignore start */
      this.isSocket() ? "Socket" : "Unknown"
    );
  }
  /**
   * Is the Path a regular file?
   */
  isFile() {
    return (this.#type & IFMT) === IFREG;
  }
  /**
   * Is the Path a directory?
   */
  isDirectory() {
    return (this.#type & IFMT) === IFDIR;
  }
  /**
   * Is the path a character device?
   */
  isCharacterDevice() {
    return (this.#type & IFMT) === IFCHR;
  }
  /**
   * Is the path a block device?
   */
  isBlockDevice() {
    return (this.#type & IFMT) === IFBLK;
  }
  /**
   * Is the path a FIFO pipe?
   */
  isFIFO() {
    return (this.#type & IFMT) === IFIFO;
  }
  /**
   * Is the path a socket?
   */
  isSocket() {
    return (this.#type & IFMT) === IFSOCK;
  }
  /**
   * Is the path a symbolic link?
   */
  isSymbolicLink() {
    return (this.#type & IFLNK) === IFLNK;
  }
  /**
   * Return the entry if it has been subject of a successful lstat, or
   * undefined otherwise.
   *
   * Does not read the filesystem, so an undefined result *could* simply
   * mean that we haven't called lstat on it.
   */
  lstatCached() {
    return this.#type & LSTAT_CALLED ? this : void 0;
  }
  /**
   * Return the cached link target if the entry has been the subject of a
   * successful readlink, or undefined otherwise.
   *
   * Does not read the filesystem, so an undefined result *could* just mean we
   * don't have any cached data. Only use it if you are very sure that a
   * readlink() has been called at some point.
   */
  readlinkCached() {
    return this.#linkTarget;
  }
  /**
   * Returns the cached realpath target if the entry has been the subject
   * of a successful realpath, or undefined otherwise.
   *
   * Does not read the filesystem, so an undefined result *could* just mean we
   * don't have any cached data. Only use it if you are very sure that a
   * realpath() has been called at some point.
   */
  realpathCached() {
    return this.#realpath;
  }
  /**
   * Returns the cached child Path entries array if the entry has been the
   * subject of a successful readdir(), or [] otherwise.
   *
   * Does not read the filesystem, so an empty array *could* just mean we
   * don't have any cached data. Only use it if you are very sure that a
   * readdir() has been called recently enough to still be valid.
   */
  readdirCached() {
    const children = this.children();
    return children.slice(0, children.provisional);
  }
  /**
   * Return true if it's worth trying to readlink.  Ie, we don't (yet) have
   * any indication that readlink will definitely fail.
   *
   * Returns false if the path is known to not be a symlink, if a previous
   * readlink failed, or if the entry does not exist.
   */
  canReadlink() {
    if (this.#linkTarget)
      return true;
    if (!this.parent)
      return false;
    const ifmt = this.#type & IFMT;
    return !(ifmt !== UNKNOWN && ifmt !== IFLNK || this.#type & ENOREADLINK || this.#type & ENOENT);
  }
  /**
   * Return true if readdir has previously been successfully called on this
   * path, indicating that cachedReaddir() is likely valid.
   */
  calledReaddir() {
    return !!(this.#type & READDIR_CALLED);
  }
  /**
   * Returns true if the path is known to not exist. That is, a previous lstat
   * or readdir failed to verify its existence when that would have been
   * expected, or a parent entry was marked either enoent or enotdir.
   */
  isENOENT() {
    return !!(this.#type & ENOENT);
  }
  /**
   * Return true if the path is a match for the given path name.  This handles
   * case sensitivity and unicode normalization.
   *
   * Note: even on case-sensitive systems, it is **not** safe to test the
   * equality of the `.name` property to determine whether a given pathname
   * matches, due to unicode normalization mismatches.
   *
   * Always use this method instead of testing the `path.name` property
   * directly.
   */
  isNamed(n) {
    return !this.nocase ? this.#matchName === normalize(n) : this.#matchName === normalizeNocase(n);
  }
  /**
   * Return the Path object corresponding to the target of a symbolic link.
   *
   * If the Path is not a symbolic link, or if the readlink call fails for any
   * reason, `undefined` is returned.
   *
   * Result is cached, and thus may be outdated if the filesystem is mutated.
   */
  async readlink() {
    const target = this.#linkTarget;
    if (target) {
      return target;
    }
    if (!this.canReadlink()) {
      return void 0;
    }
    if (!this.parent) {
      return void 0;
    }
    try {
      const read = await this.#fs.promises.readlink(this.fullpath());
      const linkTarget = (await this.parent.realpath())?.resolve(read);
      if (linkTarget) {
        return this.#linkTarget = linkTarget;
      }
    } catch (er) {
      this.#readlinkFail(er.code);
      return void 0;
    }
  }
  /**
   * Synchronous {@link PathBase.readlink}
   */
  readlinkSync() {
    const target = this.#linkTarget;
    if (target) {
      return target;
    }
    if (!this.canReadlink()) {
      return void 0;
    }
    if (!this.parent) {
      return void 0;
    }
    try {
      const read = this.#fs.readlinkSync(this.fullpath());
      const linkTarget = this.parent.realpathSync()?.resolve(read);
      if (linkTarget) {
        return this.#linkTarget = linkTarget;
      }
    } catch (er) {
      this.#readlinkFail(er.code);
      return void 0;
    }
  }
  #readdirSuccess(children) {
    this.#type |= READDIR_CALLED;
    for (let p = children.provisional; p < children.length; p++) {
      const c = children[p];
      if (c)
        c.#markENOENT();
    }
  }
  #markENOENT() {
    if (this.#type & ENOENT)
      return;
    this.#type = (this.#type | ENOENT) & IFMT_UNKNOWN;
    this.#markChildrenENOENT();
  }
  #markChildrenENOENT() {
    const children = this.children();
    children.provisional = 0;
    for (const p of children) {
      p.#markENOENT();
    }
  }
  #markENOREALPATH() {
    this.#type |= ENOREALPATH;
    this.#markENOTDIR();
  }
  // save the information when we know the entry is not a dir
  #markENOTDIR() {
    if (this.#type & ENOTDIR)
      return;
    let t = this.#type;
    if ((t & IFMT) === IFDIR)
      t &= IFMT_UNKNOWN;
    this.#type = t | ENOTDIR;
    this.#markChildrenENOENT();
  }
  #readdirFail(code = "") {
    if (code === "ENOTDIR" || code === "EPERM") {
      this.#markENOTDIR();
    } else if (code === "ENOENT") {
      this.#markENOENT();
    } else {
      this.children().provisional = 0;
    }
  }
  #lstatFail(code = "") {
    if (code === "ENOTDIR") {
      const p = this.parent;
      p.#markENOTDIR();
    } else if (code === "ENOENT") {
      this.#markENOENT();
    }
  }
  #readlinkFail(code = "") {
    let ter = this.#type;
    ter |= ENOREADLINK;
    if (code === "ENOENT")
      ter |= ENOENT;
    if (code === "EINVAL" || code === "UNKNOWN") {
      ter &= IFMT_UNKNOWN;
    }
    this.#type = ter;
    if (code === "ENOTDIR" && this.parent) {
      this.parent.#markENOTDIR();
    }
  }
  #readdirAddChild(e, c) {
    return this.#readdirMaybePromoteChild(e, c) || this.#readdirAddNewChild(e, c);
  }
  #readdirAddNewChild(e, c) {
    const type = entToType(e);
    const child = this.newChild(e.name, type, { parent: this });
    const ifmt = child.#type & IFMT;
    if (ifmt !== IFDIR && ifmt !== IFLNK && ifmt !== UNKNOWN) {
      child.#type |= ENOTDIR;
    }
    c.unshift(child);
    c.provisional++;
    return child;
  }
  #readdirMaybePromoteChild(e, c) {
    for (let p = c.provisional; p < c.length; p++) {
      const pchild = c[p];
      const name = this.nocase ? normalizeNocase(e.name) : normalize(e.name);
      if (name !== pchild.#matchName) {
        continue;
      }
      return this.#readdirPromoteChild(e, pchild, p, c);
    }
  }
  #readdirPromoteChild(e, p, index, c) {
    const v = p.name;
    p.#type = p.#type & IFMT_UNKNOWN | entToType(e);
    if (v !== e.name)
      p.name = e.name;
    if (index !== c.provisional) {
      if (index === c.length - 1)
        c.pop();
      else
        c.splice(index, 1);
      c.unshift(p);
    }
    c.provisional++;
    return p;
  }
  /**
   * Call lstat() on this Path, and update all known information that can be
   * determined.
   *
   * Note that unlike `fs.lstat()`, the returned value does not contain some
   * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
   * information is required, you will need to call `fs.lstat` yourself.
   *
   * If the Path refers to a nonexistent file, or if the lstat call fails for
   * any reason, `undefined` is returned.  Otherwise the updated Path object is
   * returned.
   *
   * Results are cached, and thus may be out of date if the filesystem is
   * mutated.
   */
  async lstat() {
    if ((this.#type & ENOENT) === 0) {
      try {
        this.#applyStat(await this.#fs.promises.lstat(this.fullpath()));
        return this;
      } catch (er) {
        this.#lstatFail(er.code);
      }
    }
  }
  /**
   * synchronous {@link PathBase.lstat}
   */
  lstatSync() {
    if ((this.#type & ENOENT) === 0) {
      try {
        this.#applyStat(this.#fs.lstatSync(this.fullpath()));
        return this;
      } catch (er) {
        this.#lstatFail(er.code);
      }
    }
  }
  #applyStat(st) {
    const { atime, atimeMs, birthtime, birthtimeMs, blksize, blocks, ctime, ctimeMs, dev, gid, ino, mode, mtime, mtimeMs, nlink, rdev, size, uid } = st;
    this.#atime = atime;
    this.#atimeMs = atimeMs;
    this.#birthtime = birthtime;
    this.#birthtimeMs = birthtimeMs;
    this.#blksize = blksize;
    this.#blocks = blocks;
    this.#ctime = ctime;
    this.#ctimeMs = ctimeMs;
    this.#dev = dev;
    this.#gid = gid;
    this.#ino = ino;
    this.#mode = mode;
    this.#mtime = mtime;
    this.#mtimeMs = mtimeMs;
    this.#nlink = nlink;
    this.#rdev = rdev;
    this.#size = size;
    this.#uid = uid;
    const ifmt = entToType(st);
    this.#type = this.#type & IFMT_UNKNOWN | ifmt | LSTAT_CALLED;
    if (ifmt !== UNKNOWN && ifmt !== IFDIR && ifmt !== IFLNK) {
      this.#type |= ENOTDIR;
    }
  }
  #onReaddirCB = [];
  #readdirCBInFlight = false;
  #callOnReaddirCB(children) {
    this.#readdirCBInFlight = false;
    const cbs = this.#onReaddirCB.slice();
    this.#onReaddirCB.length = 0;
    cbs.forEach((cb) => cb(null, children));
  }
  /**
   * Standard node-style callback interface to get list of directory entries.
   *
   * If the Path cannot or does not contain any children, then an empty array
   * is returned.
   *
   * Results are cached, and thus may be out of date if the filesystem is
   * mutated.
   *
   * @param cb The callback called with (er, entries).  Note that the `er`
   * param is somewhat extraneous, as all readdir() errors are handled and
   * simply result in an empty set of entries being returned.
   * @param allowZalgo Boolean indicating that immediately known results should
   * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release
   * zalgo at your peril, the dark pony lord is devious and unforgiving.
   */
  readdirCB(cb, allowZalgo = false) {
    if (!this.canReaddir()) {
      if (allowZalgo)
        cb(null, []);
      else
        queueMicrotask(() => cb(null, []));
      return;
    }
    const children = this.children();
    if (this.calledReaddir()) {
      const c = children.slice(0, children.provisional);
      if (allowZalgo)
        cb(null, c);
      else
        queueMicrotask(() => cb(null, c));
      return;
    }
    this.#onReaddirCB.push(cb);
    if (this.#readdirCBInFlight) {
      return;
    }
    this.#readdirCBInFlight = true;
    const fullpath = this.fullpath();
    this.#fs.readdir(fullpath, { withFileTypes: true }, (er, entries) => {
      if (er) {
        this.#readdirFail(er.code);
        children.provisional = 0;
      } else {
        for (const e of entries) {
          this.#readdirAddChild(e, children);
        }
        this.#readdirSuccess(children);
      }
      this.#callOnReaddirCB(children.slice(0, children.provisional));
      return;
    });
  }
  #asyncReaddirInFlight;
  /**
   * Return an array of known child entries.
   *
   * If the Path cannot or does not contain any children, then an empty array
   * is returned.
   *
   * Results are cached, and thus may be out of date if the filesystem is
   * mutated.
   */
  async readdir() {
    if (!this.canReaddir()) {
      return [];
    }
    const children = this.children();
    if (this.calledReaddir()) {
      return children.slice(0, children.provisional);
    }
    const fullpath = this.fullpath();
    if (this.#asyncReaddirInFlight) {
      await this.#asyncReaddirInFlight;
    } else {
      let resolve = () => {
      };
      this.#asyncReaddirInFlight = new Promise((res) => resolve = res);
      try {
        for (const e of await this.#fs.promises.readdir(fullpath, {
          withFileTypes: true
        })) {
          this.#readdirAddChild(e, children);
        }
        this.#readdirSuccess(children);
      } catch (er) {
        this.#readdirFail(er.code);
        children.provisional = 0;
      }
      this.#asyncReaddirInFlight = void 0;
      resolve();
    }
    return children.slice(0, children.provisional);
  }
  /**
   * synchronous {@link PathBase.readdir}
   */
  readdirSync() {
    if (!this.canReaddir()) {
      return [];
    }
    const children = this.children();
    if (this.calledReaddir()) {
      return children.slice(0, children.provisional);
    }
    const fullpath = this.fullpath();
    try {
      for (const e of this.#fs.readdirSync(fullpath, {
        withFileTypes: true
      })) {
        this.#readdirAddChild(e, children);
      }
      this.#readdirSuccess(children);
    } catch (er) {
      this.#readdirFail(er.code);
      children.provisional = 0;
    }
    return children.slice(0, children.provisional);
  }
  canReaddir() {
    if (this.#type & ENOCHILD)
      return false;
    const ifmt = IFMT & this.#type;
    if (!(ifmt === UNKNOWN || ifmt === IFDIR || ifmt === IFLNK)) {
      return false;
    }
    return true;
  }
  shouldWalk(dirs, walkFilter) {
    return (this.#type & IFDIR) === IFDIR && !(this.#type & ENOCHILD) && !dirs.has(this) && (!walkFilter || walkFilter(this));
  }
  /**
   * Return the Path object corresponding to path as resolved
   * by realpath(3).
   *
   * If the realpath call fails for any reason, `undefined` is returned.
   *
   * Result is cached, and thus may be outdated if the filesystem is mutated.
   * On success, returns a Path object.
   */
  async realpath() {
    if (this.#realpath)
      return this.#realpath;
    if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
      return void 0;
    try {
      const rp = await this.#fs.promises.realpath(this.fullpath());
      return this.#realpath = this.resolve(rp);
    } catch (_) {
      this.#markENOREALPATH();
    }
  }
  /**
   * Synchronous {@link realpath}
   */
  realpathSync() {
    if (this.#realpath)
      return this.#realpath;
    if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
      return void 0;
    try {
      const rp = this.#fs.realpathSync(this.fullpath());
      return this.#realpath = this.resolve(rp);
    } catch (_) {
      this.#markENOREALPATH();
    }
  }
  /**
   * Internal method to mark this Path object as the scurry cwd,
   * called by {@link PathScurry#chdir}
   *
   * @internal
   */
  [setAsCwd](oldCwd) {
    if (oldCwd === this)
      return;
    oldCwd.isCWD = false;
    this.isCWD = true;
    const changed = /* @__PURE__ */ new Set([]);
    let rp = [];
    let p = this;
    while (p && p.parent) {
      changed.add(p);
      p.#relative = rp.join(this.sep);
      p.#relativePosix = rp.join("/");
      p = p.parent;
      rp.push("..");
    }
    p = oldCwd;
    while (p && p.parent && !changed.has(p)) {
      p.#relative = void 0;
      p.#relativePosix = void 0;
      p = p.parent;
    }
  }
};
var PathWin32 = class _PathWin32 extends PathBase {
  /**
   * Separator for generating path strings.
   */
  sep = "\\";
  /**
   * Separator for parsing path strings.
   */
  splitSep = eitherSep;
  /**
   * Do not create new Path objects directly.  They should always be accessed
   * via the PathScurry class or other methods on the Path class.
   *
   * @internal
   */
  constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {
    super(name, type, root, roots, nocase, children, opts);
  }
  /**
   * @internal
   */
  newChild(name, type = UNKNOWN, opts = {}) {
    return new _PathWin32(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
  }
  /**
   * @internal
   */
  getRootString(path2) {
    return import_node_path.win32.parse(path2).root;
  }
  /**
   * @internal
   */
  getRoot(rootPath) {
    rootPath = uncToDrive(rootPath.toUpperCase());
    if (rootPath === this.root.name) {
      return this.root;
    }
    for (const [compare, root] of Object.entries(this.roots)) {
      if (this.sameRoot(rootPath, compare)) {
        return this.roots[rootPath] = root;
      }
    }
    return this.roots[rootPath] = new PathScurryWin32(rootPath, this).root;
  }
  /**
   * @internal
   */
  sameRoot(rootPath, compare = this.root.name) {
    rootPath = rootPath.toUpperCase().replace(/\//g, "\\").replace(uncDriveRegexp, "$1\\");
    return rootPath === compare;
  }
};
var PathPosix = class _PathPosix extends PathBase {
  /**
   * separator for parsing path strings
   */
  splitSep = "/";
  /**
   * separator for generating path strings
   */
  sep = "/";
  /**
   * Do not create new Path objects directly.  They should always be accessed
   * via the PathScurry class or other methods on the Path class.
   *
   * @internal
   */
  constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {
    super(name, type, root, roots, nocase, children, opts);
  }
  /**
   * @internal
   */
  getRootString(path2) {
    return path2.startsWith("/") ? "/" : "";
  }
  /**
   * @internal
   */
  getRoot(_rootPath) {
    return this.root;
  }
  /**
   * @internal
   */
  newChild(name, type = UNKNOWN, opts = {}) {
    return new _PathPosix(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
  }
};
var PathScurryBase = class {
  /**
   * The root Path entry for the current working directory of this Scurry
   */
  root;
  /**
   * The string path for the root of this Scurry's current working directory
   */
  rootPath;
  /**
   * A collection of all roots encountered, referenced by rootPath
   */
  roots;
  /**
   * The Path entry corresponding to this PathScurry's current working directory.
   */
  cwd;
  #resolveCache;
  #resolvePosixCache;
  #children;
  /**
   * Perform path comparisons case-insensitively.
   *
   * Defaults true on Darwin and Windows systems, false elsewhere.
   */
  nocase;
  #fs;
  /**
   * This class should not be instantiated directly.
   *
   * Use PathScurryWin32, PathScurryDarwin, PathScurryPosix, or PathScurry
   *
   * @internal
   */
  constructor(cwd = process.cwd(), pathImpl, sep2, { nocase, childrenCacheSize = 16 * 1024, fs = defaultFS } = {}) {
    this.#fs = fsFromOption(fs);
    if (cwd instanceof URL || cwd.startsWith("file://")) {
      cwd = (0, import_node_url.fileURLToPath)(cwd);
    }
    const cwdPath = pathImpl.resolve(cwd);
    this.roots = /* @__PURE__ */ Object.create(null);
    this.rootPath = this.parseRootPath(cwdPath);
    this.#resolveCache = new ResolveCache();
    this.#resolvePosixCache = new ResolveCache();
    this.#children = new ChildrenCache(childrenCacheSize);
    const split = cwdPath.substring(this.rootPath.length).split(sep2);
    if (split.length === 1 && !split[0]) {
      split.pop();
    }
    if (nocase === void 0) {
      throw new TypeError("must provide nocase setting to PathScurryBase ctor");
    }
    this.nocase = nocase;
    this.root = this.newRoot(this.#fs);
    this.roots[this.rootPath] = this.root;
    let prev = this.root;
    let len = split.length - 1;
    const joinSep = pathImpl.sep;
    let abs = this.rootPath;
    let sawFirst = false;
    for (const part of split) {
      const l = len--;
      prev = prev.child(part, {
        relative: new Array(l).fill("..").join(joinSep),
        relativePosix: new Array(l).fill("..").join("/"),
        fullpath: abs += (sawFirst ? "" : joinSep) + part
      });
      sawFirst = true;
    }
    this.cwd = prev;
  }
  /**
   * Get the depth of a provided path, string, or the cwd
   */
  depth(path2 = this.cwd) {
    if (typeof path2 === "string") {
      path2 = this.cwd.resolve(path2);
    }
    return path2.depth();
  }
  /**
   * Return the cache of child entries.  Exposed so subclasses can create
   * child Path objects in a platform-specific way.
   *
   * @internal
   */
  childrenCache() {
    return this.#children;
  }
  /**
   * Resolve one or more path strings to a resolved string
   *
   * Same interface as require('path').resolve.
   *
   * Much faster than path.resolve() when called multiple times for the same
   * path, because the resolved Path objects are cached.  Much slower
   * otherwise.
   */
  resolve(...paths) {
    let r = "";
    for (let i = paths.length - 1; i >= 0; i--) {
      const p = paths[i];
      if (!p || p === ".")
        continue;
      r = r ? `${p}/${r}` : p;
      if (this.isAbsolute(p)) {
        break;
      }
    }
    const cached = this.#resolveCache.get(r);
    if (cached !== void 0) {
      return cached;
    }
    const result = this.cwd.resolve(r).fullpath();
    this.#resolveCache.set(r, result);
    return result;
  }
  /**
   * Resolve one or more path strings to a resolved string, returning
   * the posix path.  Identical to .resolve() on posix systems, but on
   * windows will return a forward-slash separated UNC path.
   *
   * Same interface as require('path').resolve.
   *
   * Much faster than path.resolve() when called multiple times for the same
   * path, because the resolved Path objects are cached.  Much slower
   * otherwise.
   */
  resolvePosix(...paths) {
    let r = "";
    for (let i = paths.length - 1; i >= 0; i--) {
      const p = paths[i];
      if (!p || p === ".")
        continue;
      r = r ? `${p}/${r}` : p;
      if (this.isAbsolute(p)) {
        break;
      }
    }
    const cached = this.#resolvePosixCache.get(r);
    if (cached !== void 0) {
      return cached;
    }
    const result = this.cwd.resolve(r).fullpathPosix();
    this.#resolvePosixCache.set(r, result);
    return result;
  }
  /**
   * find the relative path from the cwd to the supplied path string or entry
   */
  relative(entry = this.cwd) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    }
    return entry.relative();
  }
  /**
   * find the relative path from the cwd to the supplied path string or
   * entry, using / as the path delimiter, even on Windows.
   */
  relativePosix(entry = this.cwd) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    }
    return entry.relativePosix();
  }
  /**
   * Return the basename for the provided string or Path object
   */
  basename(entry = this.cwd) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    }
    return entry.name;
  }
  /**
   * Return the dirname for the provided string or Path object
   */
  dirname(entry = this.cwd) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    }
    return (entry.parent || entry).fullpath();
  }
  async readdir(entry = this.cwd, opts = {
    withFileTypes: true
  }) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      opts = entry;
      entry = this.cwd;
    }
    const { withFileTypes } = opts;
    if (!entry.canReaddir()) {
      return [];
    } else {
      const p = await entry.readdir();
      return withFileTypes ? p : p.map((e) => e.name);
    }
  }
  readdirSync(entry = this.cwd, opts = {
    withFileTypes: true
  }) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      opts = entry;
      entry = this.cwd;
    }
    const { withFileTypes = true } = opts;
    if (!entry.canReaddir()) {
      return [];
    } else if (withFileTypes) {
      return entry.readdirSync();
    } else {
      return entry.readdirSync().map((e) => e.name);
    }
  }
  /**
   * Call lstat() on the string or Path object, and update all known
   * information that can be determined.
   *
   * Note that unlike `fs.lstat()`, the returned value does not contain some
   * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
   * information is required, you will need to call `fs.lstat` yourself.
   *
   * If the Path refers to a nonexistent file, or if the lstat call fails for
   * any reason, `undefined` is returned.  Otherwise the updated Path object is
   * returned.
   *
   * Results are cached, and thus may be out of date if the filesystem is
   * mutated.
   */
  async lstat(entry = this.cwd) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    }
    return entry.lstat();
  }
  /**
   * synchronous {@link PathScurryBase.lstat}
   */
  lstatSync(entry = this.cwd) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    }
    return entry.lstatSync();
  }
  async readlink(entry = this.cwd, { withFileTypes } = {
    withFileTypes: false
  }) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      withFileTypes = entry.withFileTypes;
      entry = this.cwd;
    }
    const e = await entry.readlink();
    return withFileTypes ? e : e?.fullpath();
  }
  readlinkSync(entry = this.cwd, { withFileTypes } = {
    withFileTypes: false
  }) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      withFileTypes = entry.withFileTypes;
      entry = this.cwd;
    }
    const e = entry.readlinkSync();
    return withFileTypes ? e : e?.fullpath();
  }
  async realpath(entry = this.cwd, { withFileTypes } = {
    withFileTypes: false
  }) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      withFileTypes = entry.withFileTypes;
      entry = this.cwd;
    }
    const e = await entry.realpath();
    return withFileTypes ? e : e?.fullpath();
  }
  realpathSync(entry = this.cwd, { withFileTypes } = {
    withFileTypes: false
  }) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      withFileTypes = entry.withFileTypes;
      entry = this.cwd;
    }
    const e = entry.realpathSync();
    return withFileTypes ? e : e?.fullpath();
  }
  async walk(entry = this.cwd, opts = {}) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      opts = entry;
      entry = this.cwd;
    }
    const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
    const results = [];
    if (!filter2 || filter2(entry)) {
      results.push(withFileTypes ? entry : entry.fullpath());
    }
    const dirs = /* @__PURE__ */ new Set();
    const walk = (dir, cb) => {
      dirs.add(dir);
      dir.readdirCB((er, entries) => {
        if (er) {
          return cb(er);
        }
        let len = entries.length;
        if (!len)
          return cb();
        const next = () => {
          if (--len === 0) {
            cb();
          }
        };
        for (const e of entries) {
          if (!filter2 || filter2(e)) {
            results.push(withFileTypes ? e : e.fullpath());
          }
          if (follow && e.isSymbolicLink()) {
            e.realpath().then((r) => r?.isUnknown() ? r.lstat() : r).then((r) => r?.shouldWalk(dirs, walkFilter) ? walk(r, next) : next());
          } else {
            if (e.shouldWalk(dirs, walkFilter)) {
              walk(e, next);
            } else {
              next();
            }
          }
        }
      }, true);
    };
    const start = entry;
    return new Promise((res, rej) => {
      walk(start, (er) => {
        if (er)
          return rej(er);
        res(results);
      });
    });
  }
  walkSync(entry = this.cwd, opts = {}) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      opts = entry;
      entry = this.cwd;
    }
    const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
    const results = [];
    if (!filter2 || filter2(entry)) {
      results.push(withFileTypes ? entry : entry.fullpath());
    }
    const dirs = /* @__PURE__ */ new Set([entry]);
    for (const dir of dirs) {
      const entries = dir.readdirSync();
      for (const e of entries) {
        if (!filter2 || filter2(e)) {
          results.push(withFileTypes ? e : e.fullpath());
        }
        let r = e;
        if (e.isSymbolicLink()) {
          if (!(follow && (r = e.realpathSync())))
            continue;
          if (r.isUnknown())
            r.lstatSync();
        }
        if (r.shouldWalk(dirs, walkFilter)) {
          dirs.add(r);
        }
      }
    }
    return results;
  }
  /**
   * Support for `for await`
   *
   * Alias for {@link PathScurryBase.iterate}
   *
   * Note: As of Node 19, this is very slow, compared to other methods of
   * walking.  Consider using {@link PathScurryBase.stream} if memory overhead
   * and backpressure are concerns, or {@link PathScurryBase.walk} if not.
   */
  [Symbol.asyncIterator]() {
    return this.iterate();
  }
  iterate(entry = this.cwd, options = {}) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      options = entry;
      entry = this.cwd;
    }
    return this.stream(entry, options)[Symbol.asyncIterator]();
  }
  /**
   * Iterating over a PathScurry performs a synchronous walk.
   *
   * Alias for {@link PathScurryBase.iterateSync}
   */
  [Symbol.iterator]() {
    return this.iterateSync();
  }
  *iterateSync(entry = this.cwd, opts = {}) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      opts = entry;
      entry = this.cwd;
    }
    const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
    if (!filter2 || filter2(entry)) {
      yield withFileTypes ? entry : entry.fullpath();
    }
    const dirs = /* @__PURE__ */ new Set([entry]);
    for (const dir of dirs) {
      const entries = dir.readdirSync();
      for (const e of entries) {
        if (!filter2 || filter2(e)) {
          yield withFileTypes ? e : e.fullpath();
        }
        let r = e;
        if (e.isSymbolicLink()) {
          if (!(follow && (r = e.realpathSync())))
            continue;
          if (r.isUnknown())
            r.lstatSync();
        }
        if (r.shouldWalk(dirs, walkFilter)) {
          dirs.add(r);
        }
      }
    }
  }
  stream(entry = this.cwd, opts = {}) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      opts = entry;
      entry = this.cwd;
    }
    const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
    const results = new Minipass({ objectMode: true });
    if (!filter2 || filter2(entry)) {
      results.write(withFileTypes ? entry : entry.fullpath());
    }
    const dirs = /* @__PURE__ */ new Set();
    const queue = [entry];
    let processing = 0;
    const process2 = () => {
      let paused = false;
      while (!paused) {
        const dir = queue.shift();
        if (!dir) {
          if (processing === 0)
            results.end();
          return;
        }
        processing++;
        dirs.add(dir);
        const onReaddir = (er, entries, didRealpaths = false) => {
          if (er)
            return results.emit("error", er);
          if (follow && !didRealpaths) {
            const promises = [];
            for (const e of entries) {
              if (e.isSymbolicLink()) {
                promises.push(e.realpath().then((r) => r?.isUnknown() ? r.lstat() : r));
              }
            }
            if (promises.length) {
              Promise.all(promises).then(() => onReaddir(null, entries, true));
              return;
            }
          }
          for (const e of entries) {
            if (e && (!filter2 || filter2(e))) {
              if (!results.write(withFileTypes ? e : e.fullpath())) {
                paused = true;
              }
            }
          }
          processing--;
          for (const e of entries) {
            const r = e.realpathCached() || e;
            if (r.shouldWalk(dirs, walkFilter)) {
              queue.push(r);
            }
          }
          if (paused && !results.flowing) {
            results.once("drain", process2);
          } else if (!sync2) {
            process2();
          }
        };
        let sync2 = true;
        dir.readdirCB(onReaddir, true);
        sync2 = false;
      }
    };
    process2();
    return results;
  }
  streamSync(entry = this.cwd, opts = {}) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      opts = entry;
      entry = this.cwd;
    }
    const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
    const results = new Minipass({ objectMode: true });
    const dirs = /* @__PURE__ */ new Set();
    if (!filter2 || filter2(entry)) {
      results.write(withFileTypes ? entry : entry.fullpath());
    }
    const queue = [entry];
    let processing = 0;
    const process2 = () => {
      let paused = false;
      while (!paused) {
        const dir = queue.shift();
        if (!dir) {
          if (processing === 0)
            results.end();
          return;
        }
        processing++;
        dirs.add(dir);
        const entries = dir.readdirSync();
        for (const e of entries) {
          if (!filter2 || filter2(e)) {
            if (!results.write(withFileTypes ? e : e.fullpath())) {
              paused = true;
            }
          }
        }
        processing--;
        for (const e of entries) {
          let r = e;
          if (e.isSymbolicLink()) {
            if (!(follow && (r = e.realpathSync())))
              continue;
            if (r.isUnknown())
              r.lstatSync();
          }
          if (r.shouldWalk(dirs, walkFilter)) {
            queue.push(r);
          }
        }
      }
      if (paused && !results.flowing)
        results.once("drain", process2);
    };
    process2();
    return results;
  }
  chdir(path2 = this.cwd) {
    const oldCwd = this.cwd;
    this.cwd = typeof path2 === "string" ? this.cwd.resolve(path2) : path2;
    this.cwd[setAsCwd](oldCwd);
  }
};
var PathScurryWin32 = class extends PathScurryBase {
  /**
   * separator for generating path strings
   */
  sep = "\\";
  constructor(cwd = process.cwd(), opts = {}) {
    const { nocase = true } = opts;
    super(cwd, import_node_path.win32, "\\", { ...opts, nocase });
    this.nocase = nocase;
    for (let p = this.cwd; p; p = p.parent) {
      p.nocase = this.nocase;
    }
  }
  /**
   * @internal
   */
  parseRootPath(dir) {
    return import_node_path.win32.parse(dir).root.toUpperCase();
  }
  /**
   * @internal
   */
  newRoot(fs) {
    return new PathWin32(this.rootPath, IFDIR, void 0, this.roots, this.nocase, this.childrenCache(), { fs });
  }
  /**
   * Return true if the provided path string is an absolute path
   */
  isAbsolute(p) {
    return p.startsWith("/") || p.startsWith("\\") || /^[a-z]:(\/|\\)/i.test(p);
  }
};
var PathScurryPosix = class extends PathScurryBase {
  /**
   * separator for generating path strings
   */
  sep = "/";
  constructor(cwd = process.cwd(), opts = {}) {
    const { nocase = false } = opts;
    super(cwd, import_node_path.posix, "/", { ...opts, nocase });
    this.nocase = nocase;
  }
  /**
   * @internal
   */
  parseRootPath(_dir) {
    return "/";
  }
  /**
   * @internal
   */
  newRoot(fs) {
    return new PathPosix(this.rootPath, IFDIR, void 0, this.roots, this.nocase, this.childrenCache(), { fs });
  }
  /**
   * Return true if the provided path string is an absolute path
   */
  isAbsolute(p) {
    return p.startsWith("/");
  }
};
var PathScurryDarwin = class extends PathScurryPosix {
  constructor(cwd = process.cwd(), opts = {}) {
    const { nocase = true } = opts;
    super(cwd, { ...opts, nocase });
  }
};
var Path = process.platform === "win32" ? PathWin32 : PathPosix;
var PathScurry = process.platform === "win32" ? PathScurryWin32 : process.platform === "darwin" ? PathScurryDarwin : PathScurryPosix;

// ../../node_modules/.pnpm/glob@11.0.2/node_modules/glob/dist/esm/pattern.js
init_importMeta();
var isPatternList = (pl) => pl.length >= 1;
var isGlobList = (gl) => gl.length >= 1;
var Pattern = class _Pattern {
  #patternList;
  #globList;
  #index;
  length;
  #platform;
  #rest;
  #globString;
  #isDrive;
  #isUNC;
  #isAbsolute;
  #followGlobstar = true;
  constructor(patternList, globList, index, platform) {
    if (!isPatternList(patternList)) {
      throw new TypeError("empty pattern list");
    }
    if (!isGlobList(globList)) {
      throw new TypeError("empty glob list");
    }
    if (globList.length !== patternList.length) {
      throw new TypeError("mismatched pattern list and glob list lengths");
    }
    this.length = patternList.length;
    if (index < 0 || index >= this.length) {
      throw new TypeError("index out of range");
    }
    this.#patternList = patternList;
    this.#globList = globList;
    this.#index = index;
    this.#platform = platform;
    if (this.#index === 0) {
      if (this.isUNC()) {
        const [p0, p1, p2, p3, ...prest] = this.#patternList;
        const [g0, g1, g2, g3, ...grest] = this.#globList;
        if (prest[0] === "") {
          prest.shift();
          grest.shift();
        }
        const p = [p0, p1, p2, p3, ""].join("/");
        const g = [g0, g1, g2, g3, ""].join("/");
        this.#patternList = [p, ...prest];
        this.#globList = [g, ...grest];
        this.length = this.#patternList.length;
      } else if (this.isDrive() || this.isAbsolute()) {
        const [p1, ...prest] = this.#patternList;
        const [g1, ...grest] = this.#globList;
        if (prest[0] === "") {
          prest.shift();
          grest.shift();
        }
        const p = p1 + "/";
        const g = g1 + "/";
        this.#patternList = [p, ...prest];
        this.#globList = [g, ...grest];
        this.length = this.#patternList.length;
      }
    }
  }
  /**
   * The first entry in the parsed list of patterns
   */
  pattern() {
    return this.#patternList[this.#index];
  }
  /**
   * true of if pattern() returns a string
   */
  isString() {
    return typeof this.#patternList[this.#index] === "string";
  }
  /**
   * true of if pattern() returns GLOBSTAR
   */
  isGlobstar() {
    return this.#patternList[this.#index] === GLOBSTAR;
  }
  /**
   * true if pattern() returns a regexp
   */
  isRegExp() {
    return this.#patternList[this.#index] instanceof RegExp;
  }
  /**
   * The /-joined set of glob parts that make up this pattern
   */
  globString() {
    return this.#globString = this.#globString || (this.#index === 0 ? this.isAbsolute() ? this.#globList[0] + this.#globList.slice(1).join("/") : this.#globList.join("/") : this.#globList.slice(this.#index).join("/"));
  }
  /**
   * true if there are more pattern parts after this one
   */
  hasMore() {
    return this.length > this.#index + 1;
  }
  /**
   * The rest of the pattern after this part, or null if this is the end
   */
  rest() {
    if (this.#rest !== void 0)
      return this.#rest;
    if (!this.hasMore())
      return this.#rest = null;
    this.#rest = new _Pattern(this.#patternList, this.#globList, this.#index + 1, this.#platform);
    this.#rest.#isAbsolute = this.#isAbsolute;
    this.#rest.#isUNC = this.#isUNC;
    this.#rest.#isDrive = this.#isDrive;
    return this.#rest;
  }
  /**
   * true if the pattern represents a //unc/path/ on windows
   */
  isUNC() {
    const pl = this.#patternList;
    return this.#isUNC !== void 0 ? this.#isUNC : this.#isUNC = this.#platform === "win32" && this.#index === 0 && pl[0] === "" && pl[1] === "" && typeof pl[2] === "string" && !!pl[2] && typeof pl[3] === "string" && !!pl[3];
  }
  // pattern like C:/...
  // split = ['C:', ...]
  // XXX: would be nice to handle patterns like `c:*` to test the cwd
  // in c: for *, but I don't know of a way to even figure out what that
  // cwd is without actually chdir'ing into it?
  /**
   * True if the pattern starts with a drive letter on Windows
   */
  isDrive() {
    const pl = this.#patternList;
    return this.#isDrive !== void 0 ? this.#isDrive : this.#isDrive = this.#platform === "win32" && this.#index === 0 && this.length > 1 && typeof pl[0] === "string" && /^[a-z]:$/i.test(pl[0]);
  }
  // pattern = '/' or '/...' or '/x/...'
  // split = ['', ''] or ['', ...] or ['', 'x', ...]
  // Drive and UNC both considered absolute on windows
  /**
   * True if the pattern is rooted on an absolute path
   */
  isAbsolute() {
    const pl = this.#patternList;
    return this.#isAbsolute !== void 0 ? this.#isAbsolute : this.#isAbsolute = pl[0] === "" && pl.length > 1 || this.isDrive() || this.isUNC();
  }
  /**
   * consume the root of the pattern, and return it
   */
  root() {
    const p = this.#patternList[0];
    return typeof p === "string" && this.isAbsolute() && this.#index === 0 ? p : "";
  }
  /**
   * Check to see if the current globstar pattern is allowed to follow
   * a symbolic link.
   */
  checkFollowGlobstar() {
    return !(this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar);
  }
  /**
   * Mark that the current globstar pattern is following a symbolic link
   */
  markFollowGlobstar() {
    if (this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar)
      return false;
    this.#followGlobstar = false;
    return true;
  }
};

// ../../node_modules/.pnpm/glob@11.0.2/node_modules/glob/dist/esm/walker.js
init_importMeta();

// ../../node_modules/.pnpm/glob@11.0.2/node_modules/glob/dist/esm/ignore.js
init_importMeta();
var defaultPlatform2 = typeof process === "object" && process && typeof process.platform === "string" ? process.platform : "linux";
var Ignore = class {
  relative;
  relativeChildren;
  absolute;
  absoluteChildren;
  platform;
  mmopts;
  constructor(ignored, { nobrace, nocase, noext, noglobstar, platform = defaultPlatform2 }) {
    this.relative = [];
    this.absolute = [];
    this.relativeChildren = [];
    this.absoluteChildren = [];
    this.platform = platform;
    this.mmopts = {
      dot: true,
      nobrace,
      nocase,
      noext,
      noglobstar,
      optimizationLevel: 2,
      platform,
      nocomment: true,
      nonegate: true
    };
    for (const ign of ignored)
      this.add(ign);
  }
  add(ign) {
    const mm = new Minimatch(ign, this.mmopts);
    for (let i = 0; i < mm.set.length; i++) {
      const parsed = mm.set[i];
      const globParts = mm.globParts[i];
      if (!parsed || !globParts) {
        throw new Error("invalid pattern object");
      }
      while (parsed[0] === "." && globParts[0] === ".") {
        parsed.shift();
        globParts.shift();
      }
      const p = new Pattern(parsed, globParts, 0, this.platform);
      const m = new Minimatch(p.globString(), this.mmopts);
      const children = globParts[globParts.length - 1] === "**";
      const absolute = p.isAbsolute();
      if (absolute)
        this.absolute.push(m);
      else
        this.relative.push(m);
      if (children) {
        if (absolute)
          this.absoluteChildren.push(m);
        else
          this.relativeChildren.push(m);
      }
    }
  }
  ignored(p) {
    const fullpath = p.fullpath();
    const fullpaths = `${fullpath}/`;
    const relative = p.relative() || ".";
    const relatives = `${relative}/`;
    for (const m of this.relative) {
      if (m.match(relative) || m.match(relatives))
        return true;
    }
    for (const m of this.absolute) {
      if (m.match(fullpath) || m.match(fullpaths))
        return true;
    }
    return false;
  }
  childrenIgnored(p) {
    const fullpath = p.fullpath() + "/";
    const relative = (p.relative() || ".") + "/";
    for (const m of this.relativeChildren) {
      if (m.match(relative))
        return true;
    }
    for (const m of this.absoluteChildren) {
      if (m.match(fullpath))
        return true;
    }
    return false;
  }
};

// ../../node_modules/.pnpm/glob@11.0.2/node_modules/glob/dist/esm/processor.js
init_importMeta();
var HasWalkedCache = class _HasWalkedCache {
  store;
  constructor(store = /* @__PURE__ */ new Map()) {
    this.store = store;
  }
  copy() {
    return new _HasWalkedCache(new Map(this.store));
  }
  hasWalked(target, pattern) {
    return this.store.get(target.fullpath())?.has(pattern.globString());
  }
  storeWalked(target, pattern) {
    const fullpath = target.fullpath();
    const cached = this.store.get(fullpath);
    if (cached)
      cached.add(pattern.globString());
    else
      this.store.set(fullpath, /* @__PURE__ */ new Set([pattern.globString()]));
  }
};
var MatchRecord = class {
  store = /* @__PURE__ */ new Map();
  add(target, absolute, ifDir) {
    const n = (absolute ? 2 : 0) | (ifDir ? 1 : 0);
    const current = this.store.get(target);
    this.store.set(target, current === void 0 ? n : n & current);
  }
  // match, absolute, ifdir
  entries() {
    return [...this.store.entries()].map(([path2, n]) => [
      path2,
      !!(n & 2),
      !!(n & 1)
    ]);
  }
};
var SubWalks = class {
  store = /* @__PURE__ */ new Map();
  add(target, pattern) {
    if (!target.canReaddir()) {
      return;
    }
    const subs = this.store.get(target);
    if (subs) {
      if (!subs.find((p) => p.globString() === pattern.globString())) {
        subs.push(pattern);
      }
    } else
      this.store.set(target, [pattern]);
  }
  get(target) {
    const subs = this.store.get(target);
    if (!subs) {
      throw new Error("attempting to walk unknown path");
    }
    return subs;
  }
  entries() {
    return this.keys().map((k) => [k, this.store.get(k)]);
  }
  keys() {
    return [...this.store.keys()].filter((t) => t.canReaddir());
  }
};
var Processor = class _Processor {
  hasWalkedCache;
  matches = new MatchRecord();
  subwalks = new SubWalks();
  patterns;
  follow;
  dot;
  opts;
  constructor(opts, hasWalkedCache) {
    this.opts = opts;
    this.follow = !!opts.follow;
    this.dot = !!opts.dot;
    this.hasWalkedCache = hasWalkedCache ? hasWalkedCache.copy() : new HasWalkedCache();
  }
  processPatterns(target, patterns) {
    this.patterns = patterns;
    const processingSet = patterns.map((p) => [target, p]);
    for (let [t, pattern] of processingSet) {
      this.hasWalkedCache.storeWalked(t, pattern);
      const root = pattern.root();
      const absolute = pattern.isAbsolute() && this.opts.absolute !== false;
      if (root) {
        t = t.resolve(root === "/" && this.opts.root !== void 0 ? this.opts.root : root);
        const rest2 = pattern.rest();
        if (!rest2) {
          this.matches.add(t, true, false);
          continue;
        } else {
          pattern = rest2;
        }
      }
      if (t.isENOENT())
        continue;
      let p;
      let rest;
      let changed = false;
      while (typeof (p = pattern.pattern()) === "string" && (rest = pattern.rest())) {
        const c = t.resolve(p);
        t = c;
        pattern = rest;
        changed = true;
      }
      p = pattern.pattern();
      rest = pattern.rest();
      if (changed) {
        if (this.hasWalkedCache.hasWalked(t, pattern))
          continue;
        this.hasWalkedCache.storeWalked(t, pattern);
      }
      if (typeof p === "string") {
        const ifDir = p === ".." || p === "" || p === ".";
        this.matches.add(t.resolve(p), absolute, ifDir);
        continue;
      } else if (p === GLOBSTAR) {
        if (!t.isSymbolicLink() || this.follow || pattern.checkFollowGlobstar()) {
          this.subwalks.add(t, pattern);
        }
        const rp = rest?.pattern();
        const rrest = rest?.rest();
        if (!rest || (rp === "" || rp === ".") && !rrest) {
          this.matches.add(t, absolute, rp === "" || rp === ".");
        } else {
          if (rp === "..") {
            const tp = t.parent || t;
            if (!rrest)
              this.matches.add(tp, absolute, true);
            else if (!this.hasWalkedCache.hasWalked(tp, rrest)) {
              this.subwalks.add(tp, rrest);
            }
          }
        }
      } else if (p instanceof RegExp) {
        this.subwalks.add(t, pattern);
      }
    }
    return this;
  }
  subwalkTargets() {
    return this.subwalks.keys();
  }
  child() {
    return new _Processor(this.opts, this.hasWalkedCache);
  }
  // return a new Processor containing the subwalks for each
  // child entry, and a set of matches, and
  // a hasWalkedCache that's a copy of this one
  // then we're going to call
  filterEntries(parent, entries) {
    const patterns = this.subwalks.get(parent);
    const results = this.child();
    for (const e of entries) {
      for (const pattern of patterns) {
        const absolute = pattern.isAbsolute();
        const p = pattern.pattern();
        const rest = pattern.rest();
        if (p === GLOBSTAR) {
          results.testGlobstar(e, pattern, rest, absolute);
        } else if (p instanceof RegExp) {
          results.testRegExp(e, p, rest, absolute);
        } else {
          results.testString(e, p, rest, absolute);
        }
      }
    }
    return results;
  }
  testGlobstar(e, pattern, rest, absolute) {
    if (this.dot || !e.name.startsWith(".")) {
      if (!pattern.hasMore()) {
        this.matches.add(e, absolute, false);
      }
      if (e.canReaddir()) {
        if (this.follow || !e.isSymbolicLink()) {
          this.subwalks.add(e, pattern);
        } else if (e.isSymbolicLink()) {
          if (rest && pattern.checkFollowGlobstar()) {
            this.subwalks.add(e, rest);
          } else if (pattern.markFollowGlobstar()) {
            this.subwalks.add(e, pattern);
          }
        }
      }
    }
    if (rest) {
      const rp = rest.pattern();
      if (typeof rp === "string" && // dots and empty were handled already
      rp !== ".." && rp !== "" && rp !== ".") {
        this.testString(e, rp, rest.rest(), absolute);
      } else if (rp === "..") {
        const ep = e.parent || e;
        this.subwalks.add(ep, rest);
      } else if (rp instanceof RegExp) {
        this.testRegExp(e, rp, rest.rest(), absolute);
      }
    }
  }
  testRegExp(e, p, rest, absolute) {
    if (!p.test(e.name))
      return;
    if (!rest) {
      this.matches.add(e, absolute, false);
    } else {
      this.subwalks.add(e, rest);
    }
  }
  testString(e, p, rest, absolute) {
    if (!e.isNamed(p))
      return;
    if (!rest) {
      this.matches.add(e, absolute, false);
    } else {
      this.subwalks.add(e, rest);
    }
  }
};

// ../../node_modules/.pnpm/glob@11.0.2/node_modules/glob/dist/esm/walker.js
var makeIgnore = (ignore, opts) => typeof ignore === "string" ? new Ignore([ignore], opts) : Array.isArray(ignore) ? new Ignore(ignore, opts) : ignore;
var GlobUtil = class {
  path;
  patterns;
  opts;
  seen = /* @__PURE__ */ new Set();
  paused = false;
  aborted = false;
  #onResume = [];
  #ignore;
  #sep;
  signal;
  maxDepth;
  includeChildMatches;
  constructor(patterns, path2, opts) {
    this.patterns = patterns;
    this.path = path2;
    this.opts = opts;
    this.#sep = !opts.posix && opts.platform === "win32" ? "\\" : "/";
    this.includeChildMatches = opts.includeChildMatches !== false;
    if (opts.ignore || !this.includeChildMatches) {
      this.#ignore = makeIgnore(opts.ignore ?? [], opts);
      if (!this.includeChildMatches && typeof this.#ignore.add !== "function") {
        const m = "cannot ignore child matches, ignore lacks add() method.";
        throw new Error(m);
      }
    }
    this.maxDepth = opts.maxDepth || Infinity;
    if (opts.signal) {
      this.signal = opts.signal;
      this.signal.addEventListener("abort", () => {
        this.#onResume.length = 0;
      });
    }
  }
  #ignored(path2) {
    return this.seen.has(path2) || !!this.#ignore?.ignored?.(path2);
  }
  #childrenIgnored(path2) {
    return !!this.#ignore?.childrenIgnored?.(path2);
  }
  // backpressure mechanism
  pause() {
    this.paused = true;
  }
  resume() {
    if (this.signal?.aborted)
      return;
    this.paused = false;
    let fn = void 0;
    while (!this.paused && (fn = this.#onResume.shift())) {
      fn();
    }
  }
  onResume(fn) {
    if (this.signal?.aborted)
      return;
    if (!this.paused) {
      fn();
    } else {
      this.#onResume.push(fn);
    }
  }
  // do the requisite realpath/stat checking, and return the path
  // to add or undefined to filter it out.
  async matchCheck(e, ifDir) {
    if (ifDir && this.opts.nodir)
      return void 0;
    let rpc;
    if (this.opts.realpath) {
      rpc = e.realpathCached() || await e.realpath();
      if (!rpc)
        return void 0;
      e = rpc;
    }
    const needStat = e.isUnknown() || this.opts.stat;
    const s = needStat ? await e.lstat() : e;
    if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
      const target = await s.realpath();
      if (target && (target.isUnknown() || this.opts.stat)) {
        await target.lstat();
      }
    }
    return this.matchCheckTest(s, ifDir);
  }
  matchCheckTest(e, ifDir) {
    return e && (this.maxDepth === Infinity || e.depth() <= this.maxDepth) && (!ifDir || e.canReaddir()) && (!this.opts.nodir || !e.isDirectory()) && (!this.opts.nodir || !this.opts.follow || !e.isSymbolicLink() || !e.realpathCached()?.isDirectory()) && !this.#ignored(e) ? e : void 0;
  }
  matchCheckSync(e, ifDir) {
    if (ifDir && this.opts.nodir)
      return void 0;
    let rpc;
    if (this.opts.realpath) {
      rpc = e.realpathCached() || e.realpathSync();
      if (!rpc)
        return void 0;
      e = rpc;
    }
    const needStat = e.isUnknown() || this.opts.stat;
    const s = needStat ? e.lstatSync() : e;
    if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
      const target = s.realpathSync();
      if (target && (target?.isUnknown() || this.opts.stat)) {
        target.lstatSync();
      }
    }
    return this.matchCheckTest(s, ifDir);
  }
  matchFinish(e, absolute) {
    if (this.#ignored(e))
      return;
    if (!this.includeChildMatches && this.#ignore?.add) {
      const ign = `${e.relativePosix()}/**`;
      this.#ignore.add(ign);
    }
    const abs = this.opts.absolute === void 0 ? absolute : this.opts.absolute;
    this.seen.add(e);
    const mark = this.opts.mark && e.isDirectory() ? this.#sep : "";
    if (this.opts.withFileTypes) {
      this.matchEmit(e);
    } else if (abs) {
      const abs2 = this.opts.posix ? e.fullpathPosix() : e.fullpath();
      this.matchEmit(abs2 + mark);
    } else {
      const rel = this.opts.posix ? e.relativePosix() : e.relative();
      const pre = this.opts.dotRelative && !rel.startsWith(".." + this.#sep) ? "." + this.#sep : "";
      this.matchEmit(!rel ? "." + mark : pre + rel + mark);
    }
  }
  async match(e, absolute, ifDir) {
    const p = await this.matchCheck(e, ifDir);
    if (p)
      this.matchFinish(p, absolute);
  }
  matchSync(e, absolute, ifDir) {
    const p = this.matchCheckSync(e, ifDir);
    if (p)
      this.matchFinish(p, absolute);
  }
  walkCB(target, patterns, cb) {
    if (this.signal?.aborted)
      cb();
    this.walkCB2(target, patterns, new Processor(this.opts), cb);
  }
  walkCB2(target, patterns, processor, cb) {
    if (this.#childrenIgnored(target))
      return cb();
    if (this.signal?.aborted)
      cb();
    if (this.paused) {
      this.onResume(() => this.walkCB2(target, patterns, processor, cb));
      return;
    }
    processor.processPatterns(target, patterns);
    let tasks = 1;
    const next = () => {
      if (--tasks === 0)
        cb();
    };
    for (const [m, absolute, ifDir] of processor.matches.entries()) {
      if (this.#ignored(m))
        continue;
      tasks++;
      this.match(m, absolute, ifDir).then(() => next());
    }
    for (const t of processor.subwalkTargets()) {
      if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
        continue;
      }
      tasks++;
      const childrenCached = t.readdirCached();
      if (t.calledReaddir())
        this.walkCB3(t, childrenCached, processor, next);
      else {
        t.readdirCB((_, entries) => this.walkCB3(t, entries, processor, next), true);
      }
    }
    next();
  }
  walkCB3(target, entries, processor, cb) {
    processor = processor.filterEntries(target, entries);
    let tasks = 1;
    const next = () => {
      if (--tasks === 0)
        cb();
    };
    for (const [m, absolute, ifDir] of processor.matches.entries()) {
      if (this.#ignored(m))
        continue;
      tasks++;
      this.match(m, absolute, ifDir).then(() => next());
    }
    for (const [target2, patterns] of processor.subwalks.entries()) {
      tasks++;
      this.walkCB2(target2, patterns, processor.child(), next);
    }
    next();
  }
  walkCBSync(target, patterns, cb) {
    if (this.signal?.aborted)
      cb();
    this.walkCB2Sync(target, patterns, new Processor(this.opts), cb);
  }
  walkCB2Sync(target, patterns, processor, cb) {
    if (this.#childrenIgnored(target))
      return cb();
    if (this.signal?.aborted)
      cb();
    if (this.paused) {
      this.onResume(() => this.walkCB2Sync(target, patterns, processor, cb));
      return;
    }
    processor.processPatterns(target, patterns);
    let tasks = 1;
    const next = () => {
      if (--tasks === 0)
        cb();
    };
    for (const [m, absolute, ifDir] of processor.matches.entries()) {
      if (this.#ignored(m))
        continue;
      this.matchSync(m, absolute, ifDir);
    }
    for (const t of processor.subwalkTargets()) {
      if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
        continue;
      }
      tasks++;
      const children = t.readdirSync();
      this.walkCB3Sync(t, children, processor, next);
    }
    next();
  }
  walkCB3Sync(target, entries, processor, cb) {
    processor = processor.filterEntries(target, entries);
    let tasks = 1;
    const next = () => {
      if (--tasks === 0)
        cb();
    };
    for (const [m, absolute, ifDir] of processor.matches.entries()) {
      if (this.#ignored(m))
        continue;
      this.matchSync(m, absolute, ifDir);
    }
    for (const [target2, patterns] of processor.subwalks.entries()) {
      tasks++;
      this.walkCB2Sync(target2, patterns, processor.child(), next);
    }
    next();
  }
};
var GlobWalker = class extends GlobUtil {
  matches = /* @__PURE__ */ new Set();
  constructor(patterns, path2, opts) {
    super(patterns, path2, opts);
  }
  matchEmit(e) {
    this.matches.add(e);
  }
  async walk() {
    if (this.signal?.aborted)
      throw this.signal.reason;
    if (this.path.isUnknown()) {
      await this.path.lstat();
    }
    await new Promise((res, rej) => {
      this.walkCB(this.path, this.patterns, () => {
        if (this.signal?.aborted) {
          rej(this.signal.reason);
        } else {
          res(this.matches);
        }
      });
    });
    return this.matches;
  }
  walkSync() {
    if (this.signal?.aborted)
      throw this.signal.reason;
    if (this.path.isUnknown()) {
      this.path.lstatSync();
    }
    this.walkCBSync(this.path, this.patterns, () => {
      if (this.signal?.aborted)
        throw this.signal.reason;
    });
    return this.matches;
  }
};
var GlobStream = class extends GlobUtil {
  results;
  constructor(patterns, path2, opts) {
    super(patterns, path2, opts);
    this.results = new Minipass({
      signal: this.signal,
      objectMode: true
    });
    this.results.on("drain", () => this.resume());
    this.results.on("resume", () => this.resume());
  }
  matchEmit(e) {
    this.results.write(e);
    if (!this.results.flowing)
      this.pause();
  }
  stream() {
    const target = this.path;
    if (target.isUnknown()) {
      target.lstat().then(() => {
        this.walkCB(target, this.patterns, () => this.results.end());
      });
    } else {
      this.walkCB(target, this.patterns, () => this.results.end());
    }
    return this.results;
  }
  streamSync() {
    if (this.path.isUnknown()) {
      this.path.lstatSync();
    }
    this.walkCBSync(this.path, this.patterns, () => this.results.end());
    return this.results;
  }
};

// ../../node_modules/.pnpm/glob@11.0.2/node_modules/glob/dist/esm/glob.js
var defaultPlatform3 = typeof process === "object" && process && typeof process.platform === "string" ? process.platform : "linux";
var Glob = class {
  absolute;
  cwd;
  root;
  dot;
  dotRelative;
  follow;
  ignore;
  magicalBraces;
  mark;
  matchBase;
  maxDepth;
  nobrace;
  nocase;
  nodir;
  noext;
  noglobstar;
  pattern;
  platform;
  realpath;
  scurry;
  stat;
  signal;
  windowsPathsNoEscape;
  withFileTypes;
  includeChildMatches;
  /**
   * The options provided to the constructor.
   */
  opts;
  /**
   * An array of parsed immutable {@link Pattern} objects.
   */
  patterns;
  /**
   * All options are stored as properties on the `Glob` object.
   *
   * See {@link GlobOptions} for full options descriptions.
   *
   * Note that a previous `Glob` object can be passed as the
   * `GlobOptions` to another `Glob` instantiation to re-use settings
   * and caches with a new pattern.
   *
   * Traversal functions can be called multiple times to run the walk
   * again.
   */
  constructor(pattern, opts) {
    if (!opts)
      throw new TypeError("glob options required");
    this.withFileTypes = !!opts.withFileTypes;
    this.signal = opts.signal;
    this.follow = !!opts.follow;
    this.dot = !!opts.dot;
    this.dotRelative = !!opts.dotRelative;
    this.nodir = !!opts.nodir;
    this.mark = !!opts.mark;
    if (!opts.cwd) {
      this.cwd = "";
    } else if (opts.cwd instanceof URL || opts.cwd.startsWith("file://")) {
      opts.cwd = (0, import_node_url2.fileURLToPath)(opts.cwd);
    }
    this.cwd = opts.cwd || "";
    this.root = opts.root;
    this.magicalBraces = !!opts.magicalBraces;
    this.nobrace = !!opts.nobrace;
    this.noext = !!opts.noext;
    this.realpath = !!opts.realpath;
    this.absolute = opts.absolute;
    this.includeChildMatches = opts.includeChildMatches !== false;
    this.noglobstar = !!opts.noglobstar;
    this.matchBase = !!opts.matchBase;
    this.maxDepth = typeof opts.maxDepth === "number" ? opts.maxDepth : Infinity;
    this.stat = !!opts.stat;
    this.ignore = opts.ignore;
    if (this.withFileTypes && this.absolute !== void 0) {
      throw new Error("cannot set absolute and withFileTypes:true");
    }
    if (typeof pattern === "string") {
      pattern = [pattern];
    }
    this.windowsPathsNoEscape = !!opts.windowsPathsNoEscape || opts.allowWindowsEscape === false;
    if (this.windowsPathsNoEscape) {
      pattern = pattern.map((p) => p.replace(/\\/g, "/"));
    }
    if (this.matchBase) {
      if (opts.noglobstar) {
        throw new TypeError("base matching requires globstar");
      }
      pattern = pattern.map((p) => p.includes("/") ? p : `./**/${p}`);
    }
    this.pattern = pattern;
    this.platform = opts.platform || defaultPlatform3;
    this.opts = { ...opts, platform: this.platform };
    if (opts.scurry) {
      this.scurry = opts.scurry;
      if (opts.nocase !== void 0 && opts.nocase !== opts.scurry.nocase) {
        throw new Error("nocase option contradicts provided scurry option");
      }
    } else {
      const Scurry = opts.platform === "win32" ? PathScurryWin32 : opts.platform === "darwin" ? PathScurryDarwin : opts.platform ? PathScurryPosix : PathScurry;
      this.scurry = new Scurry(this.cwd, {
        nocase: opts.nocase,
        fs: opts.fs
      });
    }
    this.nocase = this.scurry.nocase;
    const nocaseMagicOnly = this.platform === "darwin" || this.platform === "win32";
    const mmo = {
      // default nocase based on platform
      ...opts,
      dot: this.dot,
      matchBase: this.matchBase,
      nobrace: this.nobrace,
      nocase: this.nocase,
      nocaseMagicOnly,
      nocomment: true,
      noext: this.noext,
      nonegate: true,
      optimizationLevel: 2,
      platform: this.platform,
      windowsPathsNoEscape: this.windowsPathsNoEscape,
      debug: !!this.opts.debug
    };
    const mms = this.pattern.map((p) => new Minimatch(p, mmo));
    const [matchSet, globParts] = mms.reduce((set, m) => {
      set[0].push(...m.set);
      set[1].push(...m.globParts);
      return set;
    }, [[], []]);
    this.patterns = matchSet.map((set, i) => {
      const g = globParts[i];
      if (!g)
        throw new Error("invalid pattern object");
      return new Pattern(set, g, 0, this.platform);
    });
  }
  async walk() {
    return [
      ...await new GlobWalker(this.patterns, this.scurry.cwd, {
        ...this.opts,
        maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
        platform: this.platform,
        nocase: this.nocase,
        includeChildMatches: this.includeChildMatches
      }).walk()
    ];
  }
  walkSync() {
    return [
      ...new GlobWalker(this.patterns, this.scurry.cwd, {
        ...this.opts,
        maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
        platform: this.platform,
        nocase: this.nocase,
        includeChildMatches: this.includeChildMatches
      }).walkSync()
    ];
  }
  stream() {
    return new GlobStream(this.patterns, this.scurry.cwd, {
      ...this.opts,
      maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
      platform: this.platform,
      nocase: this.nocase,
      includeChildMatches: this.includeChildMatches
    }).stream();
  }
  streamSync() {
    return new GlobStream(this.patterns, this.scurry.cwd, {
      ...this.opts,
      maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
      platform: this.platform,
      nocase: this.nocase,
      includeChildMatches: this.includeChildMatches
    }).streamSync();
  }
  /**
   * Default sync iteration function. Returns a Generator that
   * iterates over the results.
   */
  iterateSync() {
    return this.streamSync()[Symbol.iterator]();
  }
  [Symbol.iterator]() {
    return this.iterateSync();
  }
  /**
   * Default async iteration function. Returns an AsyncGenerator that
   * iterates over the results.
   */
  iterate() {
    return this.stream()[Symbol.asyncIterator]();
  }
  [Symbol.asyncIterator]() {
    return this.iterate();
  }
};

// ../../node_modules/.pnpm/glob@11.0.2/node_modules/glob/dist/esm/has-magic.js
init_importMeta();
var hasMagic = (pattern, options = {}) => {
  if (!Array.isArray(pattern)) {
    pattern = [pattern];
  }
  for (const p of pattern) {
    if (new Minimatch(p, options).hasMagic())
      return true;
  }
  return false;
};

// ../../node_modules/.pnpm/glob@11.0.2/node_modules/glob/dist/esm/index.js
function globStreamSync(pattern, options = {}) {
  return new Glob(pattern, options).streamSync();
}
function globStream(pattern, options = {}) {
  return new Glob(pattern, options).stream();
}
function globSync(pattern, options = {}) {
  return new Glob(pattern, options).walkSync();
}
async function glob_(pattern, options = {}) {
  return new Glob(pattern, options).walk();
}
function globIterateSync(pattern, options = {}) {
  return new Glob(pattern, options).iterateSync();
}
function globIterate(pattern, options = {}) {
  return new Glob(pattern, options).iterate();
}
var streamSync = globStreamSync;
var stream = Object.assign(globStream, { sync: globStreamSync });
var iterateSync = globIterateSync;
var iterate = Object.assign(globIterate, {
  sync: globIterateSync
});
var sync = Object.assign(globSync, {
  stream: globStreamSync,
  iterate: globIterateSync
});
var glob = Object.assign(glob_, {
  glob: glob_,
  globSync,
  sync,
  globStream,
  stream,
  globStreamSync,
  streamSync,
  globIterate,
  iterate,
  globIterateSync,
  iterateSync,
  Glob,
  hasMagic,
  escape,
  unescape
});
glob.glob = glob;

// src/lib.ts
var reportDiagnostics = async ({ document }, connection2) => {
  const lang = await Promise.resolve().then(() => __toESM(require_dist3()));
  const currentFileName = (0, import_node_url3.fileURLToPath)(document.uri).split(process.cwd() + "/").at(-1);
  const fileList = await glob("**/*.aeria");
  const sources = {};
  for (const fileName of fileList) {
    if (fileName === currentFileName) {
      sources[fileName] = document.getText();
    } else {
      sources[fileName] = await (0, import_promises2.readFile)(fileName, {
        encoding: "utf-8"
      });
    }
  }
  const result = await lang.parseAndCheck(sources, {
    languageServer: true
  });
  const diagnostics = [];
  for (const error of result.errors) {
    if (error.location.file !== currentFileName) {
      continue;
    }
    diagnostics.push({
      message: error.message,
      range: {
        start: {
          line: error.location.line - 1,
          character: error.location.start
        },
        end: {
          line: error.location.line - 1,
          character: error.location.end
        }
      }
    });
  }
  connection2.sendDiagnostics({
    uri: document.uri,
    diagnostics
  });
};

// src/index.ts
var connection = (0, import_node.createConnection)(import_node.ProposedFeatures.all);
var documents = new import_node.TextDocuments(TextDocument);
connection.onInitialize(() => {
  const result = {
    capabilities: {}
  };
  return result;
});
documents.onDidChangeContent(async (event) => {
  return reportDiagnostics(event, connection);
});
documents.listen(connection);
connection.listen();
